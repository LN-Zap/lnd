// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: walletrpc/walletkit.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Walletrpc_WitnessType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownWitness // = 0

  ///
  ///A witness that allows us to spend the output of a commitment transaction
  ///after a relative lock-time lockout.
  case commitmentTimeLock // = 1

  ///
  ///A witness that allows us to spend a settled no-delay output immediately on a
  ///counterparty's commitment transaction.
  case commitmentNoDelay // = 2

  ///
  ///A witness that allows us to sweep the settled output of a malicious
  ///counterparty's who broadcasts a revoked commitment transaction.
  case commitmentRevoke // = 3

  ///
  ///A witness that allows us to sweep an HTLC which we offered to the remote
  ///party in the case that they broadcast a revoked commitment state.
  case htlcOfferedRevoke // = 4

  ///
  ///A witness that allows us to sweep an HTLC output sent to us in the case that
  ///the remote party broadcasts a revoked commitment state.
  case htlcAcceptedRevoke // = 5

  ///
  ///A witness that allows us to sweep an HTLC output that we extended to a
  ///party, but was never fulfilled.  This HTLC output isn't directly on the
  ///commitment transaction, but is the result of a confirmed second-level HTLC
  ///transaction. As a result, we can only spend this after a CSV delay.
  case htlcOfferedTimeoutSecondLevel // = 6

  ///
  ///A witness that allows us to sweep an HTLC output that was offered to us, and
  ///for which we have a payment preimage. This HTLC output isn't directly on our
  ///commitment transaction, but is the result of confirmed second-level HTLC
  ///transaction. As a result, we can only spend this after a CSV delay.
  case htlcAcceptedSuccessSecondLevel // = 7

  ///
  ///A witness that allows us to sweep an HTLC that we offered to the remote
  ///party which lies in the commitment transaction of the remote party. We can
  ///spend this output after the absolute CLTV timeout of the HTLC as passed.
  case htlcOfferedRemoteTimeout // = 8

  ///
  ///A witness that allows us to sweep an HTLC that was offered to us by the
  ///remote party. We use this witness in the case that the remote party goes to
  ///chain, and we know the pre-image to the HTLC. We can sweep this without any
  ///additional timeout.
  case htlcAcceptedRemoteSuccess // = 9

  ///
  ///A witness that allows us to sweep an HTLC from the remote party's commitment
  ///transaction in the case that the broadcast a revoked commitment, but then
  ///also immediately attempt to go to the second level to claim the HTLC.
  case htlcSecondLevelRevoke // = 10

  ///
  ///A witness type that allows us to spend a regular p2wkh output that's sent to
  ///an output which is under complete control of the backing wallet.
  case witnessKeyHash // = 11

  ///
  ///A witness type that allows us to sweep an output that sends to a nested P2SH
  ///script that pays to a key solely under our control.
  case nestedWitnessKeyHash // = 12
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownWitness
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownWitness
    case 1: self = .commitmentTimeLock
    case 2: self = .commitmentNoDelay
    case 3: self = .commitmentRevoke
    case 4: self = .htlcOfferedRevoke
    case 5: self = .htlcAcceptedRevoke
    case 6: self = .htlcOfferedTimeoutSecondLevel
    case 7: self = .htlcAcceptedSuccessSecondLevel
    case 8: self = .htlcOfferedRemoteTimeout
    case 9: self = .htlcAcceptedRemoteSuccess
    case 10: self = .htlcSecondLevelRevoke
    case 11: self = .witnessKeyHash
    case 12: self = .nestedWitnessKeyHash
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownWitness: return 0
    case .commitmentTimeLock: return 1
    case .commitmentNoDelay: return 2
    case .commitmentRevoke: return 3
    case .htlcOfferedRevoke: return 4
    case .htlcAcceptedRevoke: return 5
    case .htlcOfferedTimeoutSecondLevel: return 6
    case .htlcAcceptedSuccessSecondLevel: return 7
    case .htlcOfferedRemoteTimeout: return 8
    case .htlcAcceptedRemoteSuccess: return 9
    case .htlcSecondLevelRevoke: return 10
    case .witnessKeyHash: return 11
    case .nestedWitnessKeyHash: return 12
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Walletrpc_WitnessType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Walletrpc_WitnessType] = [
    .unknownWitness,
    .commitmentTimeLock,
    .commitmentNoDelay,
    .commitmentRevoke,
    .htlcOfferedRevoke,
    .htlcAcceptedRevoke,
    .htlcOfferedTimeoutSecondLevel,
    .htlcAcceptedSuccessSecondLevel,
    .htlcOfferedRemoteTimeout,
    .htlcAcceptedRemoteSuccess,
    .htlcSecondLevelRevoke,
    .witnessKeyHash,
    .nestedWitnessKeyHash,
  ]
}

#endif  // swift(>=4.2)

struct Walletrpc_KeyReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///Is the key finger print of the root pubkey that this request is targeting.
  ///This allows the WalletKit to possibly serve out keys for multiple HD chains
  ///via public derivation.
  var keyFingerPrint: Int32 = 0

  ///*
  ///The target key family to derive a key from. In other contexts, this is
  ///known as the "account".
  var keyFamily: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// No fields, as we always give out a p2wkh address.
struct Walletrpc_AddrRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_AddrResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The address encoded using a bech32 format.
  var addr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The raw serialized transaction.
  var txHex: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_PublishResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///If blank, then no error occurred and the transaction was successfully
  ///published. If not the empty string, then a string representation of the
  ///broadcast error.
  ///
  ///TODO(roasbeef): map to a proper enum type
  var publishError: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_SendOutputsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The number of satoshis per kilo weight that should be used when crafting
  ///this transaction.
  var satPerKw: Int64 = 0

  ///*
  ///A slice of the outputs that should be created in the transaction produced.
  var outputs: [Signrpc_TxOut] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_SendOutputsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The serialized transaction sent out on the network.
  var rawTx: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_EstimateFeeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The number of confirmations to shoot for when estimating the fee.
  var confTarget: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_EstimateFeeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The amount of satoshis per kw that should be used in order to reach the
  ///confirmation target in the request.
  var satPerKw: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_PendingSweep {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The outpoint of the output we're attempting to sweep.
  var outpoint: Lnrpc_OutPoint {
    get {return _storage._outpoint ?? Lnrpc_OutPoint()}
    set {_uniqueStorage()._outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return _storage._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {_uniqueStorage()._outpoint = nil}

  /// The witness type of the output we're attempting to sweep.
  var witnessType: Walletrpc_WitnessType {
    get {return _storage._witnessType}
    set {_uniqueStorage()._witnessType = newValue}
  }

  /// The value of the output we're attempting to sweep.
  var amountSat: UInt32 {
    get {return _storage._amountSat}
    set {_uniqueStorage()._amountSat = newValue}
  }

  ///
  ///The fee rate we'll use to sweep the output. The fee rate is only determined
  ///once a sweeping transaction for the output is created, so it's possible for
  ///this to be 0 before this.
  var satPerByte: UInt32 {
    get {return _storage._satPerByte}
    set {_uniqueStorage()._satPerByte = newValue}
  }

  /// The number of broadcast attempts we've made to sweep the output.
  var broadcastAttempts: UInt32 {
    get {return _storage._broadcastAttempts}
    set {_uniqueStorage()._broadcastAttempts = newValue}
  }

  ///
  ///The next height of the chain at which we'll attempt to broadcast the
  ///sweep transaction of the output.
  var nextBroadcastHeight: UInt32 {
    get {return _storage._nextBroadcastHeight}
    set {_uniqueStorage()._nextBroadcastHeight = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Walletrpc_PendingSweepsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_PendingSweepsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The set of outputs currently being swept by lnd's central batching engine.
  var pendingSweeps: [Walletrpc_PendingSweep] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_BumpFeeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The input we're attempting to bump the fee of.
  var outpoint: Lnrpc_OutPoint {
    get {return _storage._outpoint ?? Lnrpc_OutPoint()}
    set {_uniqueStorage()._outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return _storage._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {_uniqueStorage()._outpoint = nil}

  /// The target number of blocks that the input should be spent within.
  var targetConf: UInt32 {
    get {return _storage._targetConf}
    set {_uniqueStorage()._targetConf = newValue}
  }

  ///
  ///The fee rate, expressed in sat/byte, that should be used to spend the input
  ///with.
  var satPerByte: UInt32 {
    get {return _storage._satPerByte}
    set {_uniqueStorage()._satPerByte = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Walletrpc_BumpFeeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "walletrpc"

extension Walletrpc_WitnessType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_WITNESS"),
    1: .same(proto: "COMMITMENT_TIME_LOCK"),
    2: .same(proto: "COMMITMENT_NO_DELAY"),
    3: .same(proto: "COMMITMENT_REVOKE"),
    4: .same(proto: "HTLC_OFFERED_REVOKE"),
    5: .same(proto: "HTLC_ACCEPTED_REVOKE"),
    6: .same(proto: "HTLC_OFFERED_TIMEOUT_SECOND_LEVEL"),
    7: .same(proto: "HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL"),
    8: .same(proto: "HTLC_OFFERED_REMOTE_TIMEOUT"),
    9: .same(proto: "HTLC_ACCEPTED_REMOTE_SUCCESS"),
    10: .same(proto: "HTLC_SECOND_LEVEL_REVOKE"),
    11: .same(proto: "WITNESS_KEY_HASH"),
    12: .same(proto: "NESTED_WITNESS_KEY_HASH"),
  ]
}

extension Walletrpc_KeyReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_finger_print"),
    2: .standard(proto: "key_family"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.keyFingerPrint)
      case 2: try decoder.decodeSingularInt32Field(value: &self.keyFamily)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.keyFingerPrint != 0 {
      try visitor.visitSingularInt32Field(value: self.keyFingerPrint, fieldNumber: 1)
    }
    if self.keyFamily != 0 {
      try visitor.visitSingularInt32Field(value: self.keyFamily, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_KeyReq, rhs: Walletrpc_KeyReq) -> Bool {
    if lhs.keyFingerPrint != rhs.keyFingerPrint {return false}
    if lhs.keyFamily != rhs.keyFamily {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_AddrRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddrRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_AddrRequest, rhs: Walletrpc_AddrRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_AddrResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddrResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.addr)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_AddrResponse, rhs: Walletrpc_AddrResponse) -> Bool {
    if lhs.addr != rhs.addr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Transaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_hex"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.txHex)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txHex.isEmpty {
      try visitor.visitSingularBytesField(value: self.txHex, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_Transaction, rhs: Walletrpc_Transaction) -> Bool {
    if lhs.txHex != rhs.txHex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_PublishResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublishResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "publish_error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.publishError)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publishError.isEmpty {
      try visitor.visitSingularStringField(value: self.publishError, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_PublishResponse, rhs: Walletrpc_PublishResponse) -> Bool {
    if lhs.publishError != rhs.publishError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_SendOutputsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendOutputsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sat_per_kw"),
    2: .same(proto: "outputs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.satPerKw)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.outputs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.satPerKw != 0 {
      try visitor.visitSingularInt64Field(value: self.satPerKw, fieldNumber: 1)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_SendOutputsRequest, rhs: Walletrpc_SendOutputsRequest) -> Bool {
    if lhs.satPerKw != rhs.satPerKw {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_SendOutputsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendOutputsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.rawTx)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rawTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawTx, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_SendOutputsResponse, rhs: Walletrpc_SendOutputsResponse) -> Bool {
    if lhs.rawTx != rhs.rawTx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_EstimateFeeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EstimateFeeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "conf_target"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.confTarget)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.confTarget != 0 {
      try visitor.visitSingularInt32Field(value: self.confTarget, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_EstimateFeeRequest, rhs: Walletrpc_EstimateFeeRequest) -> Bool {
    if lhs.confTarget != rhs.confTarget {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_EstimateFeeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EstimateFeeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sat_per_kw"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.satPerKw)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.satPerKw != 0 {
      try visitor.visitSingularInt64Field(value: self.satPerKw, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_EstimateFeeResponse, rhs: Walletrpc_EstimateFeeResponse) -> Bool {
    if lhs.satPerKw != rhs.satPerKw {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_PendingSweep: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingSweep"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outpoint"),
    2: .same(proto: "witness_type"),
    3: .same(proto: "amount_sat"),
    4: .same(proto: "sat_per_byte"),
    5: .same(proto: "broadcast_attempts"),
    6: .same(proto: "next_broadcast_height"),
  ]

  fileprivate class _StorageClass {
    var _outpoint: Lnrpc_OutPoint? = nil
    var _witnessType: Walletrpc_WitnessType = .unknownWitness
    var _amountSat: UInt32 = 0
    var _satPerByte: UInt32 = 0
    var _broadcastAttempts: UInt32 = 0
    var _nextBroadcastHeight: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _outpoint = source._outpoint
      _witnessType = source._witnessType
      _amountSat = source._amountSat
      _satPerByte = source._satPerByte
      _broadcastAttempts = source._broadcastAttempts
      _nextBroadcastHeight = source._nextBroadcastHeight
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._outpoint)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._witnessType)
        case 3: try decoder.decodeSingularUInt32Field(value: &_storage._amountSat)
        case 4: try decoder.decodeSingularUInt32Field(value: &_storage._satPerByte)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._broadcastAttempts)
        case 6: try decoder.decodeSingularUInt32Field(value: &_storage._nextBroadcastHeight)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._outpoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._witnessType != .unknownWitness {
        try visitor.visitSingularEnumField(value: _storage._witnessType, fieldNumber: 2)
      }
      if _storage._amountSat != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._amountSat, fieldNumber: 3)
      }
      if _storage._satPerByte != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._satPerByte, fieldNumber: 4)
      }
      if _storage._broadcastAttempts != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._broadcastAttempts, fieldNumber: 5)
      }
      if _storage._nextBroadcastHeight != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._nextBroadcastHeight, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_PendingSweep, rhs: Walletrpc_PendingSweep) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._outpoint != rhs_storage._outpoint {return false}
        if _storage._witnessType != rhs_storage._witnessType {return false}
        if _storage._amountSat != rhs_storage._amountSat {return false}
        if _storage._satPerByte != rhs_storage._satPerByte {return false}
        if _storage._broadcastAttempts != rhs_storage._broadcastAttempts {return false}
        if _storage._nextBroadcastHeight != rhs_storage._nextBroadcastHeight {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_PendingSweepsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingSweepsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_PendingSweepsRequest, rhs: Walletrpc_PendingSweepsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_PendingSweepsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingSweepsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pending_sweeps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.pendingSweeps)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pendingSweeps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pendingSweeps, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_PendingSweepsResponse, rhs: Walletrpc_PendingSweepsResponse) -> Bool {
    if lhs.pendingSweeps != rhs.pendingSweeps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_BumpFeeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BumpFeeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outpoint"),
    2: .same(proto: "target_conf"),
    3: .same(proto: "sat_per_byte"),
  ]

  fileprivate class _StorageClass {
    var _outpoint: Lnrpc_OutPoint? = nil
    var _targetConf: UInt32 = 0
    var _satPerByte: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _outpoint = source._outpoint
      _targetConf = source._targetConf
      _satPerByte = source._satPerByte
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._outpoint)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._targetConf)
        case 3: try decoder.decodeSingularUInt32Field(value: &_storage._satPerByte)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._outpoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._targetConf != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._targetConf, fieldNumber: 2)
      }
      if _storage._satPerByte != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._satPerByte, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_BumpFeeRequest, rhs: Walletrpc_BumpFeeRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._outpoint != rhs_storage._outpoint {return false}
        if _storage._targetConf != rhs_storage._targetConf {return false}
        if _storage._satPerByte != rhs_storage._satPerByte {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_BumpFeeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BumpFeeResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_BumpFeeResponse, rhs: Walletrpc_BumpFeeResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
