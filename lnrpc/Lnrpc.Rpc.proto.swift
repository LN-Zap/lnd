/// Generated by the Protocol Buffers 3.6.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 4.0.0
/// Source file "rpc.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Lnrpc { }

public extension Lnrpc {
    public struct RpcRoot {
        public static let `default` = RpcRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Google.Api.AnnotationsRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class GenSeedRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.GenSeedRequest.Builder

        public static func == (lhs: Lnrpc.GenSeedRequest, rhs: Lnrpc.GenSeedRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasAezeedPassphrase == rhs.hasAezeedPassphrase) && (!lhs.hasAezeedPassphrase || lhs.aezeedPassphrase == rhs.aezeedPassphrase)
            fieldCheck = fieldCheck && (lhs.hasSeedEntropy == rhs.hasSeedEntropy) && (!lhs.hasSeedEntropy || lhs.seedEntropy == rhs.seedEntropy)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///*
        ///aezeed_passphrase is an optional user provided passphrase that will be used
        ///to encrypt the generated aezeed cipher seed.
        public fileprivate(set) var aezeedPassphrase:Data! = nil
        public fileprivate(set) var hasAezeedPassphrase:Bool = false

        ///*
        ///seed_entropy is an optional 16-bytes generated via CSPRNG. If not
        ///specified, then a fresh set of randomness will be used to create the seed.
        public fileprivate(set) var seedEntropy:Data! = nil
        public fileprivate(set) var hasSeedEntropy:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasAezeedPassphrase {
                try codedOutputStream.writeData(fieldNumber: 1, value:aezeedPassphrase)
            }
            if hasSeedEntropy {
                try codedOutputStream.writeData(fieldNumber: 2, value:seedEntropy)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasAezeedPassphrase {
                serialize_size += aezeedPassphrase.computeDataSize(fieldNumber: 1)
            }
            if hasSeedEntropy {
                serialize_size += seedEntropy.computeDataSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.GenSeedRequest.Builder {
            return Lnrpc.GenSeedRequest.classBuilder() as! Lnrpc.GenSeedRequest.Builder
        }
        public func getBuilder() -> Lnrpc.GenSeedRequest.Builder {
            return classBuilder() as! Lnrpc.GenSeedRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.GenSeedRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.GenSeedRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.GenSeedRequest.Builder {
            return try Lnrpc.GenSeedRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.GenSeedRequest) throws -> Lnrpc.GenSeedRequest.Builder {
            return try Lnrpc.GenSeedRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasAezeedPassphrase {
                jsonMap["aezeedPassphrase"] = aezeedPassphrase.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasSeedEntropy {
                jsonMap["seedEntropy"] = seedEntropy.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.GenSeedRequest {
            return try Lnrpc.GenSeedRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.GenSeedRequest {
            return try Lnrpc.GenSeedRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasAezeedPassphrase {
                output += "\(indent) aezeedPassphrase: \(aezeedPassphrase) \n"
            }
            if hasSeedEntropy {
                output += "\(indent) seedEntropy: \(seedEntropy) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasAezeedPassphrase {
                    hashCode = (hashCode &* 31) &+ aezeedPassphrase.hashValue
                }
                if hasSeedEntropy {
                    hashCode = (hashCode &* 31) &+ seedEntropy.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.GenSeedRequest"
        }
        override public func className() -> String {
            return "Lnrpc.GenSeedRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.GenSeedRequest = Lnrpc.GenSeedRequest()
            public func getMessage() -> Lnrpc.GenSeedRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///*
            ///aezeed_passphrase is an optional user provided passphrase that will be used
            ///to encrypt the generated aezeed cipher seed.
            public var aezeedPassphrase:Data {
                get {
                    return builderResult.aezeedPassphrase
                }
                set (value) {
                    builderResult.hasAezeedPassphrase = true
                    builderResult.aezeedPassphrase = value
                }
            }
            public var hasAezeedPassphrase:Bool {
                get {
                    return builderResult.hasAezeedPassphrase
                }
            }
            @discardableResult
            public func setAezeedPassphrase(_ value:Data) -> Lnrpc.GenSeedRequest.Builder {
                self.aezeedPassphrase = value
                return self
            }
            @discardableResult
            public func clearAezeedPassphrase() -> Lnrpc.GenSeedRequest.Builder{
                builderResult.hasAezeedPassphrase = false
                builderResult.aezeedPassphrase = nil
                return self
            }
            ///*
            ///seed_entropy is an optional 16-bytes generated via CSPRNG. If not
            ///specified, then a fresh set of randomness will be used to create the seed.
            public var seedEntropy:Data {
                get {
                    return builderResult.seedEntropy
                }
                set (value) {
                    builderResult.hasSeedEntropy = true
                    builderResult.seedEntropy = value
                }
            }
            public var hasSeedEntropy:Bool {
                get {
                    return builderResult.hasSeedEntropy
                }
            }
            @discardableResult
            public func setSeedEntropy(_ value:Data) -> Lnrpc.GenSeedRequest.Builder {
                self.seedEntropy = value
                return self
            }
            @discardableResult
            public func clearSeedEntropy() -> Lnrpc.GenSeedRequest.Builder{
                builderResult.hasSeedEntropy = false
                builderResult.seedEntropy = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.GenSeedRequest.Builder {
                builderResult = Lnrpc.GenSeedRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.GenSeedRequest.Builder {
                return try Lnrpc.GenSeedRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.GenSeedRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.GenSeedRequest {
                let returnMe:Lnrpc.GenSeedRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.GenSeedRequest) throws -> Lnrpc.GenSeedRequest.Builder {
                if other == Lnrpc.GenSeedRequest() {
                    return self
                }
                if other.hasAezeedPassphrase {
                    aezeedPassphrase = other.aezeedPassphrase
                }
                if other.hasSeedEntropy {
                    seedEntropy = other.seedEntropy
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.GenSeedRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GenSeedRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        aezeedPassphrase = try codedInputStream.readData()

                    case 18:
                        seedEntropy = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.GenSeedRequest.Builder {
                let resultDecodedBuilder = Lnrpc.GenSeedRequest.Builder()
                if let jsonValueAezeedPassphrase = jsonMap["aezeedPassphrase"] as? String {
                    resultDecodedBuilder.aezeedPassphrase = Data(base64Encoded:jsonValueAezeedPassphrase, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueSeedEntropy = jsonMap["seedEntropy"] as? String {
                    resultDecodedBuilder.seedEntropy = Data(base64Encoded:jsonValueSeedEntropy, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.GenSeedRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.GenSeedRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GenSeedResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.GenSeedResponse.Builder

        public static func == (lhs: Lnrpc.GenSeedResponse, rhs: Lnrpc.GenSeedResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.cipherSeedMnemonic == rhs.cipherSeedMnemonic)
            fieldCheck = fieldCheck && (lhs.hasEncipheredSeed == rhs.hasEncipheredSeed) && (!lhs.hasEncipheredSeed || lhs.encipheredSeed == rhs.encipheredSeed)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///*
        ///cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
        ///cipher seed obtained by the user. This field is optional, as if not
        ///provided, then the daemon will generate a new cipher seed for the user.
        ///Otherwise, then the daemon will attempt to recover the wallet state linked
        ///to this cipher seed.
        public fileprivate(set) var cipherSeedMnemonic:Array<String> = Array<String>()
        ///*
        ///enciphered_seed are the raw aezeed cipher seed bytes. This is the raw
        ///cipher text before run through our mnemonic encoding scheme.
        public fileprivate(set) var encipheredSeed:Data! = nil
        public fileprivate(set) var hasEncipheredSeed:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if !cipherSeedMnemonic.isEmpty {
                for oneValuecipherSeedMnemonic in cipherSeedMnemonic {
                    try codedOutputStream.writeString(fieldNumber: 1, value:oneValuecipherSeedMnemonic)
                }
            }
            if hasEncipheredSeed {
                try codedOutputStream.writeData(fieldNumber: 2, value:encipheredSeed)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            var dataSizeCipherSeedMnemonic:Int32 = 0
            for oneValuecipherSeedMnemonic in cipherSeedMnemonic {
                dataSizeCipherSeedMnemonic += oneValuecipherSeedMnemonic.computeStringSizeNoTag()
            }
            serialize_size += dataSizeCipherSeedMnemonic
            serialize_size += 1 * Int32(cipherSeedMnemonic.count)
            if hasEncipheredSeed {
                serialize_size += encipheredSeed.computeDataSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.GenSeedResponse.Builder {
            return Lnrpc.GenSeedResponse.classBuilder() as! Lnrpc.GenSeedResponse.Builder
        }
        public func getBuilder() -> Lnrpc.GenSeedResponse.Builder {
            return classBuilder() as! Lnrpc.GenSeedResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.GenSeedResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.GenSeedResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.GenSeedResponse.Builder {
            return try Lnrpc.GenSeedResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.GenSeedResponse) throws -> Lnrpc.GenSeedResponse.Builder {
            return try Lnrpc.GenSeedResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !cipherSeedMnemonic.isEmpty {
                var jsonArrayCipherSeedMnemonic:Array<String> = []
                for oneValueCipherSeedMnemonic in cipherSeedMnemonic {
                    jsonArrayCipherSeedMnemonic.append(oneValueCipherSeedMnemonic)
                }
                jsonMap["cipherSeedMnemonic"] = jsonArrayCipherSeedMnemonic
            }
            if hasEncipheredSeed {
                jsonMap["encipheredSeed"] = encipheredSeed.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.GenSeedResponse {
            return try Lnrpc.GenSeedResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.GenSeedResponse {
            return try Lnrpc.GenSeedResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var cipherSeedMnemonicElementIndex:Int = 0
            for oneValueCipherSeedMnemonic in cipherSeedMnemonic  {
                output += "\(indent) cipherSeedMnemonic[\(cipherSeedMnemonicElementIndex)]: \(oneValueCipherSeedMnemonic)\n"
                cipherSeedMnemonicElementIndex += 1
            }
            if hasEncipheredSeed {
                output += "\(indent) encipheredSeed: \(encipheredSeed) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValueCipherSeedMnemonic in cipherSeedMnemonic {
                    hashCode = (hashCode &* 31) &+ oneValueCipherSeedMnemonic.hashValue
                }
                if hasEncipheredSeed {
                    hashCode = (hashCode &* 31) &+ encipheredSeed.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.GenSeedResponse"
        }
        override public func className() -> String {
            return "Lnrpc.GenSeedResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.GenSeedResponse = Lnrpc.GenSeedResponse()
            public func getMessage() -> Lnrpc.GenSeedResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///*
            ///cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
            ///cipher seed obtained by the user. This field is optional, as if not
            ///provided, then the daemon will generate a new cipher seed for the user.
            ///Otherwise, then the daemon will attempt to recover the wallet state linked
            ///to this cipher seed.
            public var cipherSeedMnemonic:Array<String> {
                get {
                    return builderResult.cipherSeedMnemonic
                }
                set (array) {
                    builderResult.cipherSeedMnemonic = array
                }
            }
            @discardableResult
            public func setCipherSeedMnemonic(_ value:Array<String>) -> Lnrpc.GenSeedResponse.Builder {
                self.cipherSeedMnemonic = value
                return self
            }
            @discardableResult
            public func clearCipherSeedMnemonic() -> Lnrpc.GenSeedResponse.Builder {
                builderResult.cipherSeedMnemonic.removeAll(keepingCapacity: false)
                return self
            }
            ///*
            ///enciphered_seed are the raw aezeed cipher seed bytes. This is the raw
            ///cipher text before run through our mnemonic encoding scheme.
            public var encipheredSeed:Data {
                get {
                    return builderResult.encipheredSeed
                }
                set (value) {
                    builderResult.hasEncipheredSeed = true
                    builderResult.encipheredSeed = value
                }
            }
            public var hasEncipheredSeed:Bool {
                get {
                    return builderResult.hasEncipheredSeed
                }
            }
            @discardableResult
            public func setEncipheredSeed(_ value:Data) -> Lnrpc.GenSeedResponse.Builder {
                self.encipheredSeed = value
                return self
            }
            @discardableResult
            public func clearEncipheredSeed() -> Lnrpc.GenSeedResponse.Builder{
                builderResult.hasEncipheredSeed = false
                builderResult.encipheredSeed = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.GenSeedResponse.Builder {
                builderResult = Lnrpc.GenSeedResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.GenSeedResponse.Builder {
                return try Lnrpc.GenSeedResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.GenSeedResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.GenSeedResponse {
                let returnMe:Lnrpc.GenSeedResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.GenSeedResponse) throws -> Lnrpc.GenSeedResponse.Builder {
                if other == Lnrpc.GenSeedResponse() {
                    return self
                }
                if !other.cipherSeedMnemonic.isEmpty {
                    builderResult.cipherSeedMnemonic += other.cipherSeedMnemonic
                }
                if other.hasEncipheredSeed {
                    encipheredSeed = other.encipheredSeed
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.GenSeedResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GenSeedResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        cipherSeedMnemonic += [try codedInputStream.readString()]

                    case 18:
                        encipheredSeed = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.GenSeedResponse.Builder {
                let resultDecodedBuilder = Lnrpc.GenSeedResponse.Builder()
                if let jsonValueCipherSeedMnemonic = jsonMap["cipherSeedMnemonic"] as? Array<String> {
                    var jsonArrayCipherSeedMnemonic:Array<String> = []
                    for oneValueCipherSeedMnemonic in jsonValueCipherSeedMnemonic {
                        jsonArrayCipherSeedMnemonic.append(oneValueCipherSeedMnemonic)
                    }
                    resultDecodedBuilder.cipherSeedMnemonic = jsonArrayCipherSeedMnemonic
                }
                if let jsonValueEncipheredSeed = jsonMap["encipheredSeed"] as? String {
                    resultDecodedBuilder.encipheredSeed = Data(base64Encoded:jsonValueEncipheredSeed, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.GenSeedResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.GenSeedResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class InitWalletRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.InitWalletRequest.Builder

        public static func == (lhs: Lnrpc.InitWalletRequest, rhs: Lnrpc.InitWalletRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasWalletPassword == rhs.hasWalletPassword) && (!lhs.hasWalletPassword || lhs.walletPassword == rhs.walletPassword)
            fieldCheck = fieldCheck && (lhs.cipherSeedMnemonic == rhs.cipherSeedMnemonic)
            fieldCheck = fieldCheck && (lhs.hasAezeedPassphrase == rhs.hasAezeedPassphrase) && (!lhs.hasAezeedPassphrase || lhs.aezeedPassphrase == rhs.aezeedPassphrase)
            fieldCheck = fieldCheck && (lhs.hasRecoveryWindow == rhs.hasRecoveryWindow) && (!lhs.hasRecoveryWindow || lhs.recoveryWindow == rhs.recoveryWindow)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///*
        ///wallet_password is the passphrase that should be used to encrypt the
        ///wallet. This MUST be at least 8 chars in length. After creation, this
        ///password is required to unlock the daemon.
        public fileprivate(set) var walletPassword:Data! = nil
        public fileprivate(set) var hasWalletPassword:Bool = false

        ///*
        ///cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
        ///cipher seed obtained by the user. This may have been generated by the
        ///GenSeed method, or be an existing seed.
        public fileprivate(set) var cipherSeedMnemonic:Array<String> = Array<String>()
        ///*
        ///aezeed_passphrase is an optional user provided passphrase that will be used
        ///to encrypt the generated aezeed cipher seed.
        public fileprivate(set) var aezeedPassphrase:Data! = nil
        public fileprivate(set) var hasAezeedPassphrase:Bool = false

        ///*
        ///recovery_window is an optional argument specifying the address lookahead
        ///when restoring a wallet seed. The recovery window applies to each
        ///invdividual branch of the BIP44 derivation paths. Supplying a recovery
        ///window of zero indicates that no addresses should be recovered, such after
        ///the first initialization of the wallet.
        public fileprivate(set) var recoveryWindow:Int32! = nil
        public fileprivate(set) var hasRecoveryWindow:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasWalletPassword {
                try codedOutputStream.writeData(fieldNumber: 1, value:walletPassword)
            }
            if !cipherSeedMnemonic.isEmpty {
                for oneValuecipherSeedMnemonic in cipherSeedMnemonic {
                    try codedOutputStream.writeString(fieldNumber: 2, value:oneValuecipherSeedMnemonic)
                }
            }
            if hasAezeedPassphrase {
                try codedOutputStream.writeData(fieldNumber: 3, value:aezeedPassphrase)
            }
            if hasRecoveryWindow {
                try codedOutputStream.writeInt32(fieldNumber: 4, value:recoveryWindow)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasWalletPassword {
                serialize_size += walletPassword.computeDataSize(fieldNumber: 1)
            }
            var dataSizeCipherSeedMnemonic:Int32 = 0
            for oneValuecipherSeedMnemonic in cipherSeedMnemonic {
                dataSizeCipherSeedMnemonic += oneValuecipherSeedMnemonic.computeStringSizeNoTag()
            }
            serialize_size += dataSizeCipherSeedMnemonic
            serialize_size += 1 * Int32(cipherSeedMnemonic.count)
            if hasAezeedPassphrase {
                serialize_size += aezeedPassphrase.computeDataSize(fieldNumber: 3)
            }
            if hasRecoveryWindow {
                serialize_size += recoveryWindow.computeInt32Size(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.InitWalletRequest.Builder {
            return Lnrpc.InitWalletRequest.classBuilder() as! Lnrpc.InitWalletRequest.Builder
        }
        public func getBuilder() -> Lnrpc.InitWalletRequest.Builder {
            return classBuilder() as! Lnrpc.InitWalletRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.InitWalletRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.InitWalletRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.InitWalletRequest.Builder {
            return try Lnrpc.InitWalletRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.InitWalletRequest) throws -> Lnrpc.InitWalletRequest.Builder {
            return try Lnrpc.InitWalletRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasWalletPassword {
                jsonMap["walletPassword"] = walletPassword.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if !cipherSeedMnemonic.isEmpty {
                var jsonArrayCipherSeedMnemonic:Array<String> = []
                for oneValueCipherSeedMnemonic in cipherSeedMnemonic {
                    jsonArrayCipherSeedMnemonic.append(oneValueCipherSeedMnemonic)
                }
                jsonMap["cipherSeedMnemonic"] = jsonArrayCipherSeedMnemonic
            }
            if hasAezeedPassphrase {
                jsonMap["aezeedPassphrase"] = aezeedPassphrase.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasRecoveryWindow {
                jsonMap["recoveryWindow"] = Int(recoveryWindow)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.InitWalletRequest {
            return try Lnrpc.InitWalletRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.InitWalletRequest {
            return try Lnrpc.InitWalletRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasWalletPassword {
                output += "\(indent) walletPassword: \(walletPassword) \n"
            }
            var cipherSeedMnemonicElementIndex:Int = 0
            for oneValueCipherSeedMnemonic in cipherSeedMnemonic  {
                output += "\(indent) cipherSeedMnemonic[\(cipherSeedMnemonicElementIndex)]: \(oneValueCipherSeedMnemonic)\n"
                cipherSeedMnemonicElementIndex += 1
            }
            if hasAezeedPassphrase {
                output += "\(indent) aezeedPassphrase: \(aezeedPassphrase) \n"
            }
            if hasRecoveryWindow {
                output += "\(indent) recoveryWindow: \(recoveryWindow) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasWalletPassword {
                    hashCode = (hashCode &* 31) &+ walletPassword.hashValue
                }
                for oneValueCipherSeedMnemonic in cipherSeedMnemonic {
                    hashCode = (hashCode &* 31) &+ oneValueCipherSeedMnemonic.hashValue
                }
                if hasAezeedPassphrase {
                    hashCode = (hashCode &* 31) &+ aezeedPassphrase.hashValue
                }
                if hasRecoveryWindow {
                    hashCode = (hashCode &* 31) &+ recoveryWindow.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.InitWalletRequest"
        }
        override public func className() -> String {
            return "Lnrpc.InitWalletRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.InitWalletRequest = Lnrpc.InitWalletRequest()
            public func getMessage() -> Lnrpc.InitWalletRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///*
            ///wallet_password is the passphrase that should be used to encrypt the
            ///wallet. This MUST be at least 8 chars in length. After creation, this
            ///password is required to unlock the daemon.
            public var walletPassword:Data {
                get {
                    return builderResult.walletPassword
                }
                set (value) {
                    builderResult.hasWalletPassword = true
                    builderResult.walletPassword = value
                }
            }
            public var hasWalletPassword:Bool {
                get {
                    return builderResult.hasWalletPassword
                }
            }
            @discardableResult
            public func setWalletPassword(_ value:Data) -> Lnrpc.InitWalletRequest.Builder {
                self.walletPassword = value
                return self
            }
            @discardableResult
            public func clearWalletPassword() -> Lnrpc.InitWalletRequest.Builder{
                builderResult.hasWalletPassword = false
                builderResult.walletPassword = nil
                return self
            }
            ///*
            ///cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
            ///cipher seed obtained by the user. This may have been generated by the
            ///GenSeed method, or be an existing seed.
            public var cipherSeedMnemonic:Array<String> {
                get {
                    return builderResult.cipherSeedMnemonic
                }
                set (array) {
                    builderResult.cipherSeedMnemonic = array
                }
            }
            @discardableResult
            public func setCipherSeedMnemonic(_ value:Array<String>) -> Lnrpc.InitWalletRequest.Builder {
                self.cipherSeedMnemonic = value
                return self
            }
            @discardableResult
            public func clearCipherSeedMnemonic() -> Lnrpc.InitWalletRequest.Builder {
                builderResult.cipherSeedMnemonic.removeAll(keepingCapacity: false)
                return self
            }
            ///*
            ///aezeed_passphrase is an optional user provided passphrase that will be used
            ///to encrypt the generated aezeed cipher seed.
            public var aezeedPassphrase:Data {
                get {
                    return builderResult.aezeedPassphrase
                }
                set (value) {
                    builderResult.hasAezeedPassphrase = true
                    builderResult.aezeedPassphrase = value
                }
            }
            public var hasAezeedPassphrase:Bool {
                get {
                    return builderResult.hasAezeedPassphrase
                }
            }
            @discardableResult
            public func setAezeedPassphrase(_ value:Data) -> Lnrpc.InitWalletRequest.Builder {
                self.aezeedPassphrase = value
                return self
            }
            @discardableResult
            public func clearAezeedPassphrase() -> Lnrpc.InitWalletRequest.Builder{
                builderResult.hasAezeedPassphrase = false
                builderResult.aezeedPassphrase = nil
                return self
            }
            ///*
            ///recovery_window is an optional argument specifying the address lookahead
            ///when restoring a wallet seed. The recovery window applies to each
            ///invdividual branch of the BIP44 derivation paths. Supplying a recovery
            ///window of zero indicates that no addresses should be recovered, such after
            ///the first initialization of the wallet.
            public var recoveryWindow:Int32 {
                get {
                    return builderResult.recoveryWindow
                }
                set (value) {
                    builderResult.hasRecoveryWindow = true
                    builderResult.recoveryWindow = value
                }
            }
            public var hasRecoveryWindow:Bool {
                get {
                    return builderResult.hasRecoveryWindow
                }
            }
            @discardableResult
            public func setRecoveryWindow(_ value:Int32) -> Lnrpc.InitWalletRequest.Builder {
                self.recoveryWindow = value
                return self
            }
            @discardableResult
            public func clearRecoveryWindow() -> Lnrpc.InitWalletRequest.Builder{
                builderResult.hasRecoveryWindow = false
                builderResult.recoveryWindow = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.InitWalletRequest.Builder {
                builderResult = Lnrpc.InitWalletRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.InitWalletRequest.Builder {
                return try Lnrpc.InitWalletRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.InitWalletRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.InitWalletRequest {
                let returnMe:Lnrpc.InitWalletRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.InitWalletRequest) throws -> Lnrpc.InitWalletRequest.Builder {
                if other == Lnrpc.InitWalletRequest() {
                    return self
                }
                if other.hasWalletPassword {
                    walletPassword = other.walletPassword
                }
                if !other.cipherSeedMnemonic.isEmpty {
                    builderResult.cipherSeedMnemonic += other.cipherSeedMnemonic
                }
                if other.hasAezeedPassphrase {
                    aezeedPassphrase = other.aezeedPassphrase
                }
                if other.hasRecoveryWindow {
                    recoveryWindow = other.recoveryWindow
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.InitWalletRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.InitWalletRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        walletPassword = try codedInputStream.readData()

                    case 18:
                        cipherSeedMnemonic += [try codedInputStream.readString()]

                    case 26:
                        aezeedPassphrase = try codedInputStream.readData()

                    case 32:
                        recoveryWindow = try codedInputStream.readInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.InitWalletRequest.Builder {
                let resultDecodedBuilder = Lnrpc.InitWalletRequest.Builder()
                if let jsonValueWalletPassword = jsonMap["walletPassword"] as? String {
                    resultDecodedBuilder.walletPassword = Data(base64Encoded:jsonValueWalletPassword, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueCipherSeedMnemonic = jsonMap["cipherSeedMnemonic"] as? Array<String> {
                    var jsonArrayCipherSeedMnemonic:Array<String> = []
                    for oneValueCipherSeedMnemonic in jsonValueCipherSeedMnemonic {
                        jsonArrayCipherSeedMnemonic.append(oneValueCipherSeedMnemonic)
                    }
                    resultDecodedBuilder.cipherSeedMnemonic = jsonArrayCipherSeedMnemonic
                }
                if let jsonValueAezeedPassphrase = jsonMap["aezeedPassphrase"] as? String {
                    resultDecodedBuilder.aezeedPassphrase = Data(base64Encoded:jsonValueAezeedPassphrase, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueRecoveryWindow = jsonMap["recoveryWindow"] as? Int {
                    resultDecodedBuilder.recoveryWindow = Int32(jsonValueRecoveryWindow)
                } else if let jsonValueRecoveryWindow = jsonMap["recoveryWindow"] as? String {
                    resultDecodedBuilder.recoveryWindow = Int32(jsonValueRecoveryWindow)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.InitWalletRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.InitWalletRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class InitWalletResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.InitWalletResponse.Builder

        public static func == (lhs: Lnrpc.InitWalletResponse, rhs: Lnrpc.InitWalletResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.InitWalletResponse.Builder {
            return Lnrpc.InitWalletResponse.classBuilder() as! Lnrpc.InitWalletResponse.Builder
        }
        public func getBuilder() -> Lnrpc.InitWalletResponse.Builder {
            return classBuilder() as! Lnrpc.InitWalletResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.InitWalletResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.InitWalletResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.InitWalletResponse.Builder {
            return try Lnrpc.InitWalletResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.InitWalletResponse) throws -> Lnrpc.InitWalletResponse.Builder {
            return try Lnrpc.InitWalletResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.InitWalletResponse {
            return try Lnrpc.InitWalletResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.InitWalletResponse {
            return try Lnrpc.InitWalletResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.InitWalletResponse"
        }
        override public func className() -> String {
            return "Lnrpc.InitWalletResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.InitWalletResponse = Lnrpc.InitWalletResponse()
            public func getMessage() -> Lnrpc.InitWalletResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.InitWalletResponse.Builder {
                builderResult = Lnrpc.InitWalletResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.InitWalletResponse.Builder {
                return try Lnrpc.InitWalletResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.InitWalletResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.InitWalletResponse {
                let returnMe:Lnrpc.InitWalletResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.InitWalletResponse) throws -> Lnrpc.InitWalletResponse.Builder {
                if other == Lnrpc.InitWalletResponse() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.InitWalletResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.InitWalletResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.InitWalletResponse.Builder {
                let resultDecodedBuilder = Lnrpc.InitWalletResponse.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.InitWalletResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.InitWalletResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class UnlockWalletRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.UnlockWalletRequest.Builder

        public static func == (lhs: Lnrpc.UnlockWalletRequest, rhs: Lnrpc.UnlockWalletRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasWalletPassword == rhs.hasWalletPassword) && (!lhs.hasWalletPassword || lhs.walletPassword == rhs.walletPassword)
            fieldCheck = fieldCheck && (lhs.hasRecoveryWindow == rhs.hasRecoveryWindow) && (!lhs.hasRecoveryWindow || lhs.recoveryWindow == rhs.recoveryWindow)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///*
        ///wallet_password should be the current valid passphrase for the daemon. This
        ///will be required to decrypt on-disk material that the daemon requires to
        ///function properly.
        public fileprivate(set) var walletPassword:Data! = nil
        public fileprivate(set) var hasWalletPassword:Bool = false

        ///*
        ///recovery_window is an optional argument specifying the address lookahead
        ///when restoring a wallet seed. The recovery window applies to each
        ///invdividual branch of the BIP44 derivation paths. Supplying a recovery
        ///window of zero indicates that no addresses should be recovered, such after
        ///the first initialization of the wallet.
        public fileprivate(set) var recoveryWindow:Int32! = nil
        public fileprivate(set) var hasRecoveryWindow:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasWalletPassword {
                try codedOutputStream.writeData(fieldNumber: 1, value:walletPassword)
            }
            if hasRecoveryWindow {
                try codedOutputStream.writeInt32(fieldNumber: 2, value:recoveryWindow)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasWalletPassword {
                serialize_size += walletPassword.computeDataSize(fieldNumber: 1)
            }
            if hasRecoveryWindow {
                serialize_size += recoveryWindow.computeInt32Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.UnlockWalletRequest.Builder {
            return Lnrpc.UnlockWalletRequest.classBuilder() as! Lnrpc.UnlockWalletRequest.Builder
        }
        public func getBuilder() -> Lnrpc.UnlockWalletRequest.Builder {
            return classBuilder() as! Lnrpc.UnlockWalletRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.UnlockWalletRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.UnlockWalletRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.UnlockWalletRequest.Builder {
            return try Lnrpc.UnlockWalletRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.UnlockWalletRequest) throws -> Lnrpc.UnlockWalletRequest.Builder {
            return try Lnrpc.UnlockWalletRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasWalletPassword {
                jsonMap["walletPassword"] = walletPassword.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasRecoveryWindow {
                jsonMap["recoveryWindow"] = Int(recoveryWindow)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.UnlockWalletRequest {
            return try Lnrpc.UnlockWalletRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.UnlockWalletRequest {
            return try Lnrpc.UnlockWalletRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasWalletPassword {
                output += "\(indent) walletPassword: \(walletPassword) \n"
            }
            if hasRecoveryWindow {
                output += "\(indent) recoveryWindow: \(recoveryWindow) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasWalletPassword {
                    hashCode = (hashCode &* 31) &+ walletPassword.hashValue
                }
                if hasRecoveryWindow {
                    hashCode = (hashCode &* 31) &+ recoveryWindow.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.UnlockWalletRequest"
        }
        override public func className() -> String {
            return "Lnrpc.UnlockWalletRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.UnlockWalletRequest = Lnrpc.UnlockWalletRequest()
            public func getMessage() -> Lnrpc.UnlockWalletRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///*
            ///wallet_password should be the current valid passphrase for the daemon. This
            ///will be required to decrypt on-disk material that the daemon requires to
            ///function properly.
            public var walletPassword:Data {
                get {
                    return builderResult.walletPassword
                }
                set (value) {
                    builderResult.hasWalletPassword = true
                    builderResult.walletPassword = value
                }
            }
            public var hasWalletPassword:Bool {
                get {
                    return builderResult.hasWalletPassword
                }
            }
            @discardableResult
            public func setWalletPassword(_ value:Data) -> Lnrpc.UnlockWalletRequest.Builder {
                self.walletPassword = value
                return self
            }
            @discardableResult
            public func clearWalletPassword() -> Lnrpc.UnlockWalletRequest.Builder{
                builderResult.hasWalletPassword = false
                builderResult.walletPassword = nil
                return self
            }
            ///*
            ///recovery_window is an optional argument specifying the address lookahead
            ///when restoring a wallet seed. The recovery window applies to each
            ///invdividual branch of the BIP44 derivation paths. Supplying a recovery
            ///window of zero indicates that no addresses should be recovered, such after
            ///the first initialization of the wallet.
            public var recoveryWindow:Int32 {
                get {
                    return builderResult.recoveryWindow
                }
                set (value) {
                    builderResult.hasRecoveryWindow = true
                    builderResult.recoveryWindow = value
                }
            }
            public var hasRecoveryWindow:Bool {
                get {
                    return builderResult.hasRecoveryWindow
                }
            }
            @discardableResult
            public func setRecoveryWindow(_ value:Int32) -> Lnrpc.UnlockWalletRequest.Builder {
                self.recoveryWindow = value
                return self
            }
            @discardableResult
            public func clearRecoveryWindow() -> Lnrpc.UnlockWalletRequest.Builder{
                builderResult.hasRecoveryWindow = false
                builderResult.recoveryWindow = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.UnlockWalletRequest.Builder {
                builderResult = Lnrpc.UnlockWalletRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.UnlockWalletRequest.Builder {
                return try Lnrpc.UnlockWalletRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.UnlockWalletRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.UnlockWalletRequest {
                let returnMe:Lnrpc.UnlockWalletRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.UnlockWalletRequest) throws -> Lnrpc.UnlockWalletRequest.Builder {
                if other == Lnrpc.UnlockWalletRequest() {
                    return self
                }
                if other.hasWalletPassword {
                    walletPassword = other.walletPassword
                }
                if other.hasRecoveryWindow {
                    recoveryWindow = other.recoveryWindow
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.UnlockWalletRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.UnlockWalletRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        walletPassword = try codedInputStream.readData()

                    case 16:
                        recoveryWindow = try codedInputStream.readInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.UnlockWalletRequest.Builder {
                let resultDecodedBuilder = Lnrpc.UnlockWalletRequest.Builder()
                if let jsonValueWalletPassword = jsonMap["walletPassword"] as? String {
                    resultDecodedBuilder.walletPassword = Data(base64Encoded:jsonValueWalletPassword, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueRecoveryWindow = jsonMap["recoveryWindow"] as? Int {
                    resultDecodedBuilder.recoveryWindow = Int32(jsonValueRecoveryWindow)
                } else if let jsonValueRecoveryWindow = jsonMap["recoveryWindow"] as? String {
                    resultDecodedBuilder.recoveryWindow = Int32(jsonValueRecoveryWindow)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.UnlockWalletRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.UnlockWalletRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class UnlockWalletResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.UnlockWalletResponse.Builder

        public static func == (lhs: Lnrpc.UnlockWalletResponse, rhs: Lnrpc.UnlockWalletResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.UnlockWalletResponse.Builder {
            return Lnrpc.UnlockWalletResponse.classBuilder() as! Lnrpc.UnlockWalletResponse.Builder
        }
        public func getBuilder() -> Lnrpc.UnlockWalletResponse.Builder {
            return classBuilder() as! Lnrpc.UnlockWalletResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.UnlockWalletResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.UnlockWalletResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.UnlockWalletResponse.Builder {
            return try Lnrpc.UnlockWalletResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.UnlockWalletResponse) throws -> Lnrpc.UnlockWalletResponse.Builder {
            return try Lnrpc.UnlockWalletResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.UnlockWalletResponse {
            return try Lnrpc.UnlockWalletResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.UnlockWalletResponse {
            return try Lnrpc.UnlockWalletResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.UnlockWalletResponse"
        }
        override public func className() -> String {
            return "Lnrpc.UnlockWalletResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.UnlockWalletResponse = Lnrpc.UnlockWalletResponse()
            public func getMessage() -> Lnrpc.UnlockWalletResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.UnlockWalletResponse.Builder {
                builderResult = Lnrpc.UnlockWalletResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.UnlockWalletResponse.Builder {
                return try Lnrpc.UnlockWalletResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.UnlockWalletResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.UnlockWalletResponse {
                let returnMe:Lnrpc.UnlockWalletResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.UnlockWalletResponse) throws -> Lnrpc.UnlockWalletResponse.Builder {
                if other == Lnrpc.UnlockWalletResponse() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.UnlockWalletResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.UnlockWalletResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.UnlockWalletResponse.Builder {
                let resultDecodedBuilder = Lnrpc.UnlockWalletResponse.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.UnlockWalletResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.UnlockWalletResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ChangePasswordRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ChangePasswordRequest.Builder

        public static func == (lhs: Lnrpc.ChangePasswordRequest, rhs: Lnrpc.ChangePasswordRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasCurrentPassword == rhs.hasCurrentPassword) && (!lhs.hasCurrentPassword || lhs.currentPassword == rhs.currentPassword)
            fieldCheck = fieldCheck && (lhs.hasNewPassword == rhs.hasNewPassword) && (!lhs.hasNewPassword || lhs.newPassword == rhs.newPassword)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///*
        ///current_password should be the current valid passphrase used to unlock the
        ///daemon.
        public fileprivate(set) var currentPassword:Data! = nil
        public fileprivate(set) var hasCurrentPassword:Bool = false

        ///*
        ///new_password should be the new passphrase that will be needed to unlock the
        ///daemon.
        public fileprivate(set) var newPassword:Data! = nil
        public fileprivate(set) var hasNewPassword:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasCurrentPassword {
                try codedOutputStream.writeData(fieldNumber: 1, value:currentPassword)
            }
            if hasNewPassword {
                try codedOutputStream.writeData(fieldNumber: 2, value:newPassword)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasCurrentPassword {
                serialize_size += currentPassword.computeDataSize(fieldNumber: 1)
            }
            if hasNewPassword {
                serialize_size += newPassword.computeDataSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ChangePasswordRequest.Builder {
            return Lnrpc.ChangePasswordRequest.classBuilder() as! Lnrpc.ChangePasswordRequest.Builder
        }
        public func getBuilder() -> Lnrpc.ChangePasswordRequest.Builder {
            return classBuilder() as! Lnrpc.ChangePasswordRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChangePasswordRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChangePasswordRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ChangePasswordRequest.Builder {
            return try Lnrpc.ChangePasswordRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ChangePasswordRequest) throws -> Lnrpc.ChangePasswordRequest.Builder {
            return try Lnrpc.ChangePasswordRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasCurrentPassword {
                jsonMap["currentPassword"] = currentPassword.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasNewPassword {
                jsonMap["newPassword"] = newPassword.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChangePasswordRequest {
            return try Lnrpc.ChangePasswordRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChangePasswordRequest {
            return try Lnrpc.ChangePasswordRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasCurrentPassword {
                output += "\(indent) currentPassword: \(currentPassword) \n"
            }
            if hasNewPassword {
                output += "\(indent) newPassword: \(newPassword) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasCurrentPassword {
                    hashCode = (hashCode &* 31) &+ currentPassword.hashValue
                }
                if hasNewPassword {
                    hashCode = (hashCode &* 31) &+ newPassword.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ChangePasswordRequest"
        }
        override public func className() -> String {
            return "Lnrpc.ChangePasswordRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ChangePasswordRequest = Lnrpc.ChangePasswordRequest()
            public func getMessage() -> Lnrpc.ChangePasswordRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///*
            ///current_password should be the current valid passphrase used to unlock the
            ///daemon.
            public var currentPassword:Data {
                get {
                    return builderResult.currentPassword
                }
                set (value) {
                    builderResult.hasCurrentPassword = true
                    builderResult.currentPassword = value
                }
            }
            public var hasCurrentPassword:Bool {
                get {
                    return builderResult.hasCurrentPassword
                }
            }
            @discardableResult
            public func setCurrentPassword(_ value:Data) -> Lnrpc.ChangePasswordRequest.Builder {
                self.currentPassword = value
                return self
            }
            @discardableResult
            public func clearCurrentPassword() -> Lnrpc.ChangePasswordRequest.Builder{
                builderResult.hasCurrentPassword = false
                builderResult.currentPassword = nil
                return self
            }
            ///*
            ///new_password should be the new passphrase that will be needed to unlock the
            ///daemon.
            public var newPassword:Data {
                get {
                    return builderResult.newPassword
                }
                set (value) {
                    builderResult.hasNewPassword = true
                    builderResult.newPassword = value
                }
            }
            public var hasNewPassword:Bool {
                get {
                    return builderResult.hasNewPassword
                }
            }
            @discardableResult
            public func setNewPassword(_ value:Data) -> Lnrpc.ChangePasswordRequest.Builder {
                self.newPassword = value
                return self
            }
            @discardableResult
            public func clearNewPassword() -> Lnrpc.ChangePasswordRequest.Builder{
                builderResult.hasNewPassword = false
                builderResult.newPassword = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ChangePasswordRequest.Builder {
                builderResult = Lnrpc.ChangePasswordRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.ChangePasswordRequest.Builder {
                return try Lnrpc.ChangePasswordRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ChangePasswordRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ChangePasswordRequest {
                let returnMe:Lnrpc.ChangePasswordRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ChangePasswordRequest) throws -> Lnrpc.ChangePasswordRequest.Builder {
                if other == Lnrpc.ChangePasswordRequest() {
                    return self
                }
                if other.hasCurrentPassword {
                    currentPassword = other.currentPassword
                }
                if other.hasNewPassword {
                    newPassword = other.newPassword
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChangePasswordRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChangePasswordRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        currentPassword = try codedInputStream.readData()

                    case 18:
                        newPassword = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChangePasswordRequest.Builder {
                let resultDecodedBuilder = Lnrpc.ChangePasswordRequest.Builder()
                if let jsonValueCurrentPassword = jsonMap["currentPassword"] as? String {
                    resultDecodedBuilder.currentPassword = Data(base64Encoded:jsonValueCurrentPassword, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueNewPassword = jsonMap["newPassword"] as? String {
                    resultDecodedBuilder.newPassword = Data(base64Encoded:jsonValueNewPassword, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChangePasswordRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ChangePasswordRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ChangePasswordResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ChangePasswordResponse.Builder

        public static func == (lhs: Lnrpc.ChangePasswordResponse, rhs: Lnrpc.ChangePasswordResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ChangePasswordResponse.Builder {
            return Lnrpc.ChangePasswordResponse.classBuilder() as! Lnrpc.ChangePasswordResponse.Builder
        }
        public func getBuilder() -> Lnrpc.ChangePasswordResponse.Builder {
            return classBuilder() as! Lnrpc.ChangePasswordResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChangePasswordResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChangePasswordResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ChangePasswordResponse.Builder {
            return try Lnrpc.ChangePasswordResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ChangePasswordResponse) throws -> Lnrpc.ChangePasswordResponse.Builder {
            return try Lnrpc.ChangePasswordResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChangePasswordResponse {
            return try Lnrpc.ChangePasswordResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChangePasswordResponse {
            return try Lnrpc.ChangePasswordResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ChangePasswordResponse"
        }
        override public func className() -> String {
            return "Lnrpc.ChangePasswordResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ChangePasswordResponse = Lnrpc.ChangePasswordResponse()
            public func getMessage() -> Lnrpc.ChangePasswordResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ChangePasswordResponse.Builder {
                builderResult = Lnrpc.ChangePasswordResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.ChangePasswordResponse.Builder {
                return try Lnrpc.ChangePasswordResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ChangePasswordResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ChangePasswordResponse {
                let returnMe:Lnrpc.ChangePasswordResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ChangePasswordResponse) throws -> Lnrpc.ChangePasswordResponse.Builder {
                if other == Lnrpc.ChangePasswordResponse() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChangePasswordResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChangePasswordResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChangePasswordResponse.Builder {
                let resultDecodedBuilder = Lnrpc.ChangePasswordResponse.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChangePasswordResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ChangePasswordResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class Transaction : GeneratedMessage {
        public typealias BuilderType = Lnrpc.Transaction.Builder

        public static func == (lhs: Lnrpc.Transaction, rhs: Lnrpc.Transaction) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTxHash == rhs.hasTxHash) && (!lhs.hasTxHash || lhs.txHash == rhs.txHash)
            fieldCheck = fieldCheck && (lhs.hasAmount == rhs.hasAmount) && (!lhs.hasAmount || lhs.amount == rhs.amount)
            fieldCheck = fieldCheck && (lhs.hasNumConfirmations == rhs.hasNumConfirmations) && (!lhs.hasNumConfirmations || lhs.numConfirmations == rhs.numConfirmations)
            fieldCheck = fieldCheck && (lhs.hasBlockHash == rhs.hasBlockHash) && (!lhs.hasBlockHash || lhs.blockHash == rhs.blockHash)
            fieldCheck = fieldCheck && (lhs.hasBlockHeight == rhs.hasBlockHeight) && (!lhs.hasBlockHeight || lhs.blockHeight == rhs.blockHeight)
            fieldCheck = fieldCheck && (lhs.hasTimeStamp == rhs.hasTimeStamp) && (!lhs.hasTimeStamp || lhs.timeStamp == rhs.timeStamp)
            fieldCheck = fieldCheck && (lhs.hasTotalFees == rhs.hasTotalFees) && (!lhs.hasTotalFees || lhs.totalFees == rhs.totalFees)
            fieldCheck = fieldCheck && (lhs.destAddresses == rhs.destAddresses)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// The transaction hash
        public fileprivate(set) var txHash:String! = nil
        public fileprivate(set) var hasTxHash:Bool = false

        //// The transaction ammount, denominated in satoshis
        public fileprivate(set) var amount:Int64! = nil
        public fileprivate(set) var hasAmount:Bool = false

        //// The number of confirmations
        public fileprivate(set) var numConfirmations:Int32! = nil
        public fileprivate(set) var hasNumConfirmations:Bool = false

        //// The hash of the block this transaction was included in
        public fileprivate(set) var blockHash:String! = nil
        public fileprivate(set) var hasBlockHash:Bool = false

        //// The height of the block this transaction was included in
        public fileprivate(set) var blockHeight:Int32! = nil
        public fileprivate(set) var hasBlockHeight:Bool = false

        //// Timestamp of this transaction 
        public fileprivate(set) var timeStamp:Int64! = nil
        public fileprivate(set) var hasTimeStamp:Bool = false

        //// Fees paid for this transaction
        public fileprivate(set) var totalFees:Int64! = nil
        public fileprivate(set) var hasTotalFees:Bool = false

        //// Addresses that received funds for this transaction
        public fileprivate(set) var destAddresses:Array<String> = Array<String>()
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTxHash {
                try codedOutputStream.writeString(fieldNumber: 1, value:txHash)
            }
            if hasAmount {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:amount)
            }
            if hasNumConfirmations {
                try codedOutputStream.writeInt32(fieldNumber: 3, value:numConfirmations)
            }
            if hasBlockHash {
                try codedOutputStream.writeString(fieldNumber: 4, value:blockHash)
            }
            if hasBlockHeight {
                try codedOutputStream.writeInt32(fieldNumber: 5, value:blockHeight)
            }
            if hasTimeStamp {
                try codedOutputStream.writeInt64(fieldNumber: 6, value:timeStamp)
            }
            if hasTotalFees {
                try codedOutputStream.writeInt64(fieldNumber: 7, value:totalFees)
            }
            if !destAddresses.isEmpty {
                for oneValuedestAddresses in destAddresses {
                    try codedOutputStream.writeString(fieldNumber: 8, value:oneValuedestAddresses)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTxHash {
                serialize_size += txHash.computeStringSize(fieldNumber: 1)
            }
            if hasAmount {
                serialize_size += amount.computeInt64Size(fieldNumber: 2)
            }
            if hasNumConfirmations {
                serialize_size += numConfirmations.computeInt32Size(fieldNumber: 3)
            }
            if hasBlockHash {
                serialize_size += blockHash.computeStringSize(fieldNumber: 4)
            }
            if hasBlockHeight {
                serialize_size += blockHeight.computeInt32Size(fieldNumber: 5)
            }
            if hasTimeStamp {
                serialize_size += timeStamp.computeInt64Size(fieldNumber: 6)
            }
            if hasTotalFees {
                serialize_size += totalFees.computeInt64Size(fieldNumber: 7)
            }
            var dataSizeDestAddresses:Int32 = 0
            for oneValuedestAddresses in destAddresses {
                dataSizeDestAddresses += oneValuedestAddresses.computeStringSizeNoTag()
            }
            serialize_size += dataSizeDestAddresses
            serialize_size += 1 * Int32(destAddresses.count)
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.Transaction.Builder {
            return Lnrpc.Transaction.classBuilder() as! Lnrpc.Transaction.Builder
        }
        public func getBuilder() -> Lnrpc.Transaction.Builder {
            return classBuilder() as! Lnrpc.Transaction.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.Transaction.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.Transaction.Builder()
        }
        public func toBuilder() throws -> Lnrpc.Transaction.Builder {
            return try Lnrpc.Transaction.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.Transaction) throws -> Lnrpc.Transaction.Builder {
            return try Lnrpc.Transaction.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTxHash {
                jsonMap["tx_hash"] = txHash
            }
            if hasAmount {
                jsonMap["amount"] = "\(amount!)"
            }
            if hasNumConfirmations {
                jsonMap["num_confirmations"] = Int(numConfirmations)
            }
            if hasBlockHash {
                jsonMap["block_hash"] = blockHash
            }
            if hasBlockHeight {
                jsonMap["block_height"] = Int(blockHeight)
            }
            if hasTimeStamp {
                jsonMap["time_stamp"] = "\(timeStamp!)"
            }
            if hasTotalFees {
                jsonMap["total_fees"] = "\(totalFees!)"
            }
            if !destAddresses.isEmpty {
                var jsonArrayDestAddresses:Array<String> = []
                for oneValueDestAddresses in destAddresses {
                    jsonArrayDestAddresses.append(oneValueDestAddresses)
                }
                jsonMap["dest_addresses"] = jsonArrayDestAddresses
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.Transaction {
            return try Lnrpc.Transaction.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.Transaction {
            return try Lnrpc.Transaction.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTxHash {
                output += "\(indent) txHash: \(txHash) \n"
            }
            if hasAmount {
                output += "\(indent) amount: \(amount) \n"
            }
            if hasNumConfirmations {
                output += "\(indent) numConfirmations: \(numConfirmations) \n"
            }
            if hasBlockHash {
                output += "\(indent) blockHash: \(blockHash) \n"
            }
            if hasBlockHeight {
                output += "\(indent) blockHeight: \(blockHeight) \n"
            }
            if hasTimeStamp {
                output += "\(indent) timeStamp: \(timeStamp) \n"
            }
            if hasTotalFees {
                output += "\(indent) totalFees: \(totalFees) \n"
            }
            var destAddressesElementIndex:Int = 0
            for oneValueDestAddresses in destAddresses  {
                output += "\(indent) destAddresses[\(destAddressesElementIndex)]: \(oneValueDestAddresses)\n"
                destAddressesElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTxHash {
                    hashCode = (hashCode &* 31) &+ txHash.hashValue
                }
                if hasAmount {
                    hashCode = (hashCode &* 31) &+ amount.hashValue
                }
                if hasNumConfirmations {
                    hashCode = (hashCode &* 31) &+ numConfirmations.hashValue
                }
                if hasBlockHash {
                    hashCode = (hashCode &* 31) &+ blockHash.hashValue
                }
                if hasBlockHeight {
                    hashCode = (hashCode &* 31) &+ blockHeight.hashValue
                }
                if hasTimeStamp {
                    hashCode = (hashCode &* 31) &+ timeStamp.hashValue
                }
                if hasTotalFees {
                    hashCode = (hashCode &* 31) &+ totalFees.hashValue
                }
                for oneValueDestAddresses in destAddresses {
                    hashCode = (hashCode &* 31) &+ oneValueDestAddresses.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.Transaction"
        }
        override public func className() -> String {
            return "Lnrpc.Transaction"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.Transaction = Lnrpc.Transaction()
            public func getMessage() -> Lnrpc.Transaction {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The transaction hash
            public var txHash:String {
                get {
                    return builderResult.txHash
                }
                set (value) {
                    builderResult.hasTxHash = true
                    builderResult.txHash = value
                }
            }
            public var hasTxHash:Bool {
                get {
                    return builderResult.hasTxHash
                }
            }
            @discardableResult
            public func setTxHash(_ value:String) -> Lnrpc.Transaction.Builder {
                self.txHash = value
                return self
            }
            @discardableResult
            public func clearTxHash() -> Lnrpc.Transaction.Builder{
                builderResult.hasTxHash = false
                builderResult.txHash = nil
                return self
            }
            //// The transaction ammount, denominated in satoshis
            public var amount:Int64 {
                get {
                    return builderResult.amount
                }
                set (value) {
                    builderResult.hasAmount = true
                    builderResult.amount = value
                }
            }
            public var hasAmount:Bool {
                get {
                    return builderResult.hasAmount
                }
            }
            @discardableResult
            public func setAmount(_ value:Int64) -> Lnrpc.Transaction.Builder {
                self.amount = value
                return self
            }
            @discardableResult
            public func clearAmount() -> Lnrpc.Transaction.Builder{
                builderResult.hasAmount = false
                builderResult.amount = nil
                return self
            }
            //// The number of confirmations
            public var numConfirmations:Int32 {
                get {
                    return builderResult.numConfirmations
                }
                set (value) {
                    builderResult.hasNumConfirmations = true
                    builderResult.numConfirmations = value
                }
            }
            public var hasNumConfirmations:Bool {
                get {
                    return builderResult.hasNumConfirmations
                }
            }
            @discardableResult
            public func setNumConfirmations(_ value:Int32) -> Lnrpc.Transaction.Builder {
                self.numConfirmations = value
                return self
            }
            @discardableResult
            public func clearNumConfirmations() -> Lnrpc.Transaction.Builder{
                builderResult.hasNumConfirmations = false
                builderResult.numConfirmations = nil
                return self
            }
            //// The hash of the block this transaction was included in
            public var blockHash:String {
                get {
                    return builderResult.blockHash
                }
                set (value) {
                    builderResult.hasBlockHash = true
                    builderResult.blockHash = value
                }
            }
            public var hasBlockHash:Bool {
                get {
                    return builderResult.hasBlockHash
                }
            }
            @discardableResult
            public func setBlockHash(_ value:String) -> Lnrpc.Transaction.Builder {
                self.blockHash = value
                return self
            }
            @discardableResult
            public func clearBlockHash() -> Lnrpc.Transaction.Builder{
                builderResult.hasBlockHash = false
                builderResult.blockHash = nil
                return self
            }
            //// The height of the block this transaction was included in
            public var blockHeight:Int32 {
                get {
                    return builderResult.blockHeight
                }
                set (value) {
                    builderResult.hasBlockHeight = true
                    builderResult.blockHeight = value
                }
            }
            public var hasBlockHeight:Bool {
                get {
                    return builderResult.hasBlockHeight
                }
            }
            @discardableResult
            public func setBlockHeight(_ value:Int32) -> Lnrpc.Transaction.Builder {
                self.blockHeight = value
                return self
            }
            @discardableResult
            public func clearBlockHeight() -> Lnrpc.Transaction.Builder{
                builderResult.hasBlockHeight = false
                builderResult.blockHeight = nil
                return self
            }
            //// Timestamp of this transaction 
            public var timeStamp:Int64 {
                get {
                    return builderResult.timeStamp
                }
                set (value) {
                    builderResult.hasTimeStamp = true
                    builderResult.timeStamp = value
                }
            }
            public var hasTimeStamp:Bool {
                get {
                    return builderResult.hasTimeStamp
                }
            }
            @discardableResult
            public func setTimeStamp(_ value:Int64) -> Lnrpc.Transaction.Builder {
                self.timeStamp = value
                return self
            }
            @discardableResult
            public func clearTimeStamp() -> Lnrpc.Transaction.Builder{
                builderResult.hasTimeStamp = false
                builderResult.timeStamp = nil
                return self
            }
            //// Fees paid for this transaction
            public var totalFees:Int64 {
                get {
                    return builderResult.totalFees
                }
                set (value) {
                    builderResult.hasTotalFees = true
                    builderResult.totalFees = value
                }
            }
            public var hasTotalFees:Bool {
                get {
                    return builderResult.hasTotalFees
                }
            }
            @discardableResult
            public func setTotalFees(_ value:Int64) -> Lnrpc.Transaction.Builder {
                self.totalFees = value
                return self
            }
            @discardableResult
            public func clearTotalFees() -> Lnrpc.Transaction.Builder{
                builderResult.hasTotalFees = false
                builderResult.totalFees = nil
                return self
            }
            //// Addresses that received funds for this transaction
            public var destAddresses:Array<String> {
                get {
                    return builderResult.destAddresses
                }
                set (array) {
                    builderResult.destAddresses = array
                }
            }
            @discardableResult
            public func setDestAddresses(_ value:Array<String>) -> Lnrpc.Transaction.Builder {
                self.destAddresses = value
                return self
            }
            @discardableResult
            public func clearDestAddresses() -> Lnrpc.Transaction.Builder {
                builderResult.destAddresses.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.Transaction.Builder {
                builderResult = Lnrpc.Transaction()
                return self
            }
            override public func clone() throws -> Lnrpc.Transaction.Builder {
                return try Lnrpc.Transaction.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.Transaction {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.Transaction {
                let returnMe:Lnrpc.Transaction = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.Transaction) throws -> Lnrpc.Transaction.Builder {
                if other == Lnrpc.Transaction() {
                    return self
                }
                if other.hasTxHash {
                    txHash = other.txHash
                }
                if other.hasAmount {
                    amount = other.amount
                }
                if other.hasNumConfirmations {
                    numConfirmations = other.numConfirmations
                }
                if other.hasBlockHash {
                    blockHash = other.blockHash
                }
                if other.hasBlockHeight {
                    blockHeight = other.blockHeight
                }
                if other.hasTimeStamp {
                    timeStamp = other.timeStamp
                }
                if other.hasTotalFees {
                    totalFees = other.totalFees
                }
                if !other.destAddresses.isEmpty {
                    builderResult.destAddresses += other.destAddresses
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.Transaction.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Transaction.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        txHash = try codedInputStream.readString()

                    case 16:
                        amount = try codedInputStream.readInt64()

                    case 24:
                        numConfirmations = try codedInputStream.readInt32()

                    case 34:
                        blockHash = try codedInputStream.readString()

                    case 40:
                        blockHeight = try codedInputStream.readInt32()

                    case 48:
                        timeStamp = try codedInputStream.readInt64()

                    case 56:
                        totalFees = try codedInputStream.readInt64()

                    case 66:
                        destAddresses += [try codedInputStream.readString()]

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.Transaction.Builder {
                let resultDecodedBuilder = Lnrpc.Transaction.Builder()
                if let jsonValueTxHash = jsonMap["tx_hash"] as? String {
                    resultDecodedBuilder.txHash = jsonValueTxHash
                }
                if let jsonValueAmount = jsonMap["amount"] as? String {
                    resultDecodedBuilder.amount = Int64(jsonValueAmount)!
                } else if let jsonValueAmount = jsonMap["amount"] as? Int {
                    resultDecodedBuilder.amount = Int64(jsonValueAmount)
                }
                if let jsonValueNumConfirmations = jsonMap["num_confirmations"] as? Int {
                    resultDecodedBuilder.numConfirmations = Int32(jsonValueNumConfirmations)
                } else if let jsonValueNumConfirmations = jsonMap["num_confirmations"] as? String {
                    resultDecodedBuilder.numConfirmations = Int32(jsonValueNumConfirmations)!
                }
                if let jsonValueBlockHash = jsonMap["block_hash"] as? String {
                    resultDecodedBuilder.blockHash = jsonValueBlockHash
                }
                if let jsonValueBlockHeight = jsonMap["block_height"] as? Int {
                    resultDecodedBuilder.blockHeight = Int32(jsonValueBlockHeight)
                } else if let jsonValueBlockHeight = jsonMap["block_height"] as? String {
                    resultDecodedBuilder.blockHeight = Int32(jsonValueBlockHeight)!
                }
                if let jsonValueTimeStamp = jsonMap["time_stamp"] as? String {
                    resultDecodedBuilder.timeStamp = Int64(jsonValueTimeStamp)!
                } else if let jsonValueTimeStamp = jsonMap["time_stamp"] as? Int {
                    resultDecodedBuilder.timeStamp = Int64(jsonValueTimeStamp)
                }
                if let jsonValueTotalFees = jsonMap["total_fees"] as? String {
                    resultDecodedBuilder.totalFees = Int64(jsonValueTotalFees)!
                } else if let jsonValueTotalFees = jsonMap["total_fees"] as? Int {
                    resultDecodedBuilder.totalFees = Int64(jsonValueTotalFees)
                }
                if let jsonValueDestAddresses = jsonMap["dest_addresses"] as? Array<String> {
                    var jsonArrayDestAddresses:Array<String> = []
                    for oneValueDestAddresses in jsonValueDestAddresses {
                        jsonArrayDestAddresses.append(oneValueDestAddresses)
                    }
                    resultDecodedBuilder.destAddresses = jsonArrayDestAddresses
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.Transaction.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.Transaction.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GetTransactionsRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.GetTransactionsRequest.Builder

        public static func == (lhs: Lnrpc.GetTransactionsRequest, rhs: Lnrpc.GetTransactionsRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.GetTransactionsRequest.Builder {
            return Lnrpc.GetTransactionsRequest.classBuilder() as! Lnrpc.GetTransactionsRequest.Builder
        }
        public func getBuilder() -> Lnrpc.GetTransactionsRequest.Builder {
            return classBuilder() as! Lnrpc.GetTransactionsRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.GetTransactionsRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.GetTransactionsRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.GetTransactionsRequest.Builder {
            return try Lnrpc.GetTransactionsRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.GetTransactionsRequest) throws -> Lnrpc.GetTransactionsRequest.Builder {
            return try Lnrpc.GetTransactionsRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.GetTransactionsRequest {
            return try Lnrpc.GetTransactionsRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.GetTransactionsRequest {
            return try Lnrpc.GetTransactionsRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.GetTransactionsRequest"
        }
        override public func className() -> String {
            return "Lnrpc.GetTransactionsRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.GetTransactionsRequest = Lnrpc.GetTransactionsRequest()
            public func getMessage() -> Lnrpc.GetTransactionsRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.GetTransactionsRequest.Builder {
                builderResult = Lnrpc.GetTransactionsRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.GetTransactionsRequest.Builder {
                return try Lnrpc.GetTransactionsRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.GetTransactionsRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.GetTransactionsRequest {
                let returnMe:Lnrpc.GetTransactionsRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.GetTransactionsRequest) throws -> Lnrpc.GetTransactionsRequest.Builder {
                if other == Lnrpc.GetTransactionsRequest() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.GetTransactionsRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GetTransactionsRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.GetTransactionsRequest.Builder {
                let resultDecodedBuilder = Lnrpc.GetTransactionsRequest.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.GetTransactionsRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.GetTransactionsRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TransactionDetails : GeneratedMessage {
        public typealias BuilderType = Lnrpc.TransactionDetails.Builder

        public static func == (lhs: Lnrpc.TransactionDetails, rhs: Lnrpc.TransactionDetails) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.transactions == rhs.transactions)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var transactions:Array<Lnrpc.Transaction>  = Array<Lnrpc.Transaction>()
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementTransactions in transactions {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementTransactions)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementTransactions in transactions {
                serialize_size += oneElementTransactions.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.TransactionDetails.Builder {
            return Lnrpc.TransactionDetails.classBuilder() as! Lnrpc.TransactionDetails.Builder
        }
        public func getBuilder() -> Lnrpc.TransactionDetails.Builder {
            return classBuilder() as! Lnrpc.TransactionDetails.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.TransactionDetails.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.TransactionDetails.Builder()
        }
        public func toBuilder() throws -> Lnrpc.TransactionDetails.Builder {
            return try Lnrpc.TransactionDetails.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.TransactionDetails) throws -> Lnrpc.TransactionDetails.Builder {
            return try Lnrpc.TransactionDetails.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !transactions.isEmpty {
                var jsonArrayTransactions:Array<Dictionary<String,Any>> = []
                for oneValueTransactions in transactions {
                    let ecodedMessageTransactions = try oneValueTransactions.encode()
                    jsonArrayTransactions.append(ecodedMessageTransactions)
                }
                jsonMap["transactions"] = jsonArrayTransactions
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.TransactionDetails {
            return try Lnrpc.TransactionDetails.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.TransactionDetails {
            return try Lnrpc.TransactionDetails.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var transactionsElementIndex:Int = 0
            for oneElementTransactions in transactions {
                output += "\(indent) transactions[\(transactionsElementIndex)] {\n"
                output += try oneElementTransactions.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                transactionsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementTransactions in transactions {
                    hashCode = (hashCode &* 31) &+ oneElementTransactions.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.TransactionDetails"
        }
        override public func className() -> String {
            return "Lnrpc.TransactionDetails"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.TransactionDetails = Lnrpc.TransactionDetails()
            public func getMessage() -> Lnrpc.TransactionDetails {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The list of transactions relevant to the wallet.
            public var transactions:Array<Lnrpc.Transaction> {
                get {
                    return builderResult.transactions
                }
                set (value) {
                    builderResult.transactions = value
                }
            }
            @discardableResult
            public func setTransactions(_ value:Array<Lnrpc.Transaction>) -> Lnrpc.TransactionDetails.Builder {
                self.transactions = value
                return self
            }
            @discardableResult
            public func clearTransactions() -> Lnrpc.TransactionDetails.Builder {
                builderResult.transactions.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.TransactionDetails.Builder {
                builderResult = Lnrpc.TransactionDetails()
                return self
            }
            override public func clone() throws -> Lnrpc.TransactionDetails.Builder {
                return try Lnrpc.TransactionDetails.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.TransactionDetails {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.TransactionDetails {
                let returnMe:Lnrpc.TransactionDetails = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.TransactionDetails) throws -> Lnrpc.TransactionDetails.Builder {
                if other == Lnrpc.TransactionDetails() {
                    return self
                }
                if !other.transactions.isEmpty  {
                     builderResult.transactions += other.transactions
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.TransactionDetails.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.TransactionDetails.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Lnrpc.Transaction.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        transactions.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.TransactionDetails.Builder {
                let resultDecodedBuilder = Lnrpc.TransactionDetails.Builder()
                if let jsonValueTransactions = jsonMap["transactions"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayTransactions:Array<Lnrpc.Transaction> = []
                    for oneValueTransactions in jsonValueTransactions {
                        let messageFromStringTransactions = try Lnrpc.Transaction.Builder.decodeToBuilder(jsonMap:oneValueTransactions).build()

                        jsonArrayTransactions.append(messageFromStringTransactions)
                    }
                    resultDecodedBuilder.transactions = jsonArrayTransactions
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.TransactionDetails.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.TransactionDetails.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class FeeLimit : GeneratedMessage {
        public typealias BuilderType = Lnrpc.FeeLimit.Builder

        public static func == (lhs: Lnrpc.FeeLimit, rhs: Lnrpc.FeeLimit) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFixed == rhs.hasFixed) && (!lhs.hasFixed || lhs.fixed == rhs.fixed)
            fieldCheck = fieldCheck && (lhs.hasPercent == rhs.hasPercent) && (!lhs.hasPercent || lhs.percent == rhs.percent)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        public enum Limit {
            case oneOfLimitNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .oneOfLimitNotSet: return false
                default: return true
                }
            }
            case fixed(Int64)

            public static func getFixed(_ value:Limit) -> Int64? {
                switch value {
                case .fixed(let otherValue): return otherValue
                default: return nil
                }
            }
            public func getFixed() -> Int64? {
                switch self {
                case .fixed(let otherValue): return otherValue
                default: return nil
                }
            }
            case percent(Int64)

            public static func getPercent(_ value:Limit) -> Int64? {
                switch value {
                case .percent(let otherValue): return otherValue
                default: return nil
                }
            }
            public func getPercent() -> Int64? {
                switch self {
                case .percent(let otherValue): return otherValue
                default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageLimit:FeeLimit.Limit =  FeeLimit.Limit.oneOfLimitNotSet
        public func getOneOfLimit() ->  FeeLimit.Limit {
            let copyObjectLimit = storageLimit
            return copyObjectLimit
        }
        //// The fee limit expressed as a fixed amount of satoshis.
        public fileprivate(set) var fixed:Int64!{
            get {
                return FeeLimit.Limit.getFixed(storageLimit)
            }
            set (newvalue) {
                storageLimit = FeeLimit.Limit.fixed(newvalue)
            }
        }
        public fileprivate(set) var hasFixed:Bool {
            get {
                return FeeLimit.Limit.getFixed(storageLimit) != nil
            }
            set(newValue) {
            }
        }
        //// The fee limit expressed as a percentage of the payment amount.
        public fileprivate(set) var percent:Int64!{
            get {
                return FeeLimit.Limit.getPercent(storageLimit)
            }
            set (newvalue) {
                storageLimit = FeeLimit.Limit.percent(newvalue)
            }
        }
        public fileprivate(set) var hasPercent:Bool {
            get {
                return FeeLimit.Limit.getPercent(storageLimit) != nil
            }
            set(newValue) {
            }
        }
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFixed {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:fixed)
            }
            if hasPercent {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:percent)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFixed {
                serialize_size += fixed.computeInt64Size(fieldNumber: 1)
            }
            if hasPercent {
                serialize_size += percent.computeInt64Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.FeeLimit.Builder {
            return Lnrpc.FeeLimit.classBuilder() as! Lnrpc.FeeLimit.Builder
        }
        public func getBuilder() -> Lnrpc.FeeLimit.Builder {
            return classBuilder() as! Lnrpc.FeeLimit.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.FeeLimit.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.FeeLimit.Builder()
        }
        public func toBuilder() throws -> Lnrpc.FeeLimit.Builder {
            return try Lnrpc.FeeLimit.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.FeeLimit) throws -> Lnrpc.FeeLimit.Builder {
            return try Lnrpc.FeeLimit.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFixed {
                jsonMap["fixed"] = "\(fixed!)"
            }
            if hasPercent {
                jsonMap["percent"] = "\(percent!)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.FeeLimit {
            return try Lnrpc.FeeLimit.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.FeeLimit {
            return try Lnrpc.FeeLimit.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFixed {
                output += "\(indent) fixed: \(fixed) \n"
            }
            if hasPercent {
                output += "\(indent) percent: \(percent) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFixed {
                    hashCode = (hashCode &* 31) &+ fixed.hashValue
                }
                if hasPercent {
                    hashCode = (hashCode &* 31) &+ percent.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.FeeLimit"
        }
        override public func className() -> String {
            return "Lnrpc.FeeLimit"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.FeeLimit = Lnrpc.FeeLimit()
            public func getMessage() -> Lnrpc.FeeLimit {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public func setLimit(_ oneOf:FeeLimit.Limit) ->  Lnrpc.FeeLimit.Builder {
                builderResult.storageLimit = oneOf
                return self
            }
            //// The fee limit expressed as a fixed amount of satoshis.
            public var fixed:Int64 {
                get {
                    return builderResult.fixed
                }
                set (value) {
                    builderResult.hasFixed = true
                    builderResult.fixed = value
                }
            }
            public var hasFixed:Bool {
                get {
                    return builderResult.hasFixed
                }
            }
            @discardableResult
            public func setFixed(_ value:Int64) -> Lnrpc.FeeLimit.Builder {
                self.fixed = value
                return self
            }
            @discardableResult
            public func clearFixed() -> Lnrpc.FeeLimit.Builder{
                builderResult.hasFixed = false
                builderResult.fixed = nil
                return self
            }
            //// The fee limit expressed as a percentage of the payment amount.
            public var percent:Int64 {
                get {
                    return builderResult.percent
                }
                set (value) {
                    builderResult.hasPercent = true
                    builderResult.percent = value
                }
            }
            public var hasPercent:Bool {
                get {
                    return builderResult.hasPercent
                }
            }
            @discardableResult
            public func setPercent(_ value:Int64) -> Lnrpc.FeeLimit.Builder {
                self.percent = value
                return self
            }
            @discardableResult
            public func clearPercent() -> Lnrpc.FeeLimit.Builder{
                builderResult.hasPercent = false
                builderResult.percent = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.FeeLimit.Builder {
                builderResult = Lnrpc.FeeLimit()
                return self
            }
            override public func clone() throws -> Lnrpc.FeeLimit.Builder {
                return try Lnrpc.FeeLimit.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.FeeLimit {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.FeeLimit {
                let returnMe:Lnrpc.FeeLimit = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.FeeLimit) throws -> Lnrpc.FeeLimit.Builder {
                if other == Lnrpc.FeeLimit() {
                    return self
                }
                if other.hasFixed {
                    fixed = other.fixed
                }
                if other.hasPercent {
                    percent = other.percent
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.FeeLimit.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.FeeLimit.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        fixed = try codedInputStream.readInt64()

                    case 16:
                        percent = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.FeeLimit.Builder {
                let resultDecodedBuilder = Lnrpc.FeeLimit.Builder()
                if let jsonValueFixed = jsonMap["fixed"] as? String {
                    resultDecodedBuilder.fixed = Int64(jsonValueFixed)!
                } else if let jsonValueFixed = jsonMap["fixed"] as? Int {
                    resultDecodedBuilder.fixed = Int64(jsonValueFixed)
                }
                if let jsonValuePercent = jsonMap["percent"] as? String {
                    resultDecodedBuilder.percent = Int64(jsonValuePercent)!
                } else if let jsonValuePercent = jsonMap["percent"] as? Int {
                    resultDecodedBuilder.percent = Int64(jsonValuePercent)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.FeeLimit.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.FeeLimit.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SendRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.SendRequest.Builder

        public static func == (lhs: Lnrpc.SendRequest, rhs: Lnrpc.SendRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasDest == rhs.hasDest) && (!lhs.hasDest || lhs.dest == rhs.dest)
            fieldCheck = fieldCheck && (lhs.hasDestString == rhs.hasDestString) && (!lhs.hasDestString || lhs.destString == rhs.destString)
            fieldCheck = fieldCheck && (lhs.hasAmt == rhs.hasAmt) && (!lhs.hasAmt || lhs.amt == rhs.amt)
            fieldCheck = fieldCheck && (lhs.hasPaymentHash == rhs.hasPaymentHash) && (!lhs.hasPaymentHash || lhs.paymentHash == rhs.paymentHash)
            fieldCheck = fieldCheck && (lhs.hasPaymentHashString == rhs.hasPaymentHashString) && (!lhs.hasPaymentHashString || lhs.paymentHashString == rhs.paymentHashString)
            fieldCheck = fieldCheck && (lhs.hasPaymentRequest == rhs.hasPaymentRequest) && (!lhs.hasPaymentRequest || lhs.paymentRequest == rhs.paymentRequest)
            fieldCheck = fieldCheck && (lhs.hasFinalCltvDelta == rhs.hasFinalCltvDelta) && (!lhs.hasFinalCltvDelta || lhs.finalCltvDelta == rhs.finalCltvDelta)
            fieldCheck = fieldCheck && (lhs.hasFeeLimit == rhs.hasFeeLimit) && (!lhs.hasFeeLimit || lhs.feeLimit == rhs.feeLimit)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// The identity pubkey of the payment recipient
        public fileprivate(set) var dest:Data! = nil
        public fileprivate(set) var hasDest:Bool = false

        //// The hex-encoded identity pubkey of the payment recipient
        public fileprivate(set) var destString:String! = nil
        public fileprivate(set) var hasDestString:Bool = false

        //// Number of satoshis to send.
        public fileprivate(set) var amt:Int64! = nil
        public fileprivate(set) var hasAmt:Bool = false

        //// The hash to use within the payment's HTLC
        public fileprivate(set) var paymentHash:Data! = nil
        public fileprivate(set) var hasPaymentHash:Bool = false

        //// The hex-encoded hash to use within the payment's HTLC
        public fileprivate(set) var paymentHashString:String! = nil
        public fileprivate(set) var hasPaymentHashString:Bool = false

        ///*
        ///A bare-bones invoice for a payment within the Lightning Network.  With the
        ///details of the invoice, the sender has all the data necessary to send a
        ///payment to the recipient.
        public fileprivate(set) var paymentRequest:String! = nil
        public fileprivate(set) var hasPaymentRequest:Bool = false

        ///*
        ///The CLTV delta from the current height that should be used to set the
        ///timelock for the final hop.
        public fileprivate(set) var finalCltvDelta:Int32! = nil
        public fileprivate(set) var hasFinalCltvDelta:Bool = false

        public fileprivate(set) var feeLimit:Lnrpc.FeeLimit!
        public fileprivate(set) var hasFeeLimit:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasDest {
                try codedOutputStream.writeData(fieldNumber: 1, value:dest)
            }
            if hasDestString {
                try codedOutputStream.writeString(fieldNumber: 2, value:destString)
            }
            if hasAmt {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:amt)
            }
            if hasPaymentHash {
                try codedOutputStream.writeData(fieldNumber: 4, value:paymentHash)
            }
            if hasPaymentHashString {
                try codedOutputStream.writeString(fieldNumber: 5, value:paymentHashString)
            }
            if hasPaymentRequest {
                try codedOutputStream.writeString(fieldNumber: 6, value:paymentRequest)
            }
            if hasFinalCltvDelta {
                try codedOutputStream.writeInt32(fieldNumber: 7, value:finalCltvDelta)
            }
            if hasFeeLimit {
                try codedOutputStream.writeMessage(fieldNumber: 8, value:feeLimit)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasDest {
                serialize_size += dest.computeDataSize(fieldNumber: 1)
            }
            if hasDestString {
                serialize_size += destString.computeStringSize(fieldNumber: 2)
            }
            if hasAmt {
                serialize_size += amt.computeInt64Size(fieldNumber: 3)
            }
            if hasPaymentHash {
                serialize_size += paymentHash.computeDataSize(fieldNumber: 4)
            }
            if hasPaymentHashString {
                serialize_size += paymentHashString.computeStringSize(fieldNumber: 5)
            }
            if hasPaymentRequest {
                serialize_size += paymentRequest.computeStringSize(fieldNumber: 6)
            }
            if hasFinalCltvDelta {
                serialize_size += finalCltvDelta.computeInt32Size(fieldNumber: 7)
            }
            if hasFeeLimit {
                if let varSizefeeLimit = feeLimit?.computeMessageSize(fieldNumber: 8) {
                    serialize_size += varSizefeeLimit
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.SendRequest.Builder {
            return Lnrpc.SendRequest.classBuilder() as! Lnrpc.SendRequest.Builder
        }
        public func getBuilder() -> Lnrpc.SendRequest.Builder {
            return classBuilder() as! Lnrpc.SendRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.SendRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.SendRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.SendRequest.Builder {
            return try Lnrpc.SendRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.SendRequest) throws -> Lnrpc.SendRequest.Builder {
            return try Lnrpc.SendRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasDest {
                jsonMap["dest"] = dest.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasDestString {
                jsonMap["destString"] = destString
            }
            if hasAmt {
                jsonMap["amt"] = "\(amt!)"
            }
            if hasPaymentHash {
                jsonMap["paymentHash"] = paymentHash.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasPaymentHashString {
                jsonMap["paymentHashString"] = paymentHashString
            }
            if hasPaymentRequest {
                jsonMap["paymentRequest"] = paymentRequest
            }
            if hasFinalCltvDelta {
                jsonMap["finalCltvDelta"] = Int(finalCltvDelta)
            }
            if hasFeeLimit {
                jsonMap["feeLimit"] = try feeLimit.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.SendRequest {
            return try Lnrpc.SendRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.SendRequest {
            return try Lnrpc.SendRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasDest {
                output += "\(indent) dest: \(dest) \n"
            }
            if hasDestString {
                output += "\(indent) destString: \(destString) \n"
            }
            if hasAmt {
                output += "\(indent) amt: \(amt) \n"
            }
            if hasPaymentHash {
                output += "\(indent) paymentHash: \(paymentHash) \n"
            }
            if hasPaymentHashString {
                output += "\(indent) paymentHashString: \(paymentHashString) \n"
            }
            if hasPaymentRequest {
                output += "\(indent) paymentRequest: \(paymentRequest) \n"
            }
            if hasFinalCltvDelta {
                output += "\(indent) finalCltvDelta: \(finalCltvDelta) \n"
            }
            if hasFeeLimit {
                output += "\(indent) feeLimit {\n"
                if let outDescFeeLimit = feeLimit {
                    output += try outDescFeeLimit.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasDest {
                    hashCode = (hashCode &* 31) &+ dest.hashValue
                }
                if hasDestString {
                    hashCode = (hashCode &* 31) &+ destString.hashValue
                }
                if hasAmt {
                    hashCode = (hashCode &* 31) &+ amt.hashValue
                }
                if hasPaymentHash {
                    hashCode = (hashCode &* 31) &+ paymentHash.hashValue
                }
                if hasPaymentHashString {
                    hashCode = (hashCode &* 31) &+ paymentHashString.hashValue
                }
                if hasPaymentRequest {
                    hashCode = (hashCode &* 31) &+ paymentRequest.hashValue
                }
                if hasFinalCltvDelta {
                    hashCode = (hashCode &* 31) &+ finalCltvDelta.hashValue
                }
                if hasFeeLimit {
                    if let hashValuefeeLimit = feeLimit?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuefeeLimit
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.SendRequest"
        }
        override public func className() -> String {
            return "Lnrpc.SendRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.SendRequest = Lnrpc.SendRequest()
            public func getMessage() -> Lnrpc.SendRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The identity pubkey of the payment recipient
            public var dest:Data {
                get {
                    return builderResult.dest
                }
                set (value) {
                    builderResult.hasDest = true
                    builderResult.dest = value
                }
            }
            public var hasDest:Bool {
                get {
                    return builderResult.hasDest
                }
            }
            @discardableResult
            public func setDest(_ value:Data) -> Lnrpc.SendRequest.Builder {
                self.dest = value
                return self
            }
            @discardableResult
            public func clearDest() -> Lnrpc.SendRequest.Builder{
                builderResult.hasDest = false
                builderResult.dest = nil
                return self
            }
            //// The hex-encoded identity pubkey of the payment recipient
            public var destString:String {
                get {
                    return builderResult.destString
                }
                set (value) {
                    builderResult.hasDestString = true
                    builderResult.destString = value
                }
            }
            public var hasDestString:Bool {
                get {
                    return builderResult.hasDestString
                }
            }
            @discardableResult
            public func setDestString(_ value:String) -> Lnrpc.SendRequest.Builder {
                self.destString = value
                return self
            }
            @discardableResult
            public func clearDestString() -> Lnrpc.SendRequest.Builder{
                builderResult.hasDestString = false
                builderResult.destString = nil
                return self
            }
            //// Number of satoshis to send.
            public var amt:Int64 {
                get {
                    return builderResult.amt
                }
                set (value) {
                    builderResult.hasAmt = true
                    builderResult.amt = value
                }
            }
            public var hasAmt:Bool {
                get {
                    return builderResult.hasAmt
                }
            }
            @discardableResult
            public func setAmt(_ value:Int64) -> Lnrpc.SendRequest.Builder {
                self.amt = value
                return self
            }
            @discardableResult
            public func clearAmt() -> Lnrpc.SendRequest.Builder{
                builderResult.hasAmt = false
                builderResult.amt = nil
                return self
            }
            //// The hash to use within the payment's HTLC
            public var paymentHash:Data {
                get {
                    return builderResult.paymentHash
                }
                set (value) {
                    builderResult.hasPaymentHash = true
                    builderResult.paymentHash = value
                }
            }
            public var hasPaymentHash:Bool {
                get {
                    return builderResult.hasPaymentHash
                }
            }
            @discardableResult
            public func setPaymentHash(_ value:Data) -> Lnrpc.SendRequest.Builder {
                self.paymentHash = value
                return self
            }
            @discardableResult
            public func clearPaymentHash() -> Lnrpc.SendRequest.Builder{
                builderResult.hasPaymentHash = false
                builderResult.paymentHash = nil
                return self
            }
            //// The hex-encoded hash to use within the payment's HTLC
            public var paymentHashString:String {
                get {
                    return builderResult.paymentHashString
                }
                set (value) {
                    builderResult.hasPaymentHashString = true
                    builderResult.paymentHashString = value
                }
            }
            public var hasPaymentHashString:Bool {
                get {
                    return builderResult.hasPaymentHashString
                }
            }
            @discardableResult
            public func setPaymentHashString(_ value:String) -> Lnrpc.SendRequest.Builder {
                self.paymentHashString = value
                return self
            }
            @discardableResult
            public func clearPaymentHashString() -> Lnrpc.SendRequest.Builder{
                builderResult.hasPaymentHashString = false
                builderResult.paymentHashString = nil
                return self
            }
            ///*
            ///A bare-bones invoice for a payment within the Lightning Network.  With the
            ///details of the invoice, the sender has all the data necessary to send a
            ///payment to the recipient.
            public var paymentRequest:String {
                get {
                    return builderResult.paymentRequest
                }
                set (value) {
                    builderResult.hasPaymentRequest = true
                    builderResult.paymentRequest = value
                }
            }
            public var hasPaymentRequest:Bool {
                get {
                    return builderResult.hasPaymentRequest
                }
            }
            @discardableResult
            public func setPaymentRequest(_ value:String) -> Lnrpc.SendRequest.Builder {
                self.paymentRequest = value
                return self
            }
            @discardableResult
            public func clearPaymentRequest() -> Lnrpc.SendRequest.Builder{
                builderResult.hasPaymentRequest = false
                builderResult.paymentRequest = nil
                return self
            }
            ///*
            ///The CLTV delta from the current height that should be used to set the
            ///timelock for the final hop.
            public var finalCltvDelta:Int32 {
                get {
                    return builderResult.finalCltvDelta
                }
                set (value) {
                    builderResult.hasFinalCltvDelta = true
                    builderResult.finalCltvDelta = value
                }
            }
            public var hasFinalCltvDelta:Bool {
                get {
                    return builderResult.hasFinalCltvDelta
                }
            }
            @discardableResult
            public func setFinalCltvDelta(_ value:Int32) -> Lnrpc.SendRequest.Builder {
                self.finalCltvDelta = value
                return self
            }
            @discardableResult
            public func clearFinalCltvDelta() -> Lnrpc.SendRequest.Builder{
                builderResult.hasFinalCltvDelta = false
                builderResult.finalCltvDelta = nil
                return self
            }
            ///*
            ///The maximum number of satoshis that will be paid as a fee of the payment.
            ///This value can be represented either as a percentage of the amount being
            ///sent, or as a fixed amount of the maximum fee the user is willing the pay to
            ///send the payment.
            public var feeLimit:Lnrpc.FeeLimit! {
                get {
                    if feeLimitBuilder_ != nil {
                        builderResult.feeLimit = feeLimitBuilder_.getMessage()
                    }
                    return builderResult.feeLimit
                }
                set (value) {
                    builderResult.hasFeeLimit = value != nil
                    builderResult.feeLimit = value
                }
            }
            public var hasFeeLimit:Bool {
                get {
                    return builderResult.hasFeeLimit
                }
            }
            fileprivate var feeLimitBuilder_:Lnrpc.FeeLimit.Builder! {
                didSet {
                    builderResult.hasFeeLimit = true
                }
            }
            public func getFeeLimitBuilder() -> Lnrpc.FeeLimit.Builder {
                if feeLimitBuilder_ == nil {
                    feeLimitBuilder_ = Lnrpc.FeeLimit.Builder()
                    builderResult.feeLimit = feeLimitBuilder_.getMessage()
                    if feeLimit != nil {
                        try! feeLimitBuilder_.mergeFrom(other: feeLimit)
                    }
                }
                return feeLimitBuilder_
            }
            @discardableResult
            public func setFeeLimit(_ value:Lnrpc.FeeLimit!) -> Lnrpc.SendRequest.Builder {
                self.feeLimit = value
                return self
            }
            @discardableResult
            public func mergeFeeLimit(value:Lnrpc.FeeLimit) throws -> Lnrpc.SendRequest.Builder {
                if builderResult.hasFeeLimit {
                    builderResult.feeLimit = try Lnrpc.FeeLimit.builderWithPrototype(prototype:builderResult.feeLimit).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.feeLimit = value
                }
                builderResult.hasFeeLimit = true
                return self
            }
            @discardableResult
            public func clearFeeLimit() -> Lnrpc.SendRequest.Builder {
                feeLimitBuilder_ = nil
                builderResult.hasFeeLimit = false
                builderResult.feeLimit = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.SendRequest.Builder {
                builderResult = Lnrpc.SendRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.SendRequest.Builder {
                return try Lnrpc.SendRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.SendRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.SendRequest {
                let returnMe:Lnrpc.SendRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.SendRequest) throws -> Lnrpc.SendRequest.Builder {
                if other == Lnrpc.SendRequest() {
                    return self
                }
                if other.hasDest {
                    dest = other.dest
                }
                if other.hasDestString {
                    destString = other.destString
                }
                if other.hasAmt {
                    amt = other.amt
                }
                if other.hasPaymentHash {
                    paymentHash = other.paymentHash
                }
                if other.hasPaymentHashString {
                    paymentHashString = other.paymentHashString
                }
                if other.hasPaymentRequest {
                    paymentRequest = other.paymentRequest
                }
                if other.hasFinalCltvDelta {
                    finalCltvDelta = other.finalCltvDelta
                }
                if (other.hasFeeLimit) {
                    try mergeFeeLimit(value: other.feeLimit)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.SendRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        dest = try codedInputStream.readData()

                    case 18:
                        destString = try codedInputStream.readString()

                    case 24:
                        amt = try codedInputStream.readInt64()

                    case 34:
                        paymentHash = try codedInputStream.readData()

                    case 42:
                        paymentHashString = try codedInputStream.readString()

                    case 50:
                        paymentRequest = try codedInputStream.readString()

                    case 56:
                        finalCltvDelta = try codedInputStream.readInt32()

                    case 66:
                        let subBuilder:Lnrpc.FeeLimit.Builder = Lnrpc.FeeLimit.Builder()
                        if hasFeeLimit {
                            try subBuilder.mergeFrom(other: feeLimit)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        feeLimit = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.SendRequest.Builder {
                let resultDecodedBuilder = Lnrpc.SendRequest.Builder()
                if let jsonValueDest = jsonMap["dest"] as? String {
                    resultDecodedBuilder.dest = Data(base64Encoded:jsonValueDest, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueDestString = jsonMap["destString"] as? String {
                    resultDecodedBuilder.destString = jsonValueDestString
                }
                if let jsonValueAmt = jsonMap["amt"] as? String {
                    resultDecodedBuilder.amt = Int64(jsonValueAmt)!
                } else if let jsonValueAmt = jsonMap["amt"] as? Int {
                    resultDecodedBuilder.amt = Int64(jsonValueAmt)
                }
                if let jsonValuePaymentHash = jsonMap["paymentHash"] as? String {
                    resultDecodedBuilder.paymentHash = Data(base64Encoded:jsonValuePaymentHash, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValuePaymentHashString = jsonMap["paymentHashString"] as? String {
                    resultDecodedBuilder.paymentHashString = jsonValuePaymentHashString
                }
                if let jsonValuePaymentRequest = jsonMap["paymentRequest"] as? String {
                    resultDecodedBuilder.paymentRequest = jsonValuePaymentRequest
                }
                if let jsonValueFinalCltvDelta = jsonMap["finalCltvDelta"] as? Int {
                    resultDecodedBuilder.finalCltvDelta = Int32(jsonValueFinalCltvDelta)
                } else if let jsonValueFinalCltvDelta = jsonMap["finalCltvDelta"] as? String {
                    resultDecodedBuilder.finalCltvDelta = Int32(jsonValueFinalCltvDelta)!
                }
                if let jsonValueFeeLimit = jsonMap["feeLimit"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.feeLimit = try Lnrpc.FeeLimit.Builder.decodeToBuilder(jsonMap:jsonValueFeeLimit).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.SendRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.SendRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SendResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.SendResponse.Builder

        public static func == (lhs: Lnrpc.SendResponse, rhs: Lnrpc.SendResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasPaymentError == rhs.hasPaymentError) && (!lhs.hasPaymentError || lhs.paymentError == rhs.paymentError)
            fieldCheck = fieldCheck && (lhs.hasPaymentPreimage == rhs.hasPaymentPreimage) && (!lhs.hasPaymentPreimage || lhs.paymentPreimage == rhs.paymentPreimage)
            fieldCheck = fieldCheck && (lhs.hasPaymentRoute == rhs.hasPaymentRoute) && (!lhs.hasPaymentRoute || lhs.paymentRoute == rhs.paymentRoute)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var paymentError:String! = nil
        public fileprivate(set) var hasPaymentError:Bool = false

        public fileprivate(set) var paymentPreimage:Data! = nil
        public fileprivate(set) var hasPaymentPreimage:Bool = false

        public fileprivate(set) var paymentRoute:Lnrpc.Route!
        public fileprivate(set) var hasPaymentRoute:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasPaymentError {
                try codedOutputStream.writeString(fieldNumber: 1, value:paymentError)
            }
            if hasPaymentPreimage {
                try codedOutputStream.writeData(fieldNumber: 2, value:paymentPreimage)
            }
            if hasPaymentRoute {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:paymentRoute)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasPaymentError {
                serialize_size += paymentError.computeStringSize(fieldNumber: 1)
            }
            if hasPaymentPreimage {
                serialize_size += paymentPreimage.computeDataSize(fieldNumber: 2)
            }
            if hasPaymentRoute {
                if let varSizepaymentRoute = paymentRoute?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizepaymentRoute
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.SendResponse.Builder {
            return Lnrpc.SendResponse.classBuilder() as! Lnrpc.SendResponse.Builder
        }
        public func getBuilder() -> Lnrpc.SendResponse.Builder {
            return classBuilder() as! Lnrpc.SendResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.SendResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.SendResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.SendResponse.Builder {
            return try Lnrpc.SendResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.SendResponse) throws -> Lnrpc.SendResponse.Builder {
            return try Lnrpc.SendResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasPaymentError {
                jsonMap["payment_error"] = paymentError
            }
            if hasPaymentPreimage {
                jsonMap["payment_preimage"] = paymentPreimage.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasPaymentRoute {
                jsonMap["payment_route"] = try paymentRoute.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.SendResponse {
            return try Lnrpc.SendResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.SendResponse {
            return try Lnrpc.SendResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasPaymentError {
                output += "\(indent) paymentError: \(paymentError) \n"
            }
            if hasPaymentPreimage {
                output += "\(indent) paymentPreimage: \(paymentPreimage) \n"
            }
            if hasPaymentRoute {
                output += "\(indent) paymentRoute {\n"
                if let outDescPaymentRoute = paymentRoute {
                    output += try outDescPaymentRoute.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasPaymentError {
                    hashCode = (hashCode &* 31) &+ paymentError.hashValue
                }
                if hasPaymentPreimage {
                    hashCode = (hashCode &* 31) &+ paymentPreimage.hashValue
                }
                if hasPaymentRoute {
                    if let hashValuepaymentRoute = paymentRoute?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuepaymentRoute
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.SendResponse"
        }
        override public func className() -> String {
            return "Lnrpc.SendResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.SendResponse = Lnrpc.SendResponse()
            public func getMessage() -> Lnrpc.SendResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var paymentError:String {
                get {
                    return builderResult.paymentError
                }
                set (value) {
                    builderResult.hasPaymentError = true
                    builderResult.paymentError = value
                }
            }
            public var hasPaymentError:Bool {
                get {
                    return builderResult.hasPaymentError
                }
            }
            @discardableResult
            public func setPaymentError(_ value:String) -> Lnrpc.SendResponse.Builder {
                self.paymentError = value
                return self
            }
            @discardableResult
            public func clearPaymentError() -> Lnrpc.SendResponse.Builder{
                builderResult.hasPaymentError = false
                builderResult.paymentError = nil
                return self
            }
            public var paymentPreimage:Data {
                get {
                    return builderResult.paymentPreimage
                }
                set (value) {
                    builderResult.hasPaymentPreimage = true
                    builderResult.paymentPreimage = value
                }
            }
            public var hasPaymentPreimage:Bool {
                get {
                    return builderResult.hasPaymentPreimage
                }
            }
            @discardableResult
            public func setPaymentPreimage(_ value:Data) -> Lnrpc.SendResponse.Builder {
                self.paymentPreimage = value
                return self
            }
            @discardableResult
            public func clearPaymentPreimage() -> Lnrpc.SendResponse.Builder{
                builderResult.hasPaymentPreimage = false
                builderResult.paymentPreimage = nil
                return self
            }
            public var paymentRoute:Lnrpc.Route! {
                get {
                    if paymentRouteBuilder_ != nil {
                        builderResult.paymentRoute = paymentRouteBuilder_.getMessage()
                    }
                    return builderResult.paymentRoute
                }
                set (value) {
                    builderResult.hasPaymentRoute = value != nil
                    builderResult.paymentRoute = value
                }
            }
            public var hasPaymentRoute:Bool {
                get {
                    return builderResult.hasPaymentRoute
                }
            }
            fileprivate var paymentRouteBuilder_:Lnrpc.Route.Builder! {
                didSet {
                    builderResult.hasPaymentRoute = true
                }
            }
            public func getPaymentRouteBuilder() -> Lnrpc.Route.Builder {
                if paymentRouteBuilder_ == nil {
                    paymentRouteBuilder_ = Lnrpc.Route.Builder()
                    builderResult.paymentRoute = paymentRouteBuilder_.getMessage()
                    if paymentRoute != nil {
                        try! paymentRouteBuilder_.mergeFrom(other: paymentRoute)
                    }
                }
                return paymentRouteBuilder_
            }
            @discardableResult
            public func setPaymentRoute(_ value:Lnrpc.Route!) -> Lnrpc.SendResponse.Builder {
                self.paymentRoute = value
                return self
            }
            @discardableResult
            public func mergePaymentRoute(value:Lnrpc.Route) throws -> Lnrpc.SendResponse.Builder {
                if builderResult.hasPaymentRoute {
                    builderResult.paymentRoute = try Lnrpc.Route.builderWithPrototype(prototype:builderResult.paymentRoute).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.paymentRoute = value
                }
                builderResult.hasPaymentRoute = true
                return self
            }
            @discardableResult
            public func clearPaymentRoute() -> Lnrpc.SendResponse.Builder {
                paymentRouteBuilder_ = nil
                builderResult.hasPaymentRoute = false
                builderResult.paymentRoute = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.SendResponse.Builder {
                builderResult = Lnrpc.SendResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.SendResponse.Builder {
                return try Lnrpc.SendResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.SendResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.SendResponse {
                let returnMe:Lnrpc.SendResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.SendResponse) throws -> Lnrpc.SendResponse.Builder {
                if other == Lnrpc.SendResponse() {
                    return self
                }
                if other.hasPaymentError {
                    paymentError = other.paymentError
                }
                if other.hasPaymentPreimage {
                    paymentPreimage = other.paymentPreimage
                }
                if (other.hasPaymentRoute) {
                    try mergePaymentRoute(value: other.paymentRoute)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.SendResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        paymentError = try codedInputStream.readString()

                    case 18:
                        paymentPreimage = try codedInputStream.readData()

                    case 26:
                        let subBuilder:Lnrpc.Route.Builder = Lnrpc.Route.Builder()
                        if hasPaymentRoute {
                            try subBuilder.mergeFrom(other: paymentRoute)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        paymentRoute = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.SendResponse.Builder {
                let resultDecodedBuilder = Lnrpc.SendResponse.Builder()
                if let jsonValuePaymentError = jsonMap["payment_error"] as? String {
                    resultDecodedBuilder.paymentError = jsonValuePaymentError
                }
                if let jsonValuePaymentPreimage = jsonMap["payment_preimage"] as? String {
                    resultDecodedBuilder.paymentPreimage = Data(base64Encoded:jsonValuePaymentPreimage, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValuePaymentRoute = jsonMap["payment_route"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.paymentRoute = try Lnrpc.Route.Builder.decodeToBuilder(jsonMap:jsonValuePaymentRoute).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.SendResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.SendResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SendToRouteRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.SendToRouteRequest.Builder

        public static func == (lhs: Lnrpc.SendToRouteRequest, rhs: Lnrpc.SendToRouteRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasPaymentHash == rhs.hasPaymentHash) && (!lhs.hasPaymentHash || lhs.paymentHash == rhs.paymentHash)
            fieldCheck = fieldCheck && (lhs.hasPaymentHashString == rhs.hasPaymentHashString) && (!lhs.hasPaymentHashString || lhs.paymentHashString == rhs.paymentHashString)
            fieldCheck = fieldCheck && (lhs.routes == rhs.routes)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// The payment hash to use for the HTLC.
        public fileprivate(set) var paymentHash:Data! = nil
        public fileprivate(set) var hasPaymentHash:Bool = false

        //// An optional hex-encoded payment hash to be used for the HTLC.
        public fileprivate(set) var paymentHashString:String! = nil
        public fileprivate(set) var hasPaymentHashString:Bool = false

        public fileprivate(set) var routes:Array<Lnrpc.Route>  = Array<Lnrpc.Route>()
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasPaymentHash {
                try codedOutputStream.writeData(fieldNumber: 1, value:paymentHash)
            }
            if hasPaymentHashString {
                try codedOutputStream.writeString(fieldNumber: 2, value:paymentHashString)
            }
            for oneElementRoutes in routes {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementRoutes)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasPaymentHash {
                serialize_size += paymentHash.computeDataSize(fieldNumber: 1)
            }
            if hasPaymentHashString {
                serialize_size += paymentHashString.computeStringSize(fieldNumber: 2)
            }
            for oneElementRoutes in routes {
                serialize_size += oneElementRoutes.computeMessageSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.SendToRouteRequest.Builder {
            return Lnrpc.SendToRouteRequest.classBuilder() as! Lnrpc.SendToRouteRequest.Builder
        }
        public func getBuilder() -> Lnrpc.SendToRouteRequest.Builder {
            return classBuilder() as! Lnrpc.SendToRouteRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.SendToRouteRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.SendToRouteRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.SendToRouteRequest.Builder {
            return try Lnrpc.SendToRouteRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.SendToRouteRequest) throws -> Lnrpc.SendToRouteRequest.Builder {
            return try Lnrpc.SendToRouteRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasPaymentHash {
                jsonMap["paymentHash"] = paymentHash.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasPaymentHashString {
                jsonMap["paymentHashString"] = paymentHashString
            }
            if !routes.isEmpty {
                var jsonArrayRoutes:Array<Dictionary<String,Any>> = []
                for oneValueRoutes in routes {
                    let ecodedMessageRoutes = try oneValueRoutes.encode()
                    jsonArrayRoutes.append(ecodedMessageRoutes)
                }
                jsonMap["routes"] = jsonArrayRoutes
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.SendToRouteRequest {
            return try Lnrpc.SendToRouteRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.SendToRouteRequest {
            return try Lnrpc.SendToRouteRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasPaymentHash {
                output += "\(indent) paymentHash: \(paymentHash) \n"
            }
            if hasPaymentHashString {
                output += "\(indent) paymentHashString: \(paymentHashString) \n"
            }
            var routesElementIndex:Int = 0
            for oneElementRoutes in routes {
                output += "\(indent) routes[\(routesElementIndex)] {\n"
                output += try oneElementRoutes.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                routesElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasPaymentHash {
                    hashCode = (hashCode &* 31) &+ paymentHash.hashValue
                }
                if hasPaymentHashString {
                    hashCode = (hashCode &* 31) &+ paymentHashString.hashValue
                }
                for oneElementRoutes in routes {
                    hashCode = (hashCode &* 31) &+ oneElementRoutes.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.SendToRouteRequest"
        }
        override public func className() -> String {
            return "Lnrpc.SendToRouteRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.SendToRouteRequest = Lnrpc.SendToRouteRequest()
            public func getMessage() -> Lnrpc.SendToRouteRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The payment hash to use for the HTLC.
            public var paymentHash:Data {
                get {
                    return builderResult.paymentHash
                }
                set (value) {
                    builderResult.hasPaymentHash = true
                    builderResult.paymentHash = value
                }
            }
            public var hasPaymentHash:Bool {
                get {
                    return builderResult.hasPaymentHash
                }
            }
            @discardableResult
            public func setPaymentHash(_ value:Data) -> Lnrpc.SendToRouteRequest.Builder {
                self.paymentHash = value
                return self
            }
            @discardableResult
            public func clearPaymentHash() -> Lnrpc.SendToRouteRequest.Builder{
                builderResult.hasPaymentHash = false
                builderResult.paymentHash = nil
                return self
            }
            //// An optional hex-encoded payment hash to be used for the HTLC.
            public var paymentHashString:String {
                get {
                    return builderResult.paymentHashString
                }
                set (value) {
                    builderResult.hasPaymentHashString = true
                    builderResult.paymentHashString = value
                }
            }
            public var hasPaymentHashString:Bool {
                get {
                    return builderResult.hasPaymentHashString
                }
            }
            @discardableResult
            public func setPaymentHashString(_ value:String) -> Lnrpc.SendToRouteRequest.Builder {
                self.paymentHashString = value
                return self
            }
            @discardableResult
            public func clearPaymentHashString() -> Lnrpc.SendToRouteRequest.Builder{
                builderResult.hasPaymentHashString = false
                builderResult.paymentHashString = nil
                return self
            }
            //// The set of routes that should be used to attempt to complete the payment.
            public var routes:Array<Lnrpc.Route> {
                get {
                    return builderResult.routes
                }
                set (value) {
                    builderResult.routes = value
                }
            }
            @discardableResult
            public func setRoutes(_ value:Array<Lnrpc.Route>) -> Lnrpc.SendToRouteRequest.Builder {
                self.routes = value
                return self
            }
            @discardableResult
            public func clearRoutes() -> Lnrpc.SendToRouteRequest.Builder {
                builderResult.routes.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.SendToRouteRequest.Builder {
                builderResult = Lnrpc.SendToRouteRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.SendToRouteRequest.Builder {
                return try Lnrpc.SendToRouteRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.SendToRouteRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.SendToRouteRequest {
                let returnMe:Lnrpc.SendToRouteRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.SendToRouteRequest) throws -> Lnrpc.SendToRouteRequest.Builder {
                if other == Lnrpc.SendToRouteRequest() {
                    return self
                }
                if other.hasPaymentHash {
                    paymentHash = other.paymentHash
                }
                if other.hasPaymentHashString {
                    paymentHashString = other.paymentHashString
                }
                if !other.routes.isEmpty  {
                     builderResult.routes += other.routes
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.SendToRouteRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendToRouteRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        paymentHash = try codedInputStream.readData()

                    case 18:
                        paymentHashString = try codedInputStream.readString()

                    case 26:
                        let subBuilder = Lnrpc.Route.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        routes.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.SendToRouteRequest.Builder {
                let resultDecodedBuilder = Lnrpc.SendToRouteRequest.Builder()
                if let jsonValuePaymentHash = jsonMap["paymentHash"] as? String {
                    resultDecodedBuilder.paymentHash = Data(base64Encoded:jsonValuePaymentHash, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValuePaymentHashString = jsonMap["paymentHashString"] as? String {
                    resultDecodedBuilder.paymentHashString = jsonValuePaymentHashString
                }
                if let jsonValueRoutes = jsonMap["routes"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayRoutes:Array<Lnrpc.Route> = []
                    for oneValueRoutes in jsonValueRoutes {
                        let messageFromStringRoutes = try Lnrpc.Route.Builder.decodeToBuilder(jsonMap:oneValueRoutes).build()

                        jsonArrayRoutes.append(messageFromStringRoutes)
                    }
                    resultDecodedBuilder.routes = jsonArrayRoutes
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.SendToRouteRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.SendToRouteRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ChannelPoint : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ChannelPoint.Builder

        public static func == (lhs: Lnrpc.ChannelPoint, rhs: Lnrpc.ChannelPoint) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFundingTxidBytes == rhs.hasFundingTxidBytes) && (!lhs.hasFundingTxidBytes || lhs.fundingTxidBytes == rhs.fundingTxidBytes)
            fieldCheck = fieldCheck && (lhs.hasFundingTxidStr == rhs.hasFundingTxidStr) && (!lhs.hasFundingTxidStr || lhs.fundingTxidStr == rhs.fundingTxidStr)
            fieldCheck = fieldCheck && (lhs.hasOutputIndex == rhs.hasOutputIndex) && (!lhs.hasOutputIndex || lhs.outputIndex == rhs.outputIndex)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        public enum FundingTxid {
            case oneOfFundingTxidNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .oneOfFundingTxidNotSet: return false
                default: return true
                }
            }
            case fundingTxidBytes(Data)

            public static func getFundingTxidBytes(_ value:FundingTxid) -> Data? {
                switch value {
                case .fundingTxidBytes(let otherValue): return otherValue
                default: return nil
                }
            }
            public func getFundingTxidBytes() -> Data? {
                switch self {
                case .fundingTxidBytes(let otherValue): return otherValue
                default: return nil
                }
            }
            case fundingTxidStr(String)

            public static func getFundingTxidStr(_ value:FundingTxid) -> String? {
                switch value {
                case .fundingTxidStr(let otherValue): return otherValue
                default: return nil
                }
            }
            public func getFundingTxidStr() -> String? {
                switch self {
                case .fundingTxidStr(let otherValue): return otherValue
                default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageFundingTxid:ChannelPoint.FundingTxid =  ChannelPoint.FundingTxid.oneOfFundingTxidNotSet
        public func getOneOfFundingTxid() ->  ChannelPoint.FundingTxid {
            let copyObjectFundingTxid = storageFundingTxid
            return copyObjectFundingTxid
        }
        //// Txid of the funding transaction
        public fileprivate(set) var fundingTxidBytes:Data!{
            get {
                return ChannelPoint.FundingTxid.getFundingTxidBytes(storageFundingTxid)
            }
            set (newvalue) {
                storageFundingTxid = ChannelPoint.FundingTxid.fundingTxidBytes(newvalue)
            }
        }
        public fileprivate(set) var hasFundingTxidBytes:Bool {
            get {
                return ChannelPoint.FundingTxid.getFundingTxidBytes(storageFundingTxid) != nil
            }
            set(newValue) {
            }
        }
        //// Hex-encoded string representing the funding transaction
        public fileprivate(set) var fundingTxidStr:String!{
            get {
                return ChannelPoint.FundingTxid.getFundingTxidStr(storageFundingTxid)
            }
            set (newvalue) {
                storageFundingTxid = ChannelPoint.FundingTxid.fundingTxidStr(newvalue)
            }
        }
        public fileprivate(set) var hasFundingTxidStr:Bool {
            get {
                return ChannelPoint.FundingTxid.getFundingTxidStr(storageFundingTxid) != nil
            }
            set(newValue) {
            }
        }
        //// The index of the output of the funding transaction
        public fileprivate(set) var outputIndex:UInt32! = nil
        public fileprivate(set) var hasOutputIndex:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFundingTxidBytes {
                try codedOutputStream.writeData(fieldNumber: 1, value:fundingTxidBytes)
            }
            if hasFundingTxidStr {
                try codedOutputStream.writeString(fieldNumber: 2, value:fundingTxidStr)
            }
            if hasOutputIndex {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:outputIndex)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFundingTxidBytes {
                serialize_size += fundingTxidBytes.computeDataSize(fieldNumber: 1)
            }
            if hasFundingTxidStr {
                serialize_size += fundingTxidStr.computeStringSize(fieldNumber: 2)
            }
            if hasOutputIndex {
                serialize_size += outputIndex.computeUInt32Size(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ChannelPoint.Builder {
            return Lnrpc.ChannelPoint.classBuilder() as! Lnrpc.ChannelPoint.Builder
        }
        public func getBuilder() -> Lnrpc.ChannelPoint.Builder {
            return classBuilder() as! Lnrpc.ChannelPoint.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChannelPoint.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChannelPoint.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ChannelPoint.Builder {
            return try Lnrpc.ChannelPoint.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ChannelPoint) throws -> Lnrpc.ChannelPoint.Builder {
            return try Lnrpc.ChannelPoint.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFundingTxidBytes {
                jsonMap["funding_txid_bytes"] = fundingTxidBytes.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasFundingTxidStr {
                jsonMap["funding_txid_str"] = fundingTxidStr
            }
            if hasOutputIndex {
                jsonMap["output_index"] = UInt(outputIndex)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChannelPoint {
            return try Lnrpc.ChannelPoint.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChannelPoint {
            return try Lnrpc.ChannelPoint.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFundingTxidBytes {
                output += "\(indent) fundingTxidBytes: \(fundingTxidBytes) \n"
            }
            if hasFundingTxidStr {
                output += "\(indent) fundingTxidStr: \(fundingTxidStr) \n"
            }
            if hasOutputIndex {
                output += "\(indent) outputIndex: \(outputIndex) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFundingTxidBytes {
                    hashCode = (hashCode &* 31) &+ fundingTxidBytes.hashValue
                }
                if hasFundingTxidStr {
                    hashCode = (hashCode &* 31) &+ fundingTxidStr.hashValue
                }
                if hasOutputIndex {
                    hashCode = (hashCode &* 31) &+ outputIndex.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ChannelPoint"
        }
        override public func className() -> String {
            return "Lnrpc.ChannelPoint"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ChannelPoint = Lnrpc.ChannelPoint()
            public func getMessage() -> Lnrpc.ChannelPoint {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public func setFundingTxid(_ oneOf:ChannelPoint.FundingTxid) ->  Lnrpc.ChannelPoint.Builder {
                builderResult.storageFundingTxid = oneOf
                return self
            }
            //// Txid of the funding transaction
            public var fundingTxidBytes:Data {
                get {
                    return builderResult.fundingTxidBytes
                }
                set (value) {
                    builderResult.hasFundingTxidBytes = true
                    builderResult.fundingTxidBytes = value
                }
            }
            public var hasFundingTxidBytes:Bool {
                get {
                    return builderResult.hasFundingTxidBytes
                }
            }
            @discardableResult
            public func setFundingTxidBytes(_ value:Data) -> Lnrpc.ChannelPoint.Builder {
                self.fundingTxidBytes = value
                return self
            }
            @discardableResult
            public func clearFundingTxidBytes() -> Lnrpc.ChannelPoint.Builder{
                builderResult.hasFundingTxidBytes = false
                builderResult.fundingTxidBytes = nil
                return self
            }
            //// Hex-encoded string representing the funding transaction
            public var fundingTxidStr:String {
                get {
                    return builderResult.fundingTxidStr
                }
                set (value) {
                    builderResult.hasFundingTxidStr = true
                    builderResult.fundingTxidStr = value
                }
            }
            public var hasFundingTxidStr:Bool {
                get {
                    return builderResult.hasFundingTxidStr
                }
            }
            @discardableResult
            public func setFundingTxidStr(_ value:String) -> Lnrpc.ChannelPoint.Builder {
                self.fundingTxidStr = value
                return self
            }
            @discardableResult
            public func clearFundingTxidStr() -> Lnrpc.ChannelPoint.Builder{
                builderResult.hasFundingTxidStr = false
                builderResult.fundingTxidStr = nil
                return self
            }
            //// The index of the output of the funding transaction
            public var outputIndex:UInt32 {
                get {
                    return builderResult.outputIndex
                }
                set (value) {
                    builderResult.hasOutputIndex = true
                    builderResult.outputIndex = value
                }
            }
            public var hasOutputIndex:Bool {
                get {
                    return builderResult.hasOutputIndex
                }
            }
            @discardableResult
            public func setOutputIndex(_ value:UInt32) -> Lnrpc.ChannelPoint.Builder {
                self.outputIndex = value
                return self
            }
            @discardableResult
            public func clearOutputIndex() -> Lnrpc.ChannelPoint.Builder{
                builderResult.hasOutputIndex = false
                builderResult.outputIndex = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ChannelPoint.Builder {
                builderResult = Lnrpc.ChannelPoint()
                return self
            }
            override public func clone() throws -> Lnrpc.ChannelPoint.Builder {
                return try Lnrpc.ChannelPoint.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ChannelPoint {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ChannelPoint {
                let returnMe:Lnrpc.ChannelPoint = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ChannelPoint) throws -> Lnrpc.ChannelPoint.Builder {
                if other == Lnrpc.ChannelPoint() {
                    return self
                }
                if other.hasFundingTxidBytes {
                    fundingTxidBytes = other.fundingTxidBytes
                }
                if other.hasFundingTxidStr {
                    fundingTxidStr = other.fundingTxidStr
                }
                if other.hasOutputIndex {
                    outputIndex = other.outputIndex
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChannelPoint.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelPoint.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        fundingTxidBytes = try codedInputStream.readData()

                    case 18:
                        fundingTxidStr = try codedInputStream.readString()

                    case 24:
                        outputIndex = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChannelPoint.Builder {
                let resultDecodedBuilder = Lnrpc.ChannelPoint.Builder()
                if let jsonValueFundingTxidBytes = jsonMap["funding_txid_bytes"] as? String {
                    resultDecodedBuilder.fundingTxidBytes = Data(base64Encoded:jsonValueFundingTxidBytes, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueFundingTxidStr = jsonMap["funding_txid_str"] as? String {
                    resultDecodedBuilder.fundingTxidStr = jsonValueFundingTxidStr
                }
                if let jsonValueOutputIndex = jsonMap["output_index"] as? UInt {
                    resultDecodedBuilder.outputIndex = UInt32(jsonValueOutputIndex)
                } else if let jsonValueOutputIndex = jsonMap["output_index"] as? String {
                    resultDecodedBuilder.outputIndex = UInt32(jsonValueOutputIndex)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChannelPoint.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ChannelPoint.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class LightningAddress : GeneratedMessage {
        public typealias BuilderType = Lnrpc.LightningAddress.Builder

        public static func == (lhs: Lnrpc.LightningAddress, rhs: Lnrpc.LightningAddress) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasPubkey == rhs.hasPubkey) && (!lhs.hasPubkey || lhs.pubkey == rhs.pubkey)
            fieldCheck = fieldCheck && (lhs.hasHost == rhs.hasHost) && (!lhs.hasHost || lhs.host == rhs.host)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// The identity pubkey of the Lightning node
        public fileprivate(set) var pubkey:String! = nil
        public fileprivate(set) var hasPubkey:Bool = false

        //// The network location of the lightning node, e.g. `69.69.69.69:1337` or `localhost:10011`
        public fileprivate(set) var host:String! = nil
        public fileprivate(set) var hasHost:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasPubkey {
                try codedOutputStream.writeString(fieldNumber: 1, value:pubkey)
            }
            if hasHost {
                try codedOutputStream.writeString(fieldNumber: 2, value:host)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasPubkey {
                serialize_size += pubkey.computeStringSize(fieldNumber: 1)
            }
            if hasHost {
                serialize_size += host.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.LightningAddress.Builder {
            return Lnrpc.LightningAddress.classBuilder() as! Lnrpc.LightningAddress.Builder
        }
        public func getBuilder() -> Lnrpc.LightningAddress.Builder {
            return classBuilder() as! Lnrpc.LightningAddress.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.LightningAddress.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.LightningAddress.Builder()
        }
        public func toBuilder() throws -> Lnrpc.LightningAddress.Builder {
            return try Lnrpc.LightningAddress.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.LightningAddress) throws -> Lnrpc.LightningAddress.Builder {
            return try Lnrpc.LightningAddress.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasPubkey {
                jsonMap["pubkey"] = pubkey
            }
            if hasHost {
                jsonMap["host"] = host
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.LightningAddress {
            return try Lnrpc.LightningAddress.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.LightningAddress {
            return try Lnrpc.LightningAddress.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasPubkey {
                output += "\(indent) pubkey: \(pubkey) \n"
            }
            if hasHost {
                output += "\(indent) host: \(host) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasPubkey {
                    hashCode = (hashCode &* 31) &+ pubkey.hashValue
                }
                if hasHost {
                    hashCode = (hashCode &* 31) &+ host.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.LightningAddress"
        }
        override public func className() -> String {
            return "Lnrpc.LightningAddress"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.LightningAddress = Lnrpc.LightningAddress()
            public func getMessage() -> Lnrpc.LightningAddress {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The identity pubkey of the Lightning node
            public var pubkey:String {
                get {
                    return builderResult.pubkey
                }
                set (value) {
                    builderResult.hasPubkey = true
                    builderResult.pubkey = value
                }
            }
            public var hasPubkey:Bool {
                get {
                    return builderResult.hasPubkey
                }
            }
            @discardableResult
            public func setPubkey(_ value:String) -> Lnrpc.LightningAddress.Builder {
                self.pubkey = value
                return self
            }
            @discardableResult
            public func clearPubkey() -> Lnrpc.LightningAddress.Builder{
                builderResult.hasPubkey = false
                builderResult.pubkey = nil
                return self
            }
            //// The network location of the lightning node, e.g. `69.69.69.69:1337` or `localhost:10011`
            public var host:String {
                get {
                    return builderResult.host
                }
                set (value) {
                    builderResult.hasHost = true
                    builderResult.host = value
                }
            }
            public var hasHost:Bool {
                get {
                    return builderResult.hasHost
                }
            }
            @discardableResult
            public func setHost(_ value:String) -> Lnrpc.LightningAddress.Builder {
                self.host = value
                return self
            }
            @discardableResult
            public func clearHost() -> Lnrpc.LightningAddress.Builder{
                builderResult.hasHost = false
                builderResult.host = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.LightningAddress.Builder {
                builderResult = Lnrpc.LightningAddress()
                return self
            }
            override public func clone() throws -> Lnrpc.LightningAddress.Builder {
                return try Lnrpc.LightningAddress.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.LightningAddress {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.LightningAddress {
                let returnMe:Lnrpc.LightningAddress = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.LightningAddress) throws -> Lnrpc.LightningAddress.Builder {
                if other == Lnrpc.LightningAddress() {
                    return self
                }
                if other.hasPubkey {
                    pubkey = other.pubkey
                }
                if other.hasHost {
                    host = other.host
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.LightningAddress.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.LightningAddress.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        pubkey = try codedInputStream.readString()

                    case 18:
                        host = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.LightningAddress.Builder {
                let resultDecodedBuilder = Lnrpc.LightningAddress.Builder()
                if let jsonValuePubkey = jsonMap["pubkey"] as? String {
                    resultDecodedBuilder.pubkey = jsonValuePubkey
                }
                if let jsonValueHost = jsonMap["host"] as? String {
                    resultDecodedBuilder.host = jsonValueHost
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.LightningAddress.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.LightningAddress.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SendManyRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.SendManyRequest.Builder

        public static func == (lhs: Lnrpc.SendManyRequest, rhs: Lnrpc.SendManyRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasAddrToAmount == rhs.hasAddrToAmount) && (!lhs.hasAddrToAmount || lhs.addrToAmount == rhs.addrToAmount)
            fieldCheck = fieldCheck && (lhs.hasTargetConf == rhs.hasTargetConf) && (!lhs.hasTargetConf || lhs.targetConf == rhs.targetConf)
            fieldCheck = fieldCheck && (lhs.hasSatPerByte == rhs.hasSatPerByte) && (!lhs.hasSatPerByte || lhs.satPerByte == rhs.satPerByte)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class AddrToAmountEntry : GeneratedMessage {
            public typealias BuilderType = Lnrpc.SendManyRequest.AddrToAmountEntry.Builder

            public static func == (lhs: Lnrpc.SendManyRequest.AddrToAmountEntry, rhs: Lnrpc.SendManyRequest.AddrToAmountEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String! = nil
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:Int64! = nil
            public fileprivate(set) var hasValue:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() throws {
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeInt64(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    serialize_size += value.computeInt64Size(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Lnrpc.SendManyRequest.AddrToAmountEntry.Builder {
                return Lnrpc.SendManyRequest.AddrToAmountEntry.classBuilder() as! Lnrpc.SendManyRequest.AddrToAmountEntry.Builder
            }
            public func getBuilder() -> Lnrpc.SendManyRequest.AddrToAmountEntry.Builder {
                return classBuilder() as! Lnrpc.SendManyRequest.AddrToAmountEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Lnrpc.SendManyRequest.AddrToAmountEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Lnrpc.SendManyRequest.AddrToAmountEntry.Builder()
            }
            public func toBuilder() throws -> Lnrpc.SendManyRequest.AddrToAmountEntry.Builder {
                return try Lnrpc.SendManyRequest.AddrToAmountEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Lnrpc.SendManyRequest.AddrToAmountEntry) throws -> Lnrpc.SendManyRequest.AddrToAmountEntry.Builder {
                return try Lnrpc.SendManyRequest.AddrToAmountEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                try isInitialized()
                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = "\(value!)"
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.SendManyRequest.AddrToAmountEntry {
                return try Lnrpc.SendManyRequest.AddrToAmountEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.SendManyRequest.AddrToAmountEntry {
                return try Lnrpc.SendManyRequest.AddrToAmountEntry.Builder.fromJSONToBuilder(data:data, options:options).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value: \(value) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        hashCode = (hashCode &* 31) &+ value.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Lnrpc.SendManyRequest.AddrToAmountEntry"
            }
            override public func className() -> String {
                return "Lnrpc.SendManyRequest.AddrToAmountEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Lnrpc.SendManyRequest.AddrToAmountEntry = Lnrpc.SendManyRequest.AddrToAmountEntry()
                public func getMessage() -> Lnrpc.SendManyRequest.AddrToAmountEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Lnrpc.SendManyRequest.AddrToAmountEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Lnrpc.SendManyRequest.AddrToAmountEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = nil
                    return self
                }
                public var value:Int64 {
                    get {
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                @discardableResult
                public func setValue(_ value:Int64) -> Lnrpc.SendManyRequest.AddrToAmountEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> Lnrpc.SendManyRequest.AddrToAmountEntry.Builder{
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Lnrpc.SendManyRequest.AddrToAmountEntry.Builder {
                    builderResult = Lnrpc.SendManyRequest.AddrToAmountEntry()
                    return self
                }
                override public func clone() throws -> Lnrpc.SendManyRequest.AddrToAmountEntry.Builder {
                    return try Lnrpc.SendManyRequest.AddrToAmountEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Lnrpc.SendManyRequest.AddrToAmountEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Lnrpc.SendManyRequest.AddrToAmountEntry {
                    let returnMe:Lnrpc.SendManyRequest.AddrToAmountEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Lnrpc.SendManyRequest.AddrToAmountEntry) throws -> Lnrpc.SendManyRequest.AddrToAmountEntry.Builder {
                    if other == Lnrpc.SendManyRequest.AddrToAmountEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if other.hasValue {
                        value = other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.SendManyRequest.AddrToAmountEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendManyRequest.AddrToAmountEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 16:
                            value = try codedInputStream.readInt64()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.SendManyRequest.AddrToAmountEntry.Builder {
                    let resultDecodedBuilder = Lnrpc.SendManyRequest.AddrToAmountEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? String {
                        resultDecodedBuilder.value = Int64(jsonValueValue)!
                    } else if let jsonValueValue = jsonMap["value"] as? Int {
                        resultDecodedBuilder.value = Int64(jsonValueValue)
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.SendManyRequest.AddrToAmountEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Lnrpc.SendManyRequest.AddrToAmountEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        //// The map from addresses to amounts
        public fileprivate(set) var addrToAmount:Dictionary<String,Int64> = Dictionary<String,Int64>()

        public fileprivate(set) var hasAddrToAmount:Bool = false
        //// The target number of blocks that this transaction should be confirmed by.
        public fileprivate(set) var targetConf:Int32! = nil
        public fileprivate(set) var hasTargetConf:Bool = false

        //// A manual fee rate set in sat/byte that should be used when crafting the transaction.
        public fileprivate(set) var satPerByte:Int64! = nil
        public fileprivate(set) var hasSatPerByte:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasAddrToAmount {
                for (keyAddrToAmount, valueAddrToAmount) in addrToAmount {
                    let valueOfAddrToAmount = try! Lnrpc.SendManyRequest.AddrToAmountEntry.Builder().setKey(keyAddrToAmount).setValue(valueAddrToAmount).build()
                      try codedOutputStream.writeMessage(fieldNumber: 1, value:valueOfAddrToAmount)
                  }
            }
            if hasTargetConf {
                try codedOutputStream.writeInt32(fieldNumber: 3, value:targetConf)
            }
            if hasSatPerByte {
                try codedOutputStream.writeInt64(fieldNumber: 5, value:satPerByte)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasAddrToAmount {
                  for (keyAddrToAmount, valueAddrToAmount) in addrToAmount {
                      let valueOfAddrToAmount = try! Lnrpc.SendManyRequest.AddrToAmountEntry.Builder().setKey(keyAddrToAmount).setValue(valueAddrToAmount).build()
                serialize_size += valueOfAddrToAmount.computeMessageSize(fieldNumber: 1)
                }
            }
            if hasTargetConf {
                serialize_size += targetConf.computeInt32Size(fieldNumber: 3)
            }
            if hasSatPerByte {
                serialize_size += satPerByte.computeInt64Size(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.SendManyRequest.Builder {
            return Lnrpc.SendManyRequest.classBuilder() as! Lnrpc.SendManyRequest.Builder
        }
        public func getBuilder() -> Lnrpc.SendManyRequest.Builder {
            return classBuilder() as! Lnrpc.SendManyRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.SendManyRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.SendManyRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.SendManyRequest.Builder {
            return try Lnrpc.SendManyRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.SendManyRequest) throws -> Lnrpc.SendManyRequest.Builder {
            return try Lnrpc.SendManyRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasAddrToAmount {
                var mapAddrToAmount = Dictionary<String, String>()
                for (keyAddrToAmount, valueAddrToAmount) in addrToAmount {
                    mapAddrToAmount["\(keyAddrToAmount)"] = "\(valueAddrToAmount)"
                }
                jsonMap["AddrToAmount"] = mapAddrToAmount
            }
            if hasTargetConf {
                jsonMap["targetConf"] = Int(targetConf)
            }
            if hasSatPerByte {
                jsonMap["satPerByte"] = "\(satPerByte!)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.SendManyRequest {
            return try Lnrpc.SendManyRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.SendManyRequest {
            return try Lnrpc.SendManyRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasAddrToAmount {
                output += "\(indent) addrToAmount: \(addrToAmount) \n"
            }
            if hasTargetConf {
                output += "\(indent) targetConf: \(targetConf) \n"
            }
            if hasSatPerByte {
                output += "\(indent) satPerByte: \(satPerByte) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasAddrToAmount {
                    for (keyAddrToAmount, valueAddrToAmount) in addrToAmount {
                        hashCode = (hashCode &* 31) &+ keyAddrToAmount.hashValue
                        hashCode = (hashCode &* 31) &+ valueAddrToAmount.hashValue
                    }
                }
                if hasTargetConf {
                    hashCode = (hashCode &* 31) &+ targetConf.hashValue
                }
                if hasSatPerByte {
                    hashCode = (hashCode &* 31) &+ satPerByte.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.SendManyRequest"
        }
        override public func className() -> String {
            return "Lnrpc.SendManyRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.SendManyRequest = Lnrpc.SendManyRequest()
            public func getMessage() -> Lnrpc.SendManyRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The map from addresses to amounts
            public var hasAddrToAmount:Bool {
                get {
                    return builderResult.hasAddrToAmount
                }
            }
            public var addrToAmount:Dictionary<String,Int64> {
                get {
                    return builderResult.addrToAmount
                }
                set (value) {
                    builderResult.hasAddrToAmount = true
                    builderResult.addrToAmount = value
                }
            }
            @discardableResult
            public func setAddrToAmount(_ value:Dictionary<String,Int64>) -> Lnrpc.SendManyRequest.Builder {
                self.addrToAmount = value
                return self
            }
            @discardableResult
            public func clearAddrToAmount() -> Lnrpc.SendManyRequest.Builder{
                builderResult.hasAddrToAmount = false
                builderResult.addrToAmount = Dictionary<String,Int64>()
                return self
            }
            //// The target number of blocks that this transaction should be confirmed by.
            public var targetConf:Int32 {
                get {
                    return builderResult.targetConf
                }
                set (value) {
                    builderResult.hasTargetConf = true
                    builderResult.targetConf = value
                }
            }
            public var hasTargetConf:Bool {
                get {
                    return builderResult.hasTargetConf
                }
            }
            @discardableResult
            public func setTargetConf(_ value:Int32) -> Lnrpc.SendManyRequest.Builder {
                self.targetConf = value
                return self
            }
            @discardableResult
            public func clearTargetConf() -> Lnrpc.SendManyRequest.Builder{
                builderResult.hasTargetConf = false
                builderResult.targetConf = nil
                return self
            }
            //// A manual fee rate set in sat/byte that should be used when crafting the transaction.
            public var satPerByte:Int64 {
                get {
                    return builderResult.satPerByte
                }
                set (value) {
                    builderResult.hasSatPerByte = true
                    builderResult.satPerByte = value
                }
            }
            public var hasSatPerByte:Bool {
                get {
                    return builderResult.hasSatPerByte
                }
            }
            @discardableResult
            public func setSatPerByte(_ value:Int64) -> Lnrpc.SendManyRequest.Builder {
                self.satPerByte = value
                return self
            }
            @discardableResult
            public func clearSatPerByte() -> Lnrpc.SendManyRequest.Builder{
                builderResult.hasSatPerByte = false
                builderResult.satPerByte = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.SendManyRequest.Builder {
                builderResult = Lnrpc.SendManyRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.SendManyRequest.Builder {
                return try Lnrpc.SendManyRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.SendManyRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.SendManyRequest {
                let returnMe:Lnrpc.SendManyRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.SendManyRequest) throws -> Lnrpc.SendManyRequest.Builder {
                if other == Lnrpc.SendManyRequest() {
                    return self
                }
                if other.hasAddrToAmount {
                    addrToAmount = other.addrToAmount
                }
                if other.hasTargetConf {
                    targetConf = other.targetConf
                }
                if other.hasSatPerByte {
                    satPerByte = other.satPerByte
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.SendManyRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendManyRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Lnrpc.SendManyRequest.AddrToAmountEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfAddrToAmount = subBuilder.buildPartial()
                        addrToAmount[buildOfAddrToAmount.key] = buildOfAddrToAmount.value

                    case 24:
                        targetConf = try codedInputStream.readInt32()

                    case 40:
                        satPerByte = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.SendManyRequest.Builder {
                let resultDecodedBuilder = Lnrpc.SendManyRequest.Builder()
                if let jsonValueAddrToAmount = jsonMap["AddrToAmount"] as? Dictionary<String, String> {
                    var mapAddrToAmount = Dictionary<String, Int64>()
                    for (keyAddrToAmount, valueAddrToAmount) in jsonValueAddrToAmount {
                        mapAddrToAmount[keyAddrToAmount] = Int64(valueAddrToAmount)!
                    }
                    resultDecodedBuilder.addrToAmount = mapAddrToAmount
                }
                if let jsonValueTargetConf = jsonMap["targetConf"] as? Int {
                    resultDecodedBuilder.targetConf = Int32(jsonValueTargetConf)
                } else if let jsonValueTargetConf = jsonMap["targetConf"] as? String {
                    resultDecodedBuilder.targetConf = Int32(jsonValueTargetConf)!
                }
                if let jsonValueSatPerByte = jsonMap["satPerByte"] as? String {
                    resultDecodedBuilder.satPerByte = Int64(jsonValueSatPerByte)!
                } else if let jsonValueSatPerByte = jsonMap["satPerByte"] as? Int {
                    resultDecodedBuilder.satPerByte = Int64(jsonValueSatPerByte)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.SendManyRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.SendManyRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SendManyResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.SendManyResponse.Builder

        public static func == (lhs: Lnrpc.SendManyResponse, rhs: Lnrpc.SendManyResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTxid == rhs.hasTxid) && (!lhs.hasTxid || lhs.txid == rhs.txid)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// The id of the transaction
        public fileprivate(set) var txid:String! = nil
        public fileprivate(set) var hasTxid:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTxid {
                try codedOutputStream.writeString(fieldNumber: 1, value:txid)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTxid {
                serialize_size += txid.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.SendManyResponse.Builder {
            return Lnrpc.SendManyResponse.classBuilder() as! Lnrpc.SendManyResponse.Builder
        }
        public func getBuilder() -> Lnrpc.SendManyResponse.Builder {
            return classBuilder() as! Lnrpc.SendManyResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.SendManyResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.SendManyResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.SendManyResponse.Builder {
            return try Lnrpc.SendManyResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.SendManyResponse) throws -> Lnrpc.SendManyResponse.Builder {
            return try Lnrpc.SendManyResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTxid {
                jsonMap["txid"] = txid
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.SendManyResponse {
            return try Lnrpc.SendManyResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.SendManyResponse {
            return try Lnrpc.SendManyResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTxid {
                output += "\(indent) txid: \(txid) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTxid {
                    hashCode = (hashCode &* 31) &+ txid.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.SendManyResponse"
        }
        override public func className() -> String {
            return "Lnrpc.SendManyResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.SendManyResponse = Lnrpc.SendManyResponse()
            public func getMessage() -> Lnrpc.SendManyResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The id of the transaction
            public var txid:String {
                get {
                    return builderResult.txid
                }
                set (value) {
                    builderResult.hasTxid = true
                    builderResult.txid = value
                }
            }
            public var hasTxid:Bool {
                get {
                    return builderResult.hasTxid
                }
            }
            @discardableResult
            public func setTxid(_ value:String) -> Lnrpc.SendManyResponse.Builder {
                self.txid = value
                return self
            }
            @discardableResult
            public func clearTxid() -> Lnrpc.SendManyResponse.Builder{
                builderResult.hasTxid = false
                builderResult.txid = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.SendManyResponse.Builder {
                builderResult = Lnrpc.SendManyResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.SendManyResponse.Builder {
                return try Lnrpc.SendManyResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.SendManyResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.SendManyResponse {
                let returnMe:Lnrpc.SendManyResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.SendManyResponse) throws -> Lnrpc.SendManyResponse.Builder {
                if other == Lnrpc.SendManyResponse() {
                    return self
                }
                if other.hasTxid {
                    txid = other.txid
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.SendManyResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendManyResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        txid = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.SendManyResponse.Builder {
                let resultDecodedBuilder = Lnrpc.SendManyResponse.Builder()
                if let jsonValueTxid = jsonMap["txid"] as? String {
                    resultDecodedBuilder.txid = jsonValueTxid
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.SendManyResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.SendManyResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SendCoinsRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.SendCoinsRequest.Builder

        public static func == (lhs: Lnrpc.SendCoinsRequest, rhs: Lnrpc.SendCoinsRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasAddr == rhs.hasAddr) && (!lhs.hasAddr || lhs.addr == rhs.addr)
            fieldCheck = fieldCheck && (lhs.hasAmount == rhs.hasAmount) && (!lhs.hasAmount || lhs.amount == rhs.amount)
            fieldCheck = fieldCheck && (lhs.hasTargetConf == rhs.hasTargetConf) && (!lhs.hasTargetConf || lhs.targetConf == rhs.targetConf)
            fieldCheck = fieldCheck && (lhs.hasSatPerByte == rhs.hasSatPerByte) && (!lhs.hasSatPerByte || lhs.satPerByte == rhs.satPerByte)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// The address to send coins to 
        public fileprivate(set) var addr:String! = nil
        public fileprivate(set) var hasAddr:Bool = false

        //// The amount in satoshis to send
        public fileprivate(set) var amount:Int64! = nil
        public fileprivate(set) var hasAmount:Bool = false

        //// The target number of blocks that this transaction should be confirmed by.
        public fileprivate(set) var targetConf:Int32! = nil
        public fileprivate(set) var hasTargetConf:Bool = false

        //// A manual fee rate set in sat/byte that should be used when crafting the transaction.
        public fileprivate(set) var satPerByte:Int64! = nil
        public fileprivate(set) var hasSatPerByte:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasAddr {
                try codedOutputStream.writeString(fieldNumber: 1, value:addr)
            }
            if hasAmount {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:amount)
            }
            if hasTargetConf {
                try codedOutputStream.writeInt32(fieldNumber: 3, value:targetConf)
            }
            if hasSatPerByte {
                try codedOutputStream.writeInt64(fieldNumber: 5, value:satPerByte)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasAddr {
                serialize_size += addr.computeStringSize(fieldNumber: 1)
            }
            if hasAmount {
                serialize_size += amount.computeInt64Size(fieldNumber: 2)
            }
            if hasTargetConf {
                serialize_size += targetConf.computeInt32Size(fieldNumber: 3)
            }
            if hasSatPerByte {
                serialize_size += satPerByte.computeInt64Size(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.SendCoinsRequest.Builder {
            return Lnrpc.SendCoinsRequest.classBuilder() as! Lnrpc.SendCoinsRequest.Builder
        }
        public func getBuilder() -> Lnrpc.SendCoinsRequest.Builder {
            return classBuilder() as! Lnrpc.SendCoinsRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.SendCoinsRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.SendCoinsRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.SendCoinsRequest.Builder {
            return try Lnrpc.SendCoinsRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.SendCoinsRequest) throws -> Lnrpc.SendCoinsRequest.Builder {
            return try Lnrpc.SendCoinsRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasAddr {
                jsonMap["addr"] = addr
            }
            if hasAmount {
                jsonMap["amount"] = "\(amount!)"
            }
            if hasTargetConf {
                jsonMap["targetConf"] = Int(targetConf)
            }
            if hasSatPerByte {
                jsonMap["satPerByte"] = "\(satPerByte!)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.SendCoinsRequest {
            return try Lnrpc.SendCoinsRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.SendCoinsRequest {
            return try Lnrpc.SendCoinsRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasAddr {
                output += "\(indent) addr: \(addr) \n"
            }
            if hasAmount {
                output += "\(indent) amount: \(amount) \n"
            }
            if hasTargetConf {
                output += "\(indent) targetConf: \(targetConf) \n"
            }
            if hasSatPerByte {
                output += "\(indent) satPerByte: \(satPerByte) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasAddr {
                    hashCode = (hashCode &* 31) &+ addr.hashValue
                }
                if hasAmount {
                    hashCode = (hashCode &* 31) &+ amount.hashValue
                }
                if hasTargetConf {
                    hashCode = (hashCode &* 31) &+ targetConf.hashValue
                }
                if hasSatPerByte {
                    hashCode = (hashCode &* 31) &+ satPerByte.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.SendCoinsRequest"
        }
        override public func className() -> String {
            return "Lnrpc.SendCoinsRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.SendCoinsRequest = Lnrpc.SendCoinsRequest()
            public func getMessage() -> Lnrpc.SendCoinsRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The address to send coins to 
            public var addr:String {
                get {
                    return builderResult.addr
                }
                set (value) {
                    builderResult.hasAddr = true
                    builderResult.addr = value
                }
            }
            public var hasAddr:Bool {
                get {
                    return builderResult.hasAddr
                }
            }
            @discardableResult
            public func setAddr(_ value:String) -> Lnrpc.SendCoinsRequest.Builder {
                self.addr = value
                return self
            }
            @discardableResult
            public func clearAddr() -> Lnrpc.SendCoinsRequest.Builder{
                builderResult.hasAddr = false
                builderResult.addr = nil
                return self
            }
            //// The amount in satoshis to send
            public var amount:Int64 {
                get {
                    return builderResult.amount
                }
                set (value) {
                    builderResult.hasAmount = true
                    builderResult.amount = value
                }
            }
            public var hasAmount:Bool {
                get {
                    return builderResult.hasAmount
                }
            }
            @discardableResult
            public func setAmount(_ value:Int64) -> Lnrpc.SendCoinsRequest.Builder {
                self.amount = value
                return self
            }
            @discardableResult
            public func clearAmount() -> Lnrpc.SendCoinsRequest.Builder{
                builderResult.hasAmount = false
                builderResult.amount = nil
                return self
            }
            //// The target number of blocks that this transaction should be confirmed by.
            public var targetConf:Int32 {
                get {
                    return builderResult.targetConf
                }
                set (value) {
                    builderResult.hasTargetConf = true
                    builderResult.targetConf = value
                }
            }
            public var hasTargetConf:Bool {
                get {
                    return builderResult.hasTargetConf
                }
            }
            @discardableResult
            public func setTargetConf(_ value:Int32) -> Lnrpc.SendCoinsRequest.Builder {
                self.targetConf = value
                return self
            }
            @discardableResult
            public func clearTargetConf() -> Lnrpc.SendCoinsRequest.Builder{
                builderResult.hasTargetConf = false
                builderResult.targetConf = nil
                return self
            }
            //// A manual fee rate set in sat/byte that should be used when crafting the transaction.
            public var satPerByte:Int64 {
                get {
                    return builderResult.satPerByte
                }
                set (value) {
                    builderResult.hasSatPerByte = true
                    builderResult.satPerByte = value
                }
            }
            public var hasSatPerByte:Bool {
                get {
                    return builderResult.hasSatPerByte
                }
            }
            @discardableResult
            public func setSatPerByte(_ value:Int64) -> Lnrpc.SendCoinsRequest.Builder {
                self.satPerByte = value
                return self
            }
            @discardableResult
            public func clearSatPerByte() -> Lnrpc.SendCoinsRequest.Builder{
                builderResult.hasSatPerByte = false
                builderResult.satPerByte = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.SendCoinsRequest.Builder {
                builderResult = Lnrpc.SendCoinsRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.SendCoinsRequest.Builder {
                return try Lnrpc.SendCoinsRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.SendCoinsRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.SendCoinsRequest {
                let returnMe:Lnrpc.SendCoinsRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.SendCoinsRequest) throws -> Lnrpc.SendCoinsRequest.Builder {
                if other == Lnrpc.SendCoinsRequest() {
                    return self
                }
                if other.hasAddr {
                    addr = other.addr
                }
                if other.hasAmount {
                    amount = other.amount
                }
                if other.hasTargetConf {
                    targetConf = other.targetConf
                }
                if other.hasSatPerByte {
                    satPerByte = other.satPerByte
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.SendCoinsRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendCoinsRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        addr = try codedInputStream.readString()

                    case 16:
                        amount = try codedInputStream.readInt64()

                    case 24:
                        targetConf = try codedInputStream.readInt32()

                    case 40:
                        satPerByte = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.SendCoinsRequest.Builder {
                let resultDecodedBuilder = Lnrpc.SendCoinsRequest.Builder()
                if let jsonValueAddr = jsonMap["addr"] as? String {
                    resultDecodedBuilder.addr = jsonValueAddr
                }
                if let jsonValueAmount = jsonMap["amount"] as? String {
                    resultDecodedBuilder.amount = Int64(jsonValueAmount)!
                } else if let jsonValueAmount = jsonMap["amount"] as? Int {
                    resultDecodedBuilder.amount = Int64(jsonValueAmount)
                }
                if let jsonValueTargetConf = jsonMap["targetConf"] as? Int {
                    resultDecodedBuilder.targetConf = Int32(jsonValueTargetConf)
                } else if let jsonValueTargetConf = jsonMap["targetConf"] as? String {
                    resultDecodedBuilder.targetConf = Int32(jsonValueTargetConf)!
                }
                if let jsonValueSatPerByte = jsonMap["satPerByte"] as? String {
                    resultDecodedBuilder.satPerByte = Int64(jsonValueSatPerByte)!
                } else if let jsonValueSatPerByte = jsonMap["satPerByte"] as? Int {
                    resultDecodedBuilder.satPerByte = Int64(jsonValueSatPerByte)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.SendCoinsRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.SendCoinsRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SendCoinsResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.SendCoinsResponse.Builder

        public static func == (lhs: Lnrpc.SendCoinsResponse, rhs: Lnrpc.SendCoinsResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTxid == rhs.hasTxid) && (!lhs.hasTxid || lhs.txid == rhs.txid)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// The transaction ID of the transaction
        public fileprivate(set) var txid:String! = nil
        public fileprivate(set) var hasTxid:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTxid {
                try codedOutputStream.writeString(fieldNumber: 1, value:txid)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTxid {
                serialize_size += txid.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.SendCoinsResponse.Builder {
            return Lnrpc.SendCoinsResponse.classBuilder() as! Lnrpc.SendCoinsResponse.Builder
        }
        public func getBuilder() -> Lnrpc.SendCoinsResponse.Builder {
            return classBuilder() as! Lnrpc.SendCoinsResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.SendCoinsResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.SendCoinsResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.SendCoinsResponse.Builder {
            return try Lnrpc.SendCoinsResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.SendCoinsResponse) throws -> Lnrpc.SendCoinsResponse.Builder {
            return try Lnrpc.SendCoinsResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTxid {
                jsonMap["txid"] = txid
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.SendCoinsResponse {
            return try Lnrpc.SendCoinsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.SendCoinsResponse {
            return try Lnrpc.SendCoinsResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTxid {
                output += "\(indent) txid: \(txid) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTxid {
                    hashCode = (hashCode &* 31) &+ txid.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.SendCoinsResponse"
        }
        override public func className() -> String {
            return "Lnrpc.SendCoinsResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.SendCoinsResponse = Lnrpc.SendCoinsResponse()
            public func getMessage() -> Lnrpc.SendCoinsResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The transaction ID of the transaction
            public var txid:String {
                get {
                    return builderResult.txid
                }
                set (value) {
                    builderResult.hasTxid = true
                    builderResult.txid = value
                }
            }
            public var hasTxid:Bool {
                get {
                    return builderResult.hasTxid
                }
            }
            @discardableResult
            public func setTxid(_ value:String) -> Lnrpc.SendCoinsResponse.Builder {
                self.txid = value
                return self
            }
            @discardableResult
            public func clearTxid() -> Lnrpc.SendCoinsResponse.Builder{
                builderResult.hasTxid = false
                builderResult.txid = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.SendCoinsResponse.Builder {
                builderResult = Lnrpc.SendCoinsResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.SendCoinsResponse.Builder {
                return try Lnrpc.SendCoinsResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.SendCoinsResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.SendCoinsResponse {
                let returnMe:Lnrpc.SendCoinsResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.SendCoinsResponse) throws -> Lnrpc.SendCoinsResponse.Builder {
                if other == Lnrpc.SendCoinsResponse() {
                    return self
                }
                if other.hasTxid {
                    txid = other.txid
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.SendCoinsResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendCoinsResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        txid = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.SendCoinsResponse.Builder {
                let resultDecodedBuilder = Lnrpc.SendCoinsResponse.Builder()
                if let jsonValueTxid = jsonMap["txid"] as? String {
                    resultDecodedBuilder.txid = jsonValueTxid
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.SendCoinsResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.SendCoinsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    ///* 
    ///`AddressType` has to be one of:
    ///- `p2wkh`: Pay to witness key hash (`WITNESS_PUBKEY_HASH` = 0)
    ///- `np2wkh`: Pay to nested witness key hash (`NESTED_PUBKEY_HASH` = 1)
    ///- `p2pkh`:  Pay to public key hash (`PUBKEY_HASH` = 2)
    final public class NewAddressRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.NewAddressRequest.Builder

        public static func == (lhs: Lnrpc.NewAddressRequest, rhs: Lnrpc.NewAddressRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



            //Enum type declaration start 

            public enum AddressType:Int32, GeneratedEnum {
                case witnessPubkeyHash = 0
                case nestedPubkeyHash = 1
                public func toString() -> String {
                    switch self {
                    case .witnessPubkeyHash: return "WITNESS_PUBKEY_HASH"
                    case .nestedPubkeyHash: return "NESTED_PUBKEY_HASH"
                    }
                }
                public static func fromString(_ str:String) throws -> Lnrpc.NewAddressRequest.AddressType {
                    switch str {
                    case "WITNESS_PUBKEY_HASH":    return .witnessPubkeyHash
                    case "NESTED_PUBKEY_HASH":    return .nestedPubkeyHash
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .witnessPubkeyHash: return ".witnessPubkeyHash"
                    case .nestedPubkeyHash: return ".nestedPubkeyHash"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:AddressType, rhs:AddressType) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        public fileprivate(set) var type:Lnrpc.NewAddressRequest.AddressType = Lnrpc.NewAddressRequest.AddressType.witnessPubkeyHash
        public fileprivate(set) var hasType:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasType {
                try codedOutputStream.writeEnum(fieldNumber: 1, value:type.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if (hasType) {
                serialize_size += type.rawValue.computeEnumSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.NewAddressRequest.Builder {
            return Lnrpc.NewAddressRequest.classBuilder() as! Lnrpc.NewAddressRequest.Builder
        }
        public func getBuilder() -> Lnrpc.NewAddressRequest.Builder {
            return classBuilder() as! Lnrpc.NewAddressRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.NewAddressRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.NewAddressRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.NewAddressRequest.Builder {
            return try Lnrpc.NewAddressRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.NewAddressRequest) throws -> Lnrpc.NewAddressRequest.Builder {
            return try Lnrpc.NewAddressRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasType {
                jsonMap["type"] = type.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.NewAddressRequest {
            return try Lnrpc.NewAddressRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.NewAddressRequest {
            return try Lnrpc.NewAddressRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if (hasType) {
                output += "\(indent) type: \(type.description)\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasType {
                     hashCode = (hashCode &* 31) &+ type.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.NewAddressRequest"
        }
        override public func className() -> String {
            return "Lnrpc.NewAddressRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.NewAddressRequest = Lnrpc.NewAddressRequest()
            public func getMessage() -> Lnrpc.NewAddressRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The address type
                public var type:Lnrpc.NewAddressRequest.AddressType {
                    get {
                        return builderResult.type
                    }
                    set (value) {
                        builderResult.hasType = true
                        builderResult.type = value
                    }
                }
                public var hasType:Bool{
                    get {
                        return builderResult.hasType
                    }
                }
            @discardableResult
                public func setType(_ value:Lnrpc.NewAddressRequest.AddressType) -> Lnrpc.NewAddressRequest.Builder {
                  self.type = value
                  return self
                }
            @discardableResult
                public func clearType() -> Lnrpc.NewAddressRequest.Builder {
                   builderResult.hasType = false
                   builderResult.type = .witnessPubkeyHash
                   return self
                }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.NewAddressRequest.Builder {
                builderResult = Lnrpc.NewAddressRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.NewAddressRequest.Builder {
                return try Lnrpc.NewAddressRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.NewAddressRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.NewAddressRequest {
                let returnMe:Lnrpc.NewAddressRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.NewAddressRequest) throws -> Lnrpc.NewAddressRequest.Builder {
                if other == Lnrpc.NewAddressRequest() {
                    return self
                }
                if other.hasType {
                    type = other.type
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.NewAddressRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NewAddressRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        let valueInttype = try codedInputStream.readEnum()
                        if let enumstype = Lnrpc.NewAddressRequest.AddressType(rawValue:valueInttype){
                            type = enumstype
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueInttype))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.NewAddressRequest.Builder {
                let resultDecodedBuilder = Lnrpc.NewAddressRequest.Builder()
                if let jsonValueType = jsonMap["type"] as? String {
                    resultDecodedBuilder.type = try Lnrpc.NewAddressRequest.AddressType.fromString(jsonValueType)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.NewAddressRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.NewAddressRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class NewWitnessAddressRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.NewWitnessAddressRequest.Builder

        public static func == (lhs: Lnrpc.NewWitnessAddressRequest, rhs: Lnrpc.NewWitnessAddressRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.NewWitnessAddressRequest.Builder {
            return Lnrpc.NewWitnessAddressRequest.classBuilder() as! Lnrpc.NewWitnessAddressRequest.Builder
        }
        public func getBuilder() -> Lnrpc.NewWitnessAddressRequest.Builder {
            return classBuilder() as! Lnrpc.NewWitnessAddressRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.NewWitnessAddressRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.NewWitnessAddressRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.NewWitnessAddressRequest.Builder {
            return try Lnrpc.NewWitnessAddressRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.NewWitnessAddressRequest) throws -> Lnrpc.NewWitnessAddressRequest.Builder {
            return try Lnrpc.NewWitnessAddressRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.NewWitnessAddressRequest {
            return try Lnrpc.NewWitnessAddressRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.NewWitnessAddressRequest {
            return try Lnrpc.NewWitnessAddressRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.NewWitnessAddressRequest"
        }
        override public func className() -> String {
            return "Lnrpc.NewWitnessAddressRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.NewWitnessAddressRequest = Lnrpc.NewWitnessAddressRequest()
            public func getMessage() -> Lnrpc.NewWitnessAddressRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.NewWitnessAddressRequest.Builder {
                builderResult = Lnrpc.NewWitnessAddressRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.NewWitnessAddressRequest.Builder {
                return try Lnrpc.NewWitnessAddressRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.NewWitnessAddressRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.NewWitnessAddressRequest {
                let returnMe:Lnrpc.NewWitnessAddressRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.NewWitnessAddressRequest) throws -> Lnrpc.NewWitnessAddressRequest.Builder {
                if other == Lnrpc.NewWitnessAddressRequest() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.NewWitnessAddressRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NewWitnessAddressRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.NewWitnessAddressRequest.Builder {
                let resultDecodedBuilder = Lnrpc.NewWitnessAddressRequest.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.NewWitnessAddressRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.NewWitnessAddressRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class NewAddressResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.NewAddressResponse.Builder

        public static func == (lhs: Lnrpc.NewAddressResponse, rhs: Lnrpc.NewAddressResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasAddress == rhs.hasAddress) && (!lhs.hasAddress || lhs.address == rhs.address)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// The newly generated wallet address
        public fileprivate(set) var address:String! = nil
        public fileprivate(set) var hasAddress:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasAddress {
                try codedOutputStream.writeString(fieldNumber: 1, value:address)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasAddress {
                serialize_size += address.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.NewAddressResponse.Builder {
            return Lnrpc.NewAddressResponse.classBuilder() as! Lnrpc.NewAddressResponse.Builder
        }
        public func getBuilder() -> Lnrpc.NewAddressResponse.Builder {
            return classBuilder() as! Lnrpc.NewAddressResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.NewAddressResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.NewAddressResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.NewAddressResponse.Builder {
            return try Lnrpc.NewAddressResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.NewAddressResponse) throws -> Lnrpc.NewAddressResponse.Builder {
            return try Lnrpc.NewAddressResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasAddress {
                jsonMap["address"] = address
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.NewAddressResponse {
            return try Lnrpc.NewAddressResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.NewAddressResponse {
            return try Lnrpc.NewAddressResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasAddress {
                output += "\(indent) address: \(address) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasAddress {
                    hashCode = (hashCode &* 31) &+ address.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.NewAddressResponse"
        }
        override public func className() -> String {
            return "Lnrpc.NewAddressResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.NewAddressResponse = Lnrpc.NewAddressResponse()
            public func getMessage() -> Lnrpc.NewAddressResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The newly generated wallet address
            public var address:String {
                get {
                    return builderResult.address
                }
                set (value) {
                    builderResult.hasAddress = true
                    builderResult.address = value
                }
            }
            public var hasAddress:Bool {
                get {
                    return builderResult.hasAddress
                }
            }
            @discardableResult
            public func setAddress(_ value:String) -> Lnrpc.NewAddressResponse.Builder {
                self.address = value
                return self
            }
            @discardableResult
            public func clearAddress() -> Lnrpc.NewAddressResponse.Builder{
                builderResult.hasAddress = false
                builderResult.address = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.NewAddressResponse.Builder {
                builderResult = Lnrpc.NewAddressResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.NewAddressResponse.Builder {
                return try Lnrpc.NewAddressResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.NewAddressResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.NewAddressResponse {
                let returnMe:Lnrpc.NewAddressResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.NewAddressResponse) throws -> Lnrpc.NewAddressResponse.Builder {
                if other == Lnrpc.NewAddressResponse() {
                    return self
                }
                if other.hasAddress {
                    address = other.address
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.NewAddressResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NewAddressResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        address = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.NewAddressResponse.Builder {
                let resultDecodedBuilder = Lnrpc.NewAddressResponse.Builder()
                if let jsonValueAddress = jsonMap["address"] as? String {
                    resultDecodedBuilder.address = jsonValueAddress
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.NewAddressResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.NewAddressResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SignMessageRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.SignMessageRequest.Builder

        public static func == (lhs: Lnrpc.SignMessageRequest, rhs: Lnrpc.SignMessageRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasMsg == rhs.hasMsg) && (!lhs.hasMsg || lhs.msg == rhs.msg)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// The message to be signed
        public fileprivate(set) var msg:Data! = nil
        public fileprivate(set) var hasMsg:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasMsg {
                try codedOutputStream.writeData(fieldNumber: 1, value:msg)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasMsg {
                serialize_size += msg.computeDataSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.SignMessageRequest.Builder {
            return Lnrpc.SignMessageRequest.classBuilder() as! Lnrpc.SignMessageRequest.Builder
        }
        public func getBuilder() -> Lnrpc.SignMessageRequest.Builder {
            return classBuilder() as! Lnrpc.SignMessageRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.SignMessageRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.SignMessageRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.SignMessageRequest.Builder {
            return try Lnrpc.SignMessageRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.SignMessageRequest) throws -> Lnrpc.SignMessageRequest.Builder {
            return try Lnrpc.SignMessageRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasMsg {
                jsonMap["msg"] = msg.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.SignMessageRequest {
            return try Lnrpc.SignMessageRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.SignMessageRequest {
            return try Lnrpc.SignMessageRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasMsg {
                output += "\(indent) msg: \(msg) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasMsg {
                    hashCode = (hashCode &* 31) &+ msg.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.SignMessageRequest"
        }
        override public func className() -> String {
            return "Lnrpc.SignMessageRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.SignMessageRequest = Lnrpc.SignMessageRequest()
            public func getMessage() -> Lnrpc.SignMessageRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The message to be signed
            public var msg:Data {
                get {
                    return builderResult.msg
                }
                set (value) {
                    builderResult.hasMsg = true
                    builderResult.msg = value
                }
            }
            public var hasMsg:Bool {
                get {
                    return builderResult.hasMsg
                }
            }
            @discardableResult
            public func setMsg(_ value:Data) -> Lnrpc.SignMessageRequest.Builder {
                self.msg = value
                return self
            }
            @discardableResult
            public func clearMsg() -> Lnrpc.SignMessageRequest.Builder{
                builderResult.hasMsg = false
                builderResult.msg = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.SignMessageRequest.Builder {
                builderResult = Lnrpc.SignMessageRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.SignMessageRequest.Builder {
                return try Lnrpc.SignMessageRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.SignMessageRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.SignMessageRequest {
                let returnMe:Lnrpc.SignMessageRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.SignMessageRequest) throws -> Lnrpc.SignMessageRequest.Builder {
                if other == Lnrpc.SignMessageRequest() {
                    return self
                }
                if other.hasMsg {
                    msg = other.msg
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.SignMessageRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SignMessageRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        msg = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.SignMessageRequest.Builder {
                let resultDecodedBuilder = Lnrpc.SignMessageRequest.Builder()
                if let jsonValueMsg = jsonMap["msg"] as? String {
                    resultDecodedBuilder.msg = Data(base64Encoded:jsonValueMsg, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.SignMessageRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.SignMessageRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class SignMessageResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.SignMessageResponse.Builder

        public static func == (lhs: Lnrpc.SignMessageResponse, rhs: Lnrpc.SignMessageResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasSignature == rhs.hasSignature) && (!lhs.hasSignature || lhs.signature == rhs.signature)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// The signature for the given message
        public fileprivate(set) var signature:String! = nil
        public fileprivate(set) var hasSignature:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasSignature {
                try codedOutputStream.writeString(fieldNumber: 1, value:signature)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasSignature {
                serialize_size += signature.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.SignMessageResponse.Builder {
            return Lnrpc.SignMessageResponse.classBuilder() as! Lnrpc.SignMessageResponse.Builder
        }
        public func getBuilder() -> Lnrpc.SignMessageResponse.Builder {
            return classBuilder() as! Lnrpc.SignMessageResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.SignMessageResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.SignMessageResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.SignMessageResponse.Builder {
            return try Lnrpc.SignMessageResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.SignMessageResponse) throws -> Lnrpc.SignMessageResponse.Builder {
            return try Lnrpc.SignMessageResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasSignature {
                jsonMap["signature"] = signature
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.SignMessageResponse {
            return try Lnrpc.SignMessageResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.SignMessageResponse {
            return try Lnrpc.SignMessageResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasSignature {
                output += "\(indent) signature: \(signature) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasSignature {
                    hashCode = (hashCode &* 31) &+ signature.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.SignMessageResponse"
        }
        override public func className() -> String {
            return "Lnrpc.SignMessageResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.SignMessageResponse = Lnrpc.SignMessageResponse()
            public func getMessage() -> Lnrpc.SignMessageResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The signature for the given message
            public var signature:String {
                get {
                    return builderResult.signature
                }
                set (value) {
                    builderResult.hasSignature = true
                    builderResult.signature = value
                }
            }
            public var hasSignature:Bool {
                get {
                    return builderResult.hasSignature
                }
            }
            @discardableResult
            public func setSignature(_ value:String) -> Lnrpc.SignMessageResponse.Builder {
                self.signature = value
                return self
            }
            @discardableResult
            public func clearSignature() -> Lnrpc.SignMessageResponse.Builder{
                builderResult.hasSignature = false
                builderResult.signature = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.SignMessageResponse.Builder {
                builderResult = Lnrpc.SignMessageResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.SignMessageResponse.Builder {
                return try Lnrpc.SignMessageResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.SignMessageResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.SignMessageResponse {
                let returnMe:Lnrpc.SignMessageResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.SignMessageResponse) throws -> Lnrpc.SignMessageResponse.Builder {
                if other == Lnrpc.SignMessageResponse() {
                    return self
                }
                if other.hasSignature {
                    signature = other.signature
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.SignMessageResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SignMessageResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        signature = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.SignMessageResponse.Builder {
                let resultDecodedBuilder = Lnrpc.SignMessageResponse.Builder()
                if let jsonValueSignature = jsonMap["signature"] as? String {
                    resultDecodedBuilder.signature = jsonValueSignature
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.SignMessageResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.SignMessageResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class VerifyMessageRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.VerifyMessageRequest.Builder

        public static func == (lhs: Lnrpc.VerifyMessageRequest, rhs: Lnrpc.VerifyMessageRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasMsg == rhs.hasMsg) && (!lhs.hasMsg || lhs.msg == rhs.msg)
            fieldCheck = fieldCheck && (lhs.hasSignature == rhs.hasSignature) && (!lhs.hasSignature || lhs.signature == rhs.signature)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// The message over which the signature is to be verified
        public fileprivate(set) var msg:Data! = nil
        public fileprivate(set) var hasMsg:Bool = false

        //// The signature to be verified over the given message
        public fileprivate(set) var signature:String! = nil
        public fileprivate(set) var hasSignature:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasMsg {
                try codedOutputStream.writeData(fieldNumber: 1, value:msg)
            }
            if hasSignature {
                try codedOutputStream.writeString(fieldNumber: 2, value:signature)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasMsg {
                serialize_size += msg.computeDataSize(fieldNumber: 1)
            }
            if hasSignature {
                serialize_size += signature.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.VerifyMessageRequest.Builder {
            return Lnrpc.VerifyMessageRequest.classBuilder() as! Lnrpc.VerifyMessageRequest.Builder
        }
        public func getBuilder() -> Lnrpc.VerifyMessageRequest.Builder {
            return classBuilder() as! Lnrpc.VerifyMessageRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.VerifyMessageRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.VerifyMessageRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.VerifyMessageRequest.Builder {
            return try Lnrpc.VerifyMessageRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.VerifyMessageRequest) throws -> Lnrpc.VerifyMessageRequest.Builder {
            return try Lnrpc.VerifyMessageRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasMsg {
                jsonMap["msg"] = msg.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasSignature {
                jsonMap["signature"] = signature
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.VerifyMessageRequest {
            return try Lnrpc.VerifyMessageRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.VerifyMessageRequest {
            return try Lnrpc.VerifyMessageRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasMsg {
                output += "\(indent) msg: \(msg) \n"
            }
            if hasSignature {
                output += "\(indent) signature: \(signature) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasMsg {
                    hashCode = (hashCode &* 31) &+ msg.hashValue
                }
                if hasSignature {
                    hashCode = (hashCode &* 31) &+ signature.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.VerifyMessageRequest"
        }
        override public func className() -> String {
            return "Lnrpc.VerifyMessageRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.VerifyMessageRequest = Lnrpc.VerifyMessageRequest()
            public func getMessage() -> Lnrpc.VerifyMessageRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The message over which the signature is to be verified
            public var msg:Data {
                get {
                    return builderResult.msg
                }
                set (value) {
                    builderResult.hasMsg = true
                    builderResult.msg = value
                }
            }
            public var hasMsg:Bool {
                get {
                    return builderResult.hasMsg
                }
            }
            @discardableResult
            public func setMsg(_ value:Data) -> Lnrpc.VerifyMessageRequest.Builder {
                self.msg = value
                return self
            }
            @discardableResult
            public func clearMsg() -> Lnrpc.VerifyMessageRequest.Builder{
                builderResult.hasMsg = false
                builderResult.msg = nil
                return self
            }
            //// The signature to be verified over the given message
            public var signature:String {
                get {
                    return builderResult.signature
                }
                set (value) {
                    builderResult.hasSignature = true
                    builderResult.signature = value
                }
            }
            public var hasSignature:Bool {
                get {
                    return builderResult.hasSignature
                }
            }
            @discardableResult
            public func setSignature(_ value:String) -> Lnrpc.VerifyMessageRequest.Builder {
                self.signature = value
                return self
            }
            @discardableResult
            public func clearSignature() -> Lnrpc.VerifyMessageRequest.Builder{
                builderResult.hasSignature = false
                builderResult.signature = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.VerifyMessageRequest.Builder {
                builderResult = Lnrpc.VerifyMessageRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.VerifyMessageRequest.Builder {
                return try Lnrpc.VerifyMessageRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.VerifyMessageRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.VerifyMessageRequest {
                let returnMe:Lnrpc.VerifyMessageRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.VerifyMessageRequest) throws -> Lnrpc.VerifyMessageRequest.Builder {
                if other == Lnrpc.VerifyMessageRequest() {
                    return self
                }
                if other.hasMsg {
                    msg = other.msg
                }
                if other.hasSignature {
                    signature = other.signature
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.VerifyMessageRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.VerifyMessageRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        msg = try codedInputStream.readData()

                    case 18:
                        signature = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.VerifyMessageRequest.Builder {
                let resultDecodedBuilder = Lnrpc.VerifyMessageRequest.Builder()
                if let jsonValueMsg = jsonMap["msg"] as? String {
                    resultDecodedBuilder.msg = Data(base64Encoded:jsonValueMsg, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueSignature = jsonMap["signature"] as? String {
                    resultDecodedBuilder.signature = jsonValueSignature
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.VerifyMessageRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.VerifyMessageRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class VerifyMessageResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.VerifyMessageResponse.Builder

        public static func == (lhs: Lnrpc.VerifyMessageResponse, rhs: Lnrpc.VerifyMessageResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasValid == rhs.hasValid) && (!lhs.hasValid || lhs.valid == rhs.valid)
            fieldCheck = fieldCheck && (lhs.hasPubkey == rhs.hasPubkey) && (!lhs.hasPubkey || lhs.pubkey == rhs.pubkey)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// Whether the signature was valid over the given message
        public fileprivate(set) var valid:Bool! = nil
        public fileprivate(set) var hasValid:Bool = false

        //// The pubkey recovered from the signature
        public fileprivate(set) var pubkey:String! = nil
        public fileprivate(set) var hasPubkey:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasValid {
                try codedOutputStream.writeBool(fieldNumber: 1, value:valid)
            }
            if hasPubkey {
                try codedOutputStream.writeString(fieldNumber: 2, value:pubkey)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasValid {
                serialize_size += valid.computeBoolSize(fieldNumber: 1)
            }
            if hasPubkey {
                serialize_size += pubkey.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.VerifyMessageResponse.Builder {
            return Lnrpc.VerifyMessageResponse.classBuilder() as! Lnrpc.VerifyMessageResponse.Builder
        }
        public func getBuilder() -> Lnrpc.VerifyMessageResponse.Builder {
            return classBuilder() as! Lnrpc.VerifyMessageResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.VerifyMessageResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.VerifyMessageResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.VerifyMessageResponse.Builder {
            return try Lnrpc.VerifyMessageResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.VerifyMessageResponse) throws -> Lnrpc.VerifyMessageResponse.Builder {
            return try Lnrpc.VerifyMessageResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasValid {
                jsonMap["valid"] = valid
            }
            if hasPubkey {
                jsonMap["pubkey"] = pubkey
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.VerifyMessageResponse {
            return try Lnrpc.VerifyMessageResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.VerifyMessageResponse {
            return try Lnrpc.VerifyMessageResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasValid {
                output += "\(indent) valid: \(valid) \n"
            }
            if hasPubkey {
                output += "\(indent) pubkey: \(pubkey) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasValid {
                    hashCode = (hashCode &* 31) &+ valid.hashValue
                }
                if hasPubkey {
                    hashCode = (hashCode &* 31) &+ pubkey.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.VerifyMessageResponse"
        }
        override public func className() -> String {
            return "Lnrpc.VerifyMessageResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.VerifyMessageResponse = Lnrpc.VerifyMessageResponse()
            public func getMessage() -> Lnrpc.VerifyMessageResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// Whether the signature was valid over the given message
            public var valid:Bool {
                get {
                    return builderResult.valid
                }
                set (value) {
                    builderResult.hasValid = true
                    builderResult.valid = value
                }
            }
            public var hasValid:Bool {
                get {
                    return builderResult.hasValid
                }
            }
            @discardableResult
            public func setValid(_ value:Bool) -> Lnrpc.VerifyMessageResponse.Builder {
                self.valid = value
                return self
            }
            @discardableResult
            public func clearValid() -> Lnrpc.VerifyMessageResponse.Builder{
                builderResult.hasValid = false
                builderResult.valid = nil
                return self
            }
            //// The pubkey recovered from the signature
            public var pubkey:String {
                get {
                    return builderResult.pubkey
                }
                set (value) {
                    builderResult.hasPubkey = true
                    builderResult.pubkey = value
                }
            }
            public var hasPubkey:Bool {
                get {
                    return builderResult.hasPubkey
                }
            }
            @discardableResult
            public func setPubkey(_ value:String) -> Lnrpc.VerifyMessageResponse.Builder {
                self.pubkey = value
                return self
            }
            @discardableResult
            public func clearPubkey() -> Lnrpc.VerifyMessageResponse.Builder{
                builderResult.hasPubkey = false
                builderResult.pubkey = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.VerifyMessageResponse.Builder {
                builderResult = Lnrpc.VerifyMessageResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.VerifyMessageResponse.Builder {
                return try Lnrpc.VerifyMessageResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.VerifyMessageResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.VerifyMessageResponse {
                let returnMe:Lnrpc.VerifyMessageResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.VerifyMessageResponse) throws -> Lnrpc.VerifyMessageResponse.Builder {
                if other == Lnrpc.VerifyMessageResponse() {
                    return self
                }
                if other.hasValid {
                    valid = other.valid
                }
                if other.hasPubkey {
                    pubkey = other.pubkey
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.VerifyMessageResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.VerifyMessageResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        valid = try codedInputStream.readBool()

                    case 18:
                        pubkey = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.VerifyMessageResponse.Builder {
                let resultDecodedBuilder = Lnrpc.VerifyMessageResponse.Builder()
                if let jsonValueValid = jsonMap["valid"] as? Bool {
                    resultDecodedBuilder.valid = jsonValueValid
                }
                if let jsonValuePubkey = jsonMap["pubkey"] as? String {
                    resultDecodedBuilder.pubkey = jsonValuePubkey
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.VerifyMessageResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.VerifyMessageResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ConnectPeerRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ConnectPeerRequest.Builder

        public static func == (lhs: Lnrpc.ConnectPeerRequest, rhs: Lnrpc.ConnectPeerRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasAddr == rhs.hasAddr) && (!lhs.hasAddr || lhs.addr == rhs.addr)
            fieldCheck = fieldCheck && (lhs.hasPerm == rhs.hasPerm) && (!lhs.hasPerm || lhs.perm == rhs.perm)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var addr:Lnrpc.LightningAddress!
        public fileprivate(set) var hasAddr:Bool = false
        ///* If set, the daemon will attempt to persistently connect to the target
        /// peer.  Otherwise, the call will be synchronous. 
        public fileprivate(set) var perm:Bool! = nil
        public fileprivate(set) var hasPerm:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasAddr {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:addr)
            }
            if hasPerm {
                try codedOutputStream.writeBool(fieldNumber: 2, value:perm)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasAddr {
                if let varSizeaddr = addr?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeaddr
                }
            }
            if hasPerm {
                serialize_size += perm.computeBoolSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ConnectPeerRequest.Builder {
            return Lnrpc.ConnectPeerRequest.classBuilder() as! Lnrpc.ConnectPeerRequest.Builder
        }
        public func getBuilder() -> Lnrpc.ConnectPeerRequest.Builder {
            return classBuilder() as! Lnrpc.ConnectPeerRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ConnectPeerRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ConnectPeerRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ConnectPeerRequest.Builder {
            return try Lnrpc.ConnectPeerRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ConnectPeerRequest) throws -> Lnrpc.ConnectPeerRequest.Builder {
            return try Lnrpc.ConnectPeerRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasAddr {
                jsonMap["addr"] = try addr.encode()
            }
            if hasPerm {
                jsonMap["perm"] = perm
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ConnectPeerRequest {
            return try Lnrpc.ConnectPeerRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ConnectPeerRequest {
            return try Lnrpc.ConnectPeerRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasAddr {
                output += "\(indent) addr {\n"
                if let outDescAddr = addr {
                    output += try outDescAddr.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasPerm {
                output += "\(indent) perm: \(perm) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasAddr {
                    if let hashValueaddr = addr?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueaddr
                    }
                }
                if hasPerm {
                    hashCode = (hashCode &* 31) &+ perm.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ConnectPeerRequest"
        }
        override public func className() -> String {
            return "Lnrpc.ConnectPeerRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ConnectPeerRequest = Lnrpc.ConnectPeerRequest()
            public func getMessage() -> Lnrpc.ConnectPeerRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// Lightning address of the peer, in the format `<pubkey>@host`
            public var addr:Lnrpc.LightningAddress! {
                get {
                    if addrBuilder_ != nil {
                        builderResult.addr = addrBuilder_.getMessage()
                    }
                    return builderResult.addr
                }
                set (value) {
                    builderResult.hasAddr = value != nil
                    builderResult.addr = value
                }
            }
            public var hasAddr:Bool {
                get {
                    return builderResult.hasAddr
                }
            }
            fileprivate var addrBuilder_:Lnrpc.LightningAddress.Builder! {
                didSet {
                    builderResult.hasAddr = true
                }
            }
            public func getAddrBuilder() -> Lnrpc.LightningAddress.Builder {
                if addrBuilder_ == nil {
                    addrBuilder_ = Lnrpc.LightningAddress.Builder()
                    builderResult.addr = addrBuilder_.getMessage()
                    if addr != nil {
                        try! addrBuilder_.mergeFrom(other: addr)
                    }
                }
                return addrBuilder_
            }
            @discardableResult
            public func setAddr(_ value:Lnrpc.LightningAddress!) -> Lnrpc.ConnectPeerRequest.Builder {
                self.addr = value
                return self
            }
            @discardableResult
            public func mergeAddr(value:Lnrpc.LightningAddress) throws -> Lnrpc.ConnectPeerRequest.Builder {
                if builderResult.hasAddr {
                    builderResult.addr = try Lnrpc.LightningAddress.builderWithPrototype(prototype:builderResult.addr).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.addr = value
                }
                builderResult.hasAddr = true
                return self
            }
            @discardableResult
            public func clearAddr() -> Lnrpc.ConnectPeerRequest.Builder {
                addrBuilder_ = nil
                builderResult.hasAddr = false
                builderResult.addr = nil
                return self
            }
            ///* If set, the daemon will attempt to persistently connect to the target
            /// peer.  Otherwise, the call will be synchronous. 
            public var perm:Bool {
                get {
                    return builderResult.perm
                }
                set (value) {
                    builderResult.hasPerm = true
                    builderResult.perm = value
                }
            }
            public var hasPerm:Bool {
                get {
                    return builderResult.hasPerm
                }
            }
            @discardableResult
            public func setPerm(_ value:Bool) -> Lnrpc.ConnectPeerRequest.Builder {
                self.perm = value
                return self
            }
            @discardableResult
            public func clearPerm() -> Lnrpc.ConnectPeerRequest.Builder{
                builderResult.hasPerm = false
                builderResult.perm = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ConnectPeerRequest.Builder {
                builderResult = Lnrpc.ConnectPeerRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.ConnectPeerRequest.Builder {
                return try Lnrpc.ConnectPeerRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ConnectPeerRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ConnectPeerRequest {
                let returnMe:Lnrpc.ConnectPeerRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ConnectPeerRequest) throws -> Lnrpc.ConnectPeerRequest.Builder {
                if other == Lnrpc.ConnectPeerRequest() {
                    return self
                }
                if (other.hasAddr) {
                    try mergeAddr(value: other.addr)
                }
                if other.hasPerm {
                    perm = other.perm
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ConnectPeerRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ConnectPeerRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Lnrpc.LightningAddress.Builder = Lnrpc.LightningAddress.Builder()
                        if hasAddr {
                            try subBuilder.mergeFrom(other: addr)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        addr = subBuilder.buildPartial()

                    case 16:
                        perm = try codedInputStream.readBool()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ConnectPeerRequest.Builder {
                let resultDecodedBuilder = Lnrpc.ConnectPeerRequest.Builder()
                if let jsonValueAddr = jsonMap["addr"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.addr = try Lnrpc.LightningAddress.Builder.decodeToBuilder(jsonMap:jsonValueAddr).build()

                }
                if let jsonValuePerm = jsonMap["perm"] as? Bool {
                    resultDecodedBuilder.perm = jsonValuePerm
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ConnectPeerRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ConnectPeerRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ConnectPeerResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ConnectPeerResponse.Builder

        public static func == (lhs: Lnrpc.ConnectPeerResponse, rhs: Lnrpc.ConnectPeerResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ConnectPeerResponse.Builder {
            return Lnrpc.ConnectPeerResponse.classBuilder() as! Lnrpc.ConnectPeerResponse.Builder
        }
        public func getBuilder() -> Lnrpc.ConnectPeerResponse.Builder {
            return classBuilder() as! Lnrpc.ConnectPeerResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ConnectPeerResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ConnectPeerResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ConnectPeerResponse.Builder {
            return try Lnrpc.ConnectPeerResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ConnectPeerResponse) throws -> Lnrpc.ConnectPeerResponse.Builder {
            return try Lnrpc.ConnectPeerResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ConnectPeerResponse {
            return try Lnrpc.ConnectPeerResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ConnectPeerResponse {
            return try Lnrpc.ConnectPeerResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ConnectPeerResponse"
        }
        override public func className() -> String {
            return "Lnrpc.ConnectPeerResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ConnectPeerResponse = Lnrpc.ConnectPeerResponse()
            public func getMessage() -> Lnrpc.ConnectPeerResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ConnectPeerResponse.Builder {
                builderResult = Lnrpc.ConnectPeerResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.ConnectPeerResponse.Builder {
                return try Lnrpc.ConnectPeerResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ConnectPeerResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ConnectPeerResponse {
                let returnMe:Lnrpc.ConnectPeerResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ConnectPeerResponse) throws -> Lnrpc.ConnectPeerResponse.Builder {
                if other == Lnrpc.ConnectPeerResponse() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ConnectPeerResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ConnectPeerResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ConnectPeerResponse.Builder {
                let resultDecodedBuilder = Lnrpc.ConnectPeerResponse.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ConnectPeerResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ConnectPeerResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class DisconnectPeerRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.DisconnectPeerRequest.Builder

        public static func == (lhs: Lnrpc.DisconnectPeerRequest, rhs: Lnrpc.DisconnectPeerRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasPubKey == rhs.hasPubKey) && (!lhs.hasPubKey || lhs.pubKey == rhs.pubKey)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// The pubkey of the node to disconnect from
        public fileprivate(set) var pubKey:String! = nil
        public fileprivate(set) var hasPubKey:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasPubKey {
                try codedOutputStream.writeString(fieldNumber: 1, value:pubKey)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasPubKey {
                serialize_size += pubKey.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.DisconnectPeerRequest.Builder {
            return Lnrpc.DisconnectPeerRequest.classBuilder() as! Lnrpc.DisconnectPeerRequest.Builder
        }
        public func getBuilder() -> Lnrpc.DisconnectPeerRequest.Builder {
            return classBuilder() as! Lnrpc.DisconnectPeerRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.DisconnectPeerRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.DisconnectPeerRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.DisconnectPeerRequest.Builder {
            return try Lnrpc.DisconnectPeerRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.DisconnectPeerRequest) throws -> Lnrpc.DisconnectPeerRequest.Builder {
            return try Lnrpc.DisconnectPeerRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasPubKey {
                jsonMap["pub_key"] = pubKey
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.DisconnectPeerRequest {
            return try Lnrpc.DisconnectPeerRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.DisconnectPeerRequest {
            return try Lnrpc.DisconnectPeerRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasPubKey {
                output += "\(indent) pubKey: \(pubKey) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasPubKey {
                    hashCode = (hashCode &* 31) &+ pubKey.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.DisconnectPeerRequest"
        }
        override public func className() -> String {
            return "Lnrpc.DisconnectPeerRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.DisconnectPeerRequest = Lnrpc.DisconnectPeerRequest()
            public func getMessage() -> Lnrpc.DisconnectPeerRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The pubkey of the node to disconnect from
            public var pubKey:String {
                get {
                    return builderResult.pubKey
                }
                set (value) {
                    builderResult.hasPubKey = true
                    builderResult.pubKey = value
                }
            }
            public var hasPubKey:Bool {
                get {
                    return builderResult.hasPubKey
                }
            }
            @discardableResult
            public func setPubKey(_ value:String) -> Lnrpc.DisconnectPeerRequest.Builder {
                self.pubKey = value
                return self
            }
            @discardableResult
            public func clearPubKey() -> Lnrpc.DisconnectPeerRequest.Builder{
                builderResult.hasPubKey = false
                builderResult.pubKey = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.DisconnectPeerRequest.Builder {
                builderResult = Lnrpc.DisconnectPeerRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.DisconnectPeerRequest.Builder {
                return try Lnrpc.DisconnectPeerRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.DisconnectPeerRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.DisconnectPeerRequest {
                let returnMe:Lnrpc.DisconnectPeerRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.DisconnectPeerRequest) throws -> Lnrpc.DisconnectPeerRequest.Builder {
                if other == Lnrpc.DisconnectPeerRequest() {
                    return self
                }
                if other.hasPubKey {
                    pubKey = other.pubKey
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.DisconnectPeerRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.DisconnectPeerRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        pubKey = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.DisconnectPeerRequest.Builder {
                let resultDecodedBuilder = Lnrpc.DisconnectPeerRequest.Builder()
                if let jsonValuePubKey = jsonMap["pub_key"] as? String {
                    resultDecodedBuilder.pubKey = jsonValuePubKey
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.DisconnectPeerRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.DisconnectPeerRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class DisconnectPeerResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.DisconnectPeerResponse.Builder

        public static func == (lhs: Lnrpc.DisconnectPeerResponse, rhs: Lnrpc.DisconnectPeerResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.DisconnectPeerResponse.Builder {
            return Lnrpc.DisconnectPeerResponse.classBuilder() as! Lnrpc.DisconnectPeerResponse.Builder
        }
        public func getBuilder() -> Lnrpc.DisconnectPeerResponse.Builder {
            return classBuilder() as! Lnrpc.DisconnectPeerResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.DisconnectPeerResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.DisconnectPeerResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.DisconnectPeerResponse.Builder {
            return try Lnrpc.DisconnectPeerResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.DisconnectPeerResponse) throws -> Lnrpc.DisconnectPeerResponse.Builder {
            return try Lnrpc.DisconnectPeerResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.DisconnectPeerResponse {
            return try Lnrpc.DisconnectPeerResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.DisconnectPeerResponse {
            return try Lnrpc.DisconnectPeerResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.DisconnectPeerResponse"
        }
        override public func className() -> String {
            return "Lnrpc.DisconnectPeerResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.DisconnectPeerResponse = Lnrpc.DisconnectPeerResponse()
            public func getMessage() -> Lnrpc.DisconnectPeerResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.DisconnectPeerResponse.Builder {
                builderResult = Lnrpc.DisconnectPeerResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.DisconnectPeerResponse.Builder {
                return try Lnrpc.DisconnectPeerResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.DisconnectPeerResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.DisconnectPeerResponse {
                let returnMe:Lnrpc.DisconnectPeerResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.DisconnectPeerResponse) throws -> Lnrpc.DisconnectPeerResponse.Builder {
                if other == Lnrpc.DisconnectPeerResponse() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.DisconnectPeerResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.DisconnectPeerResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.DisconnectPeerResponse.Builder {
                let resultDecodedBuilder = Lnrpc.DisconnectPeerResponse.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.DisconnectPeerResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.DisconnectPeerResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class Htlc : GeneratedMessage {
        public typealias BuilderType = Lnrpc.Htlc.Builder

        public static func == (lhs: Lnrpc.Htlc, rhs: Lnrpc.Htlc) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasIncoming == rhs.hasIncoming) && (!lhs.hasIncoming || lhs.incoming == rhs.incoming)
            fieldCheck = fieldCheck && (lhs.hasAmount == rhs.hasAmount) && (!lhs.hasAmount || lhs.amount == rhs.amount)
            fieldCheck = fieldCheck && (lhs.hasHashLock == rhs.hasHashLock) && (!lhs.hasHashLock || lhs.hashLock == rhs.hashLock)
            fieldCheck = fieldCheck && (lhs.hasExpirationHeight == rhs.hasExpirationHeight) && (!lhs.hasExpirationHeight || lhs.expirationHeight == rhs.expirationHeight)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var incoming:Bool! = nil
        public fileprivate(set) var hasIncoming:Bool = false

        public fileprivate(set) var amount:Int64! = nil
        public fileprivate(set) var hasAmount:Bool = false

        public fileprivate(set) var hashLock:Data! = nil
        public fileprivate(set) var hasHashLock:Bool = false

        public fileprivate(set) var expirationHeight:UInt32! = nil
        public fileprivate(set) var hasExpirationHeight:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasIncoming {
                try codedOutputStream.writeBool(fieldNumber: 1, value:incoming)
            }
            if hasAmount {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:amount)
            }
            if hasHashLock {
                try codedOutputStream.writeData(fieldNumber: 3, value:hashLock)
            }
            if hasExpirationHeight {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:expirationHeight)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasIncoming {
                serialize_size += incoming.computeBoolSize(fieldNumber: 1)
            }
            if hasAmount {
                serialize_size += amount.computeInt64Size(fieldNumber: 2)
            }
            if hasHashLock {
                serialize_size += hashLock.computeDataSize(fieldNumber: 3)
            }
            if hasExpirationHeight {
                serialize_size += expirationHeight.computeUInt32Size(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.Htlc.Builder {
            return Lnrpc.Htlc.classBuilder() as! Lnrpc.Htlc.Builder
        }
        public func getBuilder() -> Lnrpc.Htlc.Builder {
            return classBuilder() as! Lnrpc.Htlc.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.Htlc.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.Htlc.Builder()
        }
        public func toBuilder() throws -> Lnrpc.Htlc.Builder {
            return try Lnrpc.Htlc.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.Htlc) throws -> Lnrpc.Htlc.Builder {
            return try Lnrpc.Htlc.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasIncoming {
                jsonMap["incoming"] = incoming
            }
            if hasAmount {
                jsonMap["amount"] = "\(amount!)"
            }
            if hasHashLock {
                jsonMap["hash_lock"] = hashLock.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasExpirationHeight {
                jsonMap["expiration_height"] = UInt(expirationHeight)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.Htlc {
            return try Lnrpc.Htlc.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.Htlc {
            return try Lnrpc.Htlc.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasIncoming {
                output += "\(indent) incoming: \(incoming) \n"
            }
            if hasAmount {
                output += "\(indent) amount: \(amount) \n"
            }
            if hasHashLock {
                output += "\(indent) hashLock: \(hashLock) \n"
            }
            if hasExpirationHeight {
                output += "\(indent) expirationHeight: \(expirationHeight) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasIncoming {
                    hashCode = (hashCode &* 31) &+ incoming.hashValue
                }
                if hasAmount {
                    hashCode = (hashCode &* 31) &+ amount.hashValue
                }
                if hasHashLock {
                    hashCode = (hashCode &* 31) &+ hashLock.hashValue
                }
                if hasExpirationHeight {
                    hashCode = (hashCode &* 31) &+ expirationHeight.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.Htlc"
        }
        override public func className() -> String {
            return "Lnrpc.Htlc"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.Htlc = Lnrpc.Htlc()
            public func getMessage() -> Lnrpc.Htlc {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var incoming:Bool {
                get {
                    return builderResult.incoming
                }
                set (value) {
                    builderResult.hasIncoming = true
                    builderResult.incoming = value
                }
            }
            public var hasIncoming:Bool {
                get {
                    return builderResult.hasIncoming
                }
            }
            @discardableResult
            public func setIncoming(_ value:Bool) -> Lnrpc.Htlc.Builder {
                self.incoming = value
                return self
            }
            @discardableResult
            public func clearIncoming() -> Lnrpc.Htlc.Builder{
                builderResult.hasIncoming = false
                builderResult.incoming = nil
                return self
            }
            public var amount:Int64 {
                get {
                    return builderResult.amount
                }
                set (value) {
                    builderResult.hasAmount = true
                    builderResult.amount = value
                }
            }
            public var hasAmount:Bool {
                get {
                    return builderResult.hasAmount
                }
            }
            @discardableResult
            public func setAmount(_ value:Int64) -> Lnrpc.Htlc.Builder {
                self.amount = value
                return self
            }
            @discardableResult
            public func clearAmount() -> Lnrpc.Htlc.Builder{
                builderResult.hasAmount = false
                builderResult.amount = nil
                return self
            }
            public var hashLock:Data {
                get {
                    return builderResult.hashLock
                }
                set (value) {
                    builderResult.hasHashLock = true
                    builderResult.hashLock = value
                }
            }
            public var hasHashLock:Bool {
                get {
                    return builderResult.hasHashLock
                }
            }
            @discardableResult
            public func setHashLock(_ value:Data) -> Lnrpc.Htlc.Builder {
                self.hashLock = value
                return self
            }
            @discardableResult
            public func clearHashLock() -> Lnrpc.Htlc.Builder{
                builderResult.hasHashLock = false
                builderResult.hashLock = nil
                return self
            }
            public var expirationHeight:UInt32 {
                get {
                    return builderResult.expirationHeight
                }
                set (value) {
                    builderResult.hasExpirationHeight = true
                    builderResult.expirationHeight = value
                }
            }
            public var hasExpirationHeight:Bool {
                get {
                    return builderResult.hasExpirationHeight
                }
            }
            @discardableResult
            public func setExpirationHeight(_ value:UInt32) -> Lnrpc.Htlc.Builder {
                self.expirationHeight = value
                return self
            }
            @discardableResult
            public func clearExpirationHeight() -> Lnrpc.Htlc.Builder{
                builderResult.hasExpirationHeight = false
                builderResult.expirationHeight = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.Htlc.Builder {
                builderResult = Lnrpc.Htlc()
                return self
            }
            override public func clone() throws -> Lnrpc.Htlc.Builder {
                return try Lnrpc.Htlc.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.Htlc {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.Htlc {
                let returnMe:Lnrpc.Htlc = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.Htlc) throws -> Lnrpc.Htlc.Builder {
                if other == Lnrpc.Htlc() {
                    return self
                }
                if other.hasIncoming {
                    incoming = other.incoming
                }
                if other.hasAmount {
                    amount = other.amount
                }
                if other.hasHashLock {
                    hashLock = other.hashLock
                }
                if other.hasExpirationHeight {
                    expirationHeight = other.expirationHeight
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.Htlc.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Htlc.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        incoming = try codedInputStream.readBool()

                    case 16:
                        amount = try codedInputStream.readInt64()

                    case 26:
                        hashLock = try codedInputStream.readData()

                    case 32:
                        expirationHeight = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.Htlc.Builder {
                let resultDecodedBuilder = Lnrpc.Htlc.Builder()
                if let jsonValueIncoming = jsonMap["incoming"] as? Bool {
                    resultDecodedBuilder.incoming = jsonValueIncoming
                }
                if let jsonValueAmount = jsonMap["amount"] as? String {
                    resultDecodedBuilder.amount = Int64(jsonValueAmount)!
                } else if let jsonValueAmount = jsonMap["amount"] as? Int {
                    resultDecodedBuilder.amount = Int64(jsonValueAmount)
                }
                if let jsonValueHashLock = jsonMap["hash_lock"] as? String {
                    resultDecodedBuilder.hashLock = Data(base64Encoded:jsonValueHashLock, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueExpirationHeight = jsonMap["expiration_height"] as? UInt {
                    resultDecodedBuilder.expirationHeight = UInt32(jsonValueExpirationHeight)
                } else if let jsonValueExpirationHeight = jsonMap["expiration_height"] as? String {
                    resultDecodedBuilder.expirationHeight = UInt32(jsonValueExpirationHeight)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.Htlc.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.Htlc.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class Channel : GeneratedMessage {
        public typealias BuilderType = Lnrpc.Channel.Builder

        public static func == (lhs: Lnrpc.Channel, rhs: Lnrpc.Channel) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasActive == rhs.hasActive) && (!lhs.hasActive || lhs.active == rhs.active)
            fieldCheck = fieldCheck && (lhs.hasRemotePubkey == rhs.hasRemotePubkey) && (!lhs.hasRemotePubkey || lhs.remotePubkey == rhs.remotePubkey)
            fieldCheck = fieldCheck && (lhs.hasChannelPoint == rhs.hasChannelPoint) && (!lhs.hasChannelPoint || lhs.channelPoint == rhs.channelPoint)
            fieldCheck = fieldCheck && (lhs.hasChanId == rhs.hasChanId) && (!lhs.hasChanId || lhs.chanId == rhs.chanId)
            fieldCheck = fieldCheck && (lhs.hasCapacity == rhs.hasCapacity) && (!lhs.hasCapacity || lhs.capacity == rhs.capacity)
            fieldCheck = fieldCheck && (lhs.hasLocalBalance == rhs.hasLocalBalance) && (!lhs.hasLocalBalance || lhs.localBalance == rhs.localBalance)
            fieldCheck = fieldCheck && (lhs.hasRemoteBalance == rhs.hasRemoteBalance) && (!lhs.hasRemoteBalance || lhs.remoteBalance == rhs.remoteBalance)
            fieldCheck = fieldCheck && (lhs.hasCommitFee == rhs.hasCommitFee) && (!lhs.hasCommitFee || lhs.commitFee == rhs.commitFee)
            fieldCheck = fieldCheck && (lhs.hasCommitWeight == rhs.hasCommitWeight) && (!lhs.hasCommitWeight || lhs.commitWeight == rhs.commitWeight)
            fieldCheck = fieldCheck && (lhs.hasFeePerKw == rhs.hasFeePerKw) && (!lhs.hasFeePerKw || lhs.feePerKw == rhs.feePerKw)
            fieldCheck = fieldCheck && (lhs.hasUnsettledBalance == rhs.hasUnsettledBalance) && (!lhs.hasUnsettledBalance || lhs.unsettledBalance == rhs.unsettledBalance)
            fieldCheck = fieldCheck && (lhs.hasTotalSatoshisSent == rhs.hasTotalSatoshisSent) && (!lhs.hasTotalSatoshisSent || lhs.totalSatoshisSent == rhs.totalSatoshisSent)
            fieldCheck = fieldCheck && (lhs.hasTotalSatoshisReceived == rhs.hasTotalSatoshisReceived) && (!lhs.hasTotalSatoshisReceived || lhs.totalSatoshisReceived == rhs.totalSatoshisReceived)
            fieldCheck = fieldCheck && (lhs.hasNumUpdates == rhs.hasNumUpdates) && (!lhs.hasNumUpdates || lhs.numUpdates == rhs.numUpdates)
            fieldCheck = fieldCheck && (lhs.pendingHtlcs == rhs.pendingHtlcs)
            fieldCheck = fieldCheck && (lhs.hasCsvDelay == rhs.hasCsvDelay) && (!lhs.hasCsvDelay || lhs.csvDelay == rhs.csvDelay)
            fieldCheck = fieldCheck && (lhs.hasPrivate == rhs.hasPrivate) && (!lhs.hasPrivate || lhs.private == rhs.private)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// Whether this channel is active or not
        public fileprivate(set) var active:Bool! = nil
        public fileprivate(set) var hasActive:Bool = false

        //// The identity pubkey of the remote node
        public fileprivate(set) var remotePubkey:String! = nil
        public fileprivate(set) var hasRemotePubkey:Bool = false

        ///*
        ///The outpoint (txid:index) of the funding transaction. With this value, Bob
        ///will be able to generate a signature for Alice's version of the commitment
        ///transaction.
        public fileprivate(set) var channelPoint:String! = nil
        public fileprivate(set) var hasChannelPoint:Bool = false

        ///*
        ///The unique channel ID for the channel. The first 3 bytes are the block
        ///height, the next 3 the index within the block, and the last 2 bytes are the
        ///output index for the channel.
        public fileprivate(set) var chanId:UInt64! = nil
        public fileprivate(set) var hasChanId:Bool = false

        //// The total amount of funds held in this channel
        public fileprivate(set) var capacity:Int64! = nil
        public fileprivate(set) var hasCapacity:Bool = false

        //// This node's current balance in this channel
        public fileprivate(set) var localBalance:Int64! = nil
        public fileprivate(set) var hasLocalBalance:Bool = false

        //// The counterparty's current balance in this channel
        public fileprivate(set) var remoteBalance:Int64! = nil
        public fileprivate(set) var hasRemoteBalance:Bool = false

        ///*
        ///The amount calculated to be paid in fees for the current set of commitment
        ///transactions. The fee amount is persisted with the channel in order to
        ///allow the fee amount to be removed and recalculated with each channel state
        ///update, including updates that happen after a system restart.
        public fileprivate(set) var commitFee:Int64! = nil
        public fileprivate(set) var hasCommitFee:Bool = false

        //// The weight of the commitment transaction
        public fileprivate(set) var commitWeight:Int64! = nil
        public fileprivate(set) var hasCommitWeight:Bool = false

        ///*
        ///The required number of satoshis per kilo-weight that the requester will pay
        ///at all times, for both the funding transaction and commitment transaction.
        ///This value can later be updated once the channel is open.
        public fileprivate(set) var feePerKw:Int64! = nil
        public fileprivate(set) var hasFeePerKw:Bool = false

        //// The unsettled balance in this channel
        public fileprivate(set) var unsettledBalance:Int64! = nil
        public fileprivate(set) var hasUnsettledBalance:Bool = false

        ///*
        ///The total number of satoshis we've sent within this channel.
        public fileprivate(set) var totalSatoshisSent:Int64! = nil
        public fileprivate(set) var hasTotalSatoshisSent:Bool = false

        ///*
        ///The total number of satoshis we've received within this channel.
        public fileprivate(set) var totalSatoshisReceived:Int64! = nil
        public fileprivate(set) var hasTotalSatoshisReceived:Bool = false

        ///*
        ///The total number of updates conducted within this channel.
        public fileprivate(set) var numUpdates:UInt64! = nil
        public fileprivate(set) var hasNumUpdates:Bool = false

        public fileprivate(set) var pendingHtlcs:Array<Lnrpc.Htlc>  = Array<Lnrpc.Htlc>()
        ///*
        ///The CSV delay expressed in relative blocks. If the channel is force
        ///closed, we'll need to wait for this many blocks before we can regain our
        ///funds.
        public fileprivate(set) var csvDelay:UInt32! = nil
        public fileprivate(set) var hasCsvDelay:Bool = false

        //// Whether this channel is advertised to the network or not
        public fileprivate(set) var private:Bool! = nil
        public fileprivate(set) var hasPrivate:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasActive {
                try codedOutputStream.writeBool(fieldNumber: 1, value:active)
            }
            if hasRemotePubkey {
                try codedOutputStream.writeString(fieldNumber: 2, value:remotePubkey)
            }
            if hasChannelPoint {
                try codedOutputStream.writeString(fieldNumber: 3, value:channelPoint)
            }
            if hasChanId {
                try codedOutputStream.writeUInt64(fieldNumber: 4, value:chanId)
            }
            if hasCapacity {
                try codedOutputStream.writeInt64(fieldNumber: 5, value:capacity)
            }
            if hasLocalBalance {
                try codedOutputStream.writeInt64(fieldNumber: 6, value:localBalance)
            }
            if hasRemoteBalance {
                try codedOutputStream.writeInt64(fieldNumber: 7, value:remoteBalance)
            }
            if hasCommitFee {
                try codedOutputStream.writeInt64(fieldNumber: 8, value:commitFee)
            }
            if hasCommitWeight {
                try codedOutputStream.writeInt64(fieldNumber: 9, value:commitWeight)
            }
            if hasFeePerKw {
                try codedOutputStream.writeInt64(fieldNumber: 10, value:feePerKw)
            }
            if hasUnsettledBalance {
                try codedOutputStream.writeInt64(fieldNumber: 11, value:unsettledBalance)
            }
            if hasTotalSatoshisSent {
                try codedOutputStream.writeInt64(fieldNumber: 12, value:totalSatoshisSent)
            }
            if hasTotalSatoshisReceived {
                try codedOutputStream.writeInt64(fieldNumber: 13, value:totalSatoshisReceived)
            }
            if hasNumUpdates {
                try codedOutputStream.writeUInt64(fieldNumber: 14, value:numUpdates)
            }
            for oneElementPendingHtlcs in pendingHtlcs {
                  try codedOutputStream.writeMessage(fieldNumber: 15, value:oneElementPendingHtlcs)
            }
            if hasCsvDelay {
                try codedOutputStream.writeUInt32(fieldNumber: 16, value:csvDelay)
            }
            if hasPrivate {
                try codedOutputStream.writeBool(fieldNumber: 17, value:private)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasActive {
                serialize_size += active.computeBoolSize(fieldNumber: 1)
            }
            if hasRemotePubkey {
                serialize_size += remotePubkey.computeStringSize(fieldNumber: 2)
            }
            if hasChannelPoint {
                serialize_size += channelPoint.computeStringSize(fieldNumber: 3)
            }
            if hasChanId {
                serialize_size += chanId.computeUInt64Size(fieldNumber: 4)
            }
            if hasCapacity {
                serialize_size += capacity.computeInt64Size(fieldNumber: 5)
            }
            if hasLocalBalance {
                serialize_size += localBalance.computeInt64Size(fieldNumber: 6)
            }
            if hasRemoteBalance {
                serialize_size += remoteBalance.computeInt64Size(fieldNumber: 7)
            }
            if hasCommitFee {
                serialize_size += commitFee.computeInt64Size(fieldNumber: 8)
            }
            if hasCommitWeight {
                serialize_size += commitWeight.computeInt64Size(fieldNumber: 9)
            }
            if hasFeePerKw {
                serialize_size += feePerKw.computeInt64Size(fieldNumber: 10)
            }
            if hasUnsettledBalance {
                serialize_size += unsettledBalance.computeInt64Size(fieldNumber: 11)
            }
            if hasTotalSatoshisSent {
                serialize_size += totalSatoshisSent.computeInt64Size(fieldNumber: 12)
            }
            if hasTotalSatoshisReceived {
                serialize_size += totalSatoshisReceived.computeInt64Size(fieldNumber: 13)
            }
            if hasNumUpdates {
                serialize_size += numUpdates.computeUInt64Size(fieldNumber: 14)
            }
            for oneElementPendingHtlcs in pendingHtlcs {
                serialize_size += oneElementPendingHtlcs.computeMessageSize(fieldNumber: 15)
            }
            if hasCsvDelay {
                serialize_size += csvDelay.computeUInt32Size(fieldNumber: 16)
            }
            if hasPrivate {
                serialize_size += private.computeBoolSize(fieldNumber: 17)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.Channel.Builder {
            return Lnrpc.Channel.classBuilder() as! Lnrpc.Channel.Builder
        }
        public func getBuilder() -> Lnrpc.Channel.Builder {
            return classBuilder() as! Lnrpc.Channel.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.Channel.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.Channel.Builder()
        }
        public func toBuilder() throws -> Lnrpc.Channel.Builder {
            return try Lnrpc.Channel.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.Channel) throws -> Lnrpc.Channel.Builder {
            return try Lnrpc.Channel.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasActive {
                jsonMap["active"] = active
            }
            if hasRemotePubkey {
                jsonMap["remote_pubkey"] = remotePubkey
            }
            if hasChannelPoint {
                jsonMap["channel_point"] = channelPoint
            }
            if hasChanId {
                jsonMap["chan_id"] = "\(chanId!)"
            }
            if hasCapacity {
                jsonMap["capacity"] = "\(capacity!)"
            }
            if hasLocalBalance {
                jsonMap["local_balance"] = "\(localBalance!)"
            }
            if hasRemoteBalance {
                jsonMap["remote_balance"] = "\(remoteBalance!)"
            }
            if hasCommitFee {
                jsonMap["commit_fee"] = "\(commitFee!)"
            }
            if hasCommitWeight {
                jsonMap["commit_weight"] = "\(commitWeight!)"
            }
            if hasFeePerKw {
                jsonMap["fee_per_kw"] = "\(feePerKw!)"
            }
            if hasUnsettledBalance {
                jsonMap["unsettled_balance"] = "\(unsettledBalance!)"
            }
            if hasTotalSatoshisSent {
                jsonMap["total_satoshis_sent"] = "\(totalSatoshisSent!)"
            }
            if hasTotalSatoshisReceived {
                jsonMap["total_satoshis_received"] = "\(totalSatoshisReceived!)"
            }
            if hasNumUpdates {
                jsonMap["num_updates"] = "\(numUpdates!)"
            }
            if !pendingHtlcs.isEmpty {
                var jsonArrayPendingHtlcs:Array<Dictionary<String,Any>> = []
                for oneValuePendingHtlcs in pendingHtlcs {
                    let ecodedMessagePendingHtlcs = try oneValuePendingHtlcs.encode()
                    jsonArrayPendingHtlcs.append(ecodedMessagePendingHtlcs)
                }
                jsonMap["pending_htlcs"] = jsonArrayPendingHtlcs
            }
            if hasCsvDelay {
                jsonMap["csv_delay"] = UInt(csvDelay)
            }
            if hasPrivate {
                jsonMap["private"] = private
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.Channel {
            return try Lnrpc.Channel.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.Channel {
            return try Lnrpc.Channel.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasActive {
                output += "\(indent) active: \(active) \n"
            }
            if hasRemotePubkey {
                output += "\(indent) remotePubkey: \(remotePubkey) \n"
            }
            if hasChannelPoint {
                output += "\(indent) channelPoint: \(channelPoint) \n"
            }
            if hasChanId {
                output += "\(indent) chanId: \(chanId) \n"
            }
            if hasCapacity {
                output += "\(indent) capacity: \(capacity) \n"
            }
            if hasLocalBalance {
                output += "\(indent) localBalance: \(localBalance) \n"
            }
            if hasRemoteBalance {
                output += "\(indent) remoteBalance: \(remoteBalance) \n"
            }
            if hasCommitFee {
                output += "\(indent) commitFee: \(commitFee) \n"
            }
            if hasCommitWeight {
                output += "\(indent) commitWeight: \(commitWeight) \n"
            }
            if hasFeePerKw {
                output += "\(indent) feePerKw: \(feePerKw) \n"
            }
            if hasUnsettledBalance {
                output += "\(indent) unsettledBalance: \(unsettledBalance) \n"
            }
            if hasTotalSatoshisSent {
                output += "\(indent) totalSatoshisSent: \(totalSatoshisSent) \n"
            }
            if hasTotalSatoshisReceived {
                output += "\(indent) totalSatoshisReceived: \(totalSatoshisReceived) \n"
            }
            if hasNumUpdates {
                output += "\(indent) numUpdates: \(numUpdates) \n"
            }
            var pendingHtlcsElementIndex:Int = 0
            for oneElementPendingHtlcs in pendingHtlcs {
                output += "\(indent) pendingHtlcs[\(pendingHtlcsElementIndex)] {\n"
                output += try oneElementPendingHtlcs.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                pendingHtlcsElementIndex += 1
            }
            if hasCsvDelay {
                output += "\(indent) csvDelay: \(csvDelay) \n"
            }
            if hasPrivate {
                output += "\(indent) private: \(private) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasActive {
                    hashCode = (hashCode &* 31) &+ active.hashValue
                }
                if hasRemotePubkey {
                    hashCode = (hashCode &* 31) &+ remotePubkey.hashValue
                }
                if hasChannelPoint {
                    hashCode = (hashCode &* 31) &+ channelPoint.hashValue
                }
                if hasChanId {
                    hashCode = (hashCode &* 31) &+ chanId.hashValue
                }
                if hasCapacity {
                    hashCode = (hashCode &* 31) &+ capacity.hashValue
                }
                if hasLocalBalance {
                    hashCode = (hashCode &* 31) &+ localBalance.hashValue
                }
                if hasRemoteBalance {
                    hashCode = (hashCode &* 31) &+ remoteBalance.hashValue
                }
                if hasCommitFee {
                    hashCode = (hashCode &* 31) &+ commitFee.hashValue
                }
                if hasCommitWeight {
                    hashCode = (hashCode &* 31) &+ commitWeight.hashValue
                }
                if hasFeePerKw {
                    hashCode = (hashCode &* 31) &+ feePerKw.hashValue
                }
                if hasUnsettledBalance {
                    hashCode = (hashCode &* 31) &+ unsettledBalance.hashValue
                }
                if hasTotalSatoshisSent {
                    hashCode = (hashCode &* 31) &+ totalSatoshisSent.hashValue
                }
                if hasTotalSatoshisReceived {
                    hashCode = (hashCode &* 31) &+ totalSatoshisReceived.hashValue
                }
                if hasNumUpdates {
                    hashCode = (hashCode &* 31) &+ numUpdates.hashValue
                }
                for oneElementPendingHtlcs in pendingHtlcs {
                    hashCode = (hashCode &* 31) &+ oneElementPendingHtlcs.hashValue
                }
                if hasCsvDelay {
                    hashCode = (hashCode &* 31) &+ csvDelay.hashValue
                }
                if hasPrivate {
                    hashCode = (hashCode &* 31) &+ private.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.Channel"
        }
        override public func className() -> String {
            return "Lnrpc.Channel"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.Channel = Lnrpc.Channel()
            public func getMessage() -> Lnrpc.Channel {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// Whether this channel is active or not
            public var active:Bool {
                get {
                    return builderResult.active
                }
                set (value) {
                    builderResult.hasActive = true
                    builderResult.active = value
                }
            }
            public var hasActive:Bool {
                get {
                    return builderResult.hasActive
                }
            }
            @discardableResult
            public func setActive(_ value:Bool) -> Lnrpc.Channel.Builder {
                self.active = value
                return self
            }
            @discardableResult
            public func clearActive() -> Lnrpc.Channel.Builder{
                builderResult.hasActive = false
                builderResult.active = nil
                return self
            }
            //// The identity pubkey of the remote node
            public var remotePubkey:String {
                get {
                    return builderResult.remotePubkey
                }
                set (value) {
                    builderResult.hasRemotePubkey = true
                    builderResult.remotePubkey = value
                }
            }
            public var hasRemotePubkey:Bool {
                get {
                    return builderResult.hasRemotePubkey
                }
            }
            @discardableResult
            public func setRemotePubkey(_ value:String) -> Lnrpc.Channel.Builder {
                self.remotePubkey = value
                return self
            }
            @discardableResult
            public func clearRemotePubkey() -> Lnrpc.Channel.Builder{
                builderResult.hasRemotePubkey = false
                builderResult.remotePubkey = nil
                return self
            }
            ///*
            ///The outpoint (txid:index) of the funding transaction. With this value, Bob
            ///will be able to generate a signature for Alice's version of the commitment
            ///transaction.
            public var channelPoint:String {
                get {
                    return builderResult.channelPoint
                }
                set (value) {
                    builderResult.hasChannelPoint = true
                    builderResult.channelPoint = value
                }
            }
            public var hasChannelPoint:Bool {
                get {
                    return builderResult.hasChannelPoint
                }
            }
            @discardableResult
            public func setChannelPoint(_ value:String) -> Lnrpc.Channel.Builder {
                self.channelPoint = value
                return self
            }
            @discardableResult
            public func clearChannelPoint() -> Lnrpc.Channel.Builder{
                builderResult.hasChannelPoint = false
                builderResult.channelPoint = nil
                return self
            }
            ///*
            ///The unique channel ID for the channel. The first 3 bytes are the block
            ///height, the next 3 the index within the block, and the last 2 bytes are the
            ///output index for the channel.
            public var chanId:UInt64 {
                get {
                    return builderResult.chanId
                }
                set (value) {
                    builderResult.hasChanId = true
                    builderResult.chanId = value
                }
            }
            public var hasChanId:Bool {
                get {
                    return builderResult.hasChanId
                }
            }
            @discardableResult
            public func setChanId(_ value:UInt64) -> Lnrpc.Channel.Builder {
                self.chanId = value
                return self
            }
            @discardableResult
            public func clearChanId() -> Lnrpc.Channel.Builder{
                builderResult.hasChanId = false
                builderResult.chanId = nil
                return self
            }
            //// The total amount of funds held in this channel
            public var capacity:Int64 {
                get {
                    return builderResult.capacity
                }
                set (value) {
                    builderResult.hasCapacity = true
                    builderResult.capacity = value
                }
            }
            public var hasCapacity:Bool {
                get {
                    return builderResult.hasCapacity
                }
            }
            @discardableResult
            public func setCapacity(_ value:Int64) -> Lnrpc.Channel.Builder {
                self.capacity = value
                return self
            }
            @discardableResult
            public func clearCapacity() -> Lnrpc.Channel.Builder{
                builderResult.hasCapacity = false
                builderResult.capacity = nil
                return self
            }
            //// This node's current balance in this channel
            public var localBalance:Int64 {
                get {
                    return builderResult.localBalance
                }
                set (value) {
                    builderResult.hasLocalBalance = true
                    builderResult.localBalance = value
                }
            }
            public var hasLocalBalance:Bool {
                get {
                    return builderResult.hasLocalBalance
                }
            }
            @discardableResult
            public func setLocalBalance(_ value:Int64) -> Lnrpc.Channel.Builder {
                self.localBalance = value
                return self
            }
            @discardableResult
            public func clearLocalBalance() -> Lnrpc.Channel.Builder{
                builderResult.hasLocalBalance = false
                builderResult.localBalance = nil
                return self
            }
            //// The counterparty's current balance in this channel
            public var remoteBalance:Int64 {
                get {
                    return builderResult.remoteBalance
                }
                set (value) {
                    builderResult.hasRemoteBalance = true
                    builderResult.remoteBalance = value
                }
            }
            public var hasRemoteBalance:Bool {
                get {
                    return builderResult.hasRemoteBalance
                }
            }
            @discardableResult
            public func setRemoteBalance(_ value:Int64) -> Lnrpc.Channel.Builder {
                self.remoteBalance = value
                return self
            }
            @discardableResult
            public func clearRemoteBalance() -> Lnrpc.Channel.Builder{
                builderResult.hasRemoteBalance = false
                builderResult.remoteBalance = nil
                return self
            }
            ///*
            ///The amount calculated to be paid in fees for the current set of commitment
            ///transactions. The fee amount is persisted with the channel in order to
            ///allow the fee amount to be removed and recalculated with each channel state
            ///update, including updates that happen after a system restart.
            public var commitFee:Int64 {
                get {
                    return builderResult.commitFee
                }
                set (value) {
                    builderResult.hasCommitFee = true
                    builderResult.commitFee = value
                }
            }
            public var hasCommitFee:Bool {
                get {
                    return builderResult.hasCommitFee
                }
            }
            @discardableResult
            public func setCommitFee(_ value:Int64) -> Lnrpc.Channel.Builder {
                self.commitFee = value
                return self
            }
            @discardableResult
            public func clearCommitFee() -> Lnrpc.Channel.Builder{
                builderResult.hasCommitFee = false
                builderResult.commitFee = nil
                return self
            }
            //// The weight of the commitment transaction
            public var commitWeight:Int64 {
                get {
                    return builderResult.commitWeight
                }
                set (value) {
                    builderResult.hasCommitWeight = true
                    builderResult.commitWeight = value
                }
            }
            public var hasCommitWeight:Bool {
                get {
                    return builderResult.hasCommitWeight
                }
            }
            @discardableResult
            public func setCommitWeight(_ value:Int64) -> Lnrpc.Channel.Builder {
                self.commitWeight = value
                return self
            }
            @discardableResult
            public func clearCommitWeight() -> Lnrpc.Channel.Builder{
                builderResult.hasCommitWeight = false
                builderResult.commitWeight = nil
                return self
            }
            ///*
            ///The required number of satoshis per kilo-weight that the requester will pay
            ///at all times, for both the funding transaction and commitment transaction.
            ///This value can later be updated once the channel is open.
            public var feePerKw:Int64 {
                get {
                    return builderResult.feePerKw
                }
                set (value) {
                    builderResult.hasFeePerKw = true
                    builderResult.feePerKw = value
                }
            }
            public var hasFeePerKw:Bool {
                get {
                    return builderResult.hasFeePerKw
                }
            }
            @discardableResult
            public func setFeePerKw(_ value:Int64) -> Lnrpc.Channel.Builder {
                self.feePerKw = value
                return self
            }
            @discardableResult
            public func clearFeePerKw() -> Lnrpc.Channel.Builder{
                builderResult.hasFeePerKw = false
                builderResult.feePerKw = nil
                return self
            }
            //// The unsettled balance in this channel
            public var unsettledBalance:Int64 {
                get {
                    return builderResult.unsettledBalance
                }
                set (value) {
                    builderResult.hasUnsettledBalance = true
                    builderResult.unsettledBalance = value
                }
            }
            public var hasUnsettledBalance:Bool {
                get {
                    return builderResult.hasUnsettledBalance
                }
            }
            @discardableResult
            public func setUnsettledBalance(_ value:Int64) -> Lnrpc.Channel.Builder {
                self.unsettledBalance = value
                return self
            }
            @discardableResult
            public func clearUnsettledBalance() -> Lnrpc.Channel.Builder{
                builderResult.hasUnsettledBalance = false
                builderResult.unsettledBalance = nil
                return self
            }
            ///*
            ///The total number of satoshis we've sent within this channel.
            public var totalSatoshisSent:Int64 {
                get {
                    return builderResult.totalSatoshisSent
                }
                set (value) {
                    builderResult.hasTotalSatoshisSent = true
                    builderResult.totalSatoshisSent = value
                }
            }
            public var hasTotalSatoshisSent:Bool {
                get {
                    return builderResult.hasTotalSatoshisSent
                }
            }
            @discardableResult
            public func setTotalSatoshisSent(_ value:Int64) -> Lnrpc.Channel.Builder {
                self.totalSatoshisSent = value
                return self
            }
            @discardableResult
            public func clearTotalSatoshisSent() -> Lnrpc.Channel.Builder{
                builderResult.hasTotalSatoshisSent = false
                builderResult.totalSatoshisSent = nil
                return self
            }
            ///*
            ///The total number of satoshis we've received within this channel.
            public var totalSatoshisReceived:Int64 {
                get {
                    return builderResult.totalSatoshisReceived
                }
                set (value) {
                    builderResult.hasTotalSatoshisReceived = true
                    builderResult.totalSatoshisReceived = value
                }
            }
            public var hasTotalSatoshisReceived:Bool {
                get {
                    return builderResult.hasTotalSatoshisReceived
                }
            }
            @discardableResult
            public func setTotalSatoshisReceived(_ value:Int64) -> Lnrpc.Channel.Builder {
                self.totalSatoshisReceived = value
                return self
            }
            @discardableResult
            public func clearTotalSatoshisReceived() -> Lnrpc.Channel.Builder{
                builderResult.hasTotalSatoshisReceived = false
                builderResult.totalSatoshisReceived = nil
                return self
            }
            ///*
            ///The total number of updates conducted within this channel.
            public var numUpdates:UInt64 {
                get {
                    return builderResult.numUpdates
                }
                set (value) {
                    builderResult.hasNumUpdates = true
                    builderResult.numUpdates = value
                }
            }
            public var hasNumUpdates:Bool {
                get {
                    return builderResult.hasNumUpdates
                }
            }
            @discardableResult
            public func setNumUpdates(_ value:UInt64) -> Lnrpc.Channel.Builder {
                self.numUpdates = value
                return self
            }
            @discardableResult
            public func clearNumUpdates() -> Lnrpc.Channel.Builder{
                builderResult.hasNumUpdates = false
                builderResult.numUpdates = nil
                return self
            }
            ///*
            ///The list of active, uncleared HTLCs currently pending within the channel.
            public var pendingHtlcs:Array<Lnrpc.Htlc> {
                get {
                    return builderResult.pendingHtlcs
                }
                set (value) {
                    builderResult.pendingHtlcs = value
                }
            }
            @discardableResult
            public func setPendingHtlcs(_ value:Array<Lnrpc.Htlc>) -> Lnrpc.Channel.Builder {
                self.pendingHtlcs = value
                return self
            }
            @discardableResult
            public func clearPendingHtlcs() -> Lnrpc.Channel.Builder {
                builderResult.pendingHtlcs.removeAll(keepingCapacity: false)
                return self
            }
            ///*
            ///The CSV delay expressed in relative blocks. If the channel is force
            ///closed, we'll need to wait for this many blocks before we can regain our
            ///funds.
            public var csvDelay:UInt32 {
                get {
                    return builderResult.csvDelay
                }
                set (value) {
                    builderResult.hasCsvDelay = true
                    builderResult.csvDelay = value
                }
            }
            public var hasCsvDelay:Bool {
                get {
                    return builderResult.hasCsvDelay
                }
            }
            @discardableResult
            public func setCsvDelay(_ value:UInt32) -> Lnrpc.Channel.Builder {
                self.csvDelay = value
                return self
            }
            @discardableResult
            public func clearCsvDelay() -> Lnrpc.Channel.Builder{
                builderResult.hasCsvDelay = false
                builderResult.csvDelay = nil
                return self
            }
            //// Whether this channel is advertised to the network or not
            public var private:Bool {
                get {
                    return builderResult.private
                }
                set (value) {
                    builderResult.hasPrivate = true
                    builderResult.private = value
                }
            }
            public var hasPrivate:Bool {
                get {
                    return builderResult.hasPrivate
                }
            }
            @discardableResult
            public func setPrivate(_ value:Bool) -> Lnrpc.Channel.Builder {
                self.private = value
                return self
            }
            @discardableResult
            public func clearPrivate() -> Lnrpc.Channel.Builder{
                builderResult.hasPrivate = false
                builderResult.private = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.Channel.Builder {
                builderResult = Lnrpc.Channel()
                return self
            }
            override public func clone() throws -> Lnrpc.Channel.Builder {
                return try Lnrpc.Channel.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.Channel {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.Channel {
                let returnMe:Lnrpc.Channel = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.Channel) throws -> Lnrpc.Channel.Builder {
                if other == Lnrpc.Channel() {
                    return self
                }
                if other.hasActive {
                    active = other.active
                }
                if other.hasRemotePubkey {
                    remotePubkey = other.remotePubkey
                }
                if other.hasChannelPoint {
                    channelPoint = other.channelPoint
                }
                if other.hasChanId {
                    chanId = other.chanId
                }
                if other.hasCapacity {
                    capacity = other.capacity
                }
                if other.hasLocalBalance {
                    localBalance = other.localBalance
                }
                if other.hasRemoteBalance {
                    remoteBalance = other.remoteBalance
                }
                if other.hasCommitFee {
                    commitFee = other.commitFee
                }
                if other.hasCommitWeight {
                    commitWeight = other.commitWeight
                }
                if other.hasFeePerKw {
                    feePerKw = other.feePerKw
                }
                if other.hasUnsettledBalance {
                    unsettledBalance = other.unsettledBalance
                }
                if other.hasTotalSatoshisSent {
                    totalSatoshisSent = other.totalSatoshisSent
                }
                if other.hasTotalSatoshisReceived {
                    totalSatoshisReceived = other.totalSatoshisReceived
                }
                if other.hasNumUpdates {
                    numUpdates = other.numUpdates
                }
                if !other.pendingHtlcs.isEmpty  {
                     builderResult.pendingHtlcs += other.pendingHtlcs
                }
                if other.hasCsvDelay {
                    csvDelay = other.csvDelay
                }
                if other.hasPrivate {
                    private = other.private
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.Channel.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Channel.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        active = try codedInputStream.readBool()

                    case 18:
                        remotePubkey = try codedInputStream.readString()

                    case 26:
                        channelPoint = try codedInputStream.readString()

                    case 32:
                        chanId = try codedInputStream.readUInt64()

                    case 40:
                        capacity = try codedInputStream.readInt64()

                    case 48:
                        localBalance = try codedInputStream.readInt64()

                    case 56:
                        remoteBalance = try codedInputStream.readInt64()

                    case 64:
                        commitFee = try codedInputStream.readInt64()

                    case 72:
                        commitWeight = try codedInputStream.readInt64()

                    case 80:
                        feePerKw = try codedInputStream.readInt64()

                    case 88:
                        unsettledBalance = try codedInputStream.readInt64()

                    case 96:
                        totalSatoshisSent = try codedInputStream.readInt64()

                    case 104:
                        totalSatoshisReceived = try codedInputStream.readInt64()

                    case 112:
                        numUpdates = try codedInputStream.readUInt64()

                    case 122:
                        let subBuilder = Lnrpc.Htlc.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        pendingHtlcs.append(subBuilder.buildPartial())

                    case 128:
                        csvDelay = try codedInputStream.readUInt32()

                    case 136:
                        private = try codedInputStream.readBool()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.Channel.Builder {
                let resultDecodedBuilder = Lnrpc.Channel.Builder()
                if let jsonValueActive = jsonMap["active"] as? Bool {
                    resultDecodedBuilder.active = jsonValueActive
                }
                if let jsonValueRemotePubkey = jsonMap["remote_pubkey"] as? String {
                    resultDecodedBuilder.remotePubkey = jsonValueRemotePubkey
                }
                if let jsonValueChannelPoint = jsonMap["channel_point"] as? String {
                    resultDecodedBuilder.channelPoint = jsonValueChannelPoint
                }
                if let jsonValueChanId = jsonMap["chan_id"] as? String {
                    resultDecodedBuilder.chanId = UInt64(jsonValueChanId)!
                } else if let jsonValueChanId = jsonMap["chan_id"] as? UInt {
                    resultDecodedBuilder.chanId = UInt64(jsonValueChanId)
                }
                if let jsonValueCapacity = jsonMap["capacity"] as? String {
                    resultDecodedBuilder.capacity = Int64(jsonValueCapacity)!
                } else if let jsonValueCapacity = jsonMap["capacity"] as? Int {
                    resultDecodedBuilder.capacity = Int64(jsonValueCapacity)
                }
                if let jsonValueLocalBalance = jsonMap["local_balance"] as? String {
                    resultDecodedBuilder.localBalance = Int64(jsonValueLocalBalance)!
                } else if let jsonValueLocalBalance = jsonMap["local_balance"] as? Int {
                    resultDecodedBuilder.localBalance = Int64(jsonValueLocalBalance)
                }
                if let jsonValueRemoteBalance = jsonMap["remote_balance"] as? String {
                    resultDecodedBuilder.remoteBalance = Int64(jsonValueRemoteBalance)!
                } else if let jsonValueRemoteBalance = jsonMap["remote_balance"] as? Int {
                    resultDecodedBuilder.remoteBalance = Int64(jsonValueRemoteBalance)
                }
                if let jsonValueCommitFee = jsonMap["commit_fee"] as? String {
                    resultDecodedBuilder.commitFee = Int64(jsonValueCommitFee)!
                } else if let jsonValueCommitFee = jsonMap["commit_fee"] as? Int {
                    resultDecodedBuilder.commitFee = Int64(jsonValueCommitFee)
                }
                if let jsonValueCommitWeight = jsonMap["commit_weight"] as? String {
                    resultDecodedBuilder.commitWeight = Int64(jsonValueCommitWeight)!
                } else if let jsonValueCommitWeight = jsonMap["commit_weight"] as? Int {
                    resultDecodedBuilder.commitWeight = Int64(jsonValueCommitWeight)
                }
                if let jsonValueFeePerKw = jsonMap["fee_per_kw"] as? String {
                    resultDecodedBuilder.feePerKw = Int64(jsonValueFeePerKw)!
                } else if let jsonValueFeePerKw = jsonMap["fee_per_kw"] as? Int {
                    resultDecodedBuilder.feePerKw = Int64(jsonValueFeePerKw)
                }
                if let jsonValueUnsettledBalance = jsonMap["unsettled_balance"] as? String {
                    resultDecodedBuilder.unsettledBalance = Int64(jsonValueUnsettledBalance)!
                } else if let jsonValueUnsettledBalance = jsonMap["unsettled_balance"] as? Int {
                    resultDecodedBuilder.unsettledBalance = Int64(jsonValueUnsettledBalance)
                }
                if let jsonValueTotalSatoshisSent = jsonMap["total_satoshis_sent"] as? String {
                    resultDecodedBuilder.totalSatoshisSent = Int64(jsonValueTotalSatoshisSent)!
                } else if let jsonValueTotalSatoshisSent = jsonMap["total_satoshis_sent"] as? Int {
                    resultDecodedBuilder.totalSatoshisSent = Int64(jsonValueTotalSatoshisSent)
                }
                if let jsonValueTotalSatoshisReceived = jsonMap["total_satoshis_received"] as? String {
                    resultDecodedBuilder.totalSatoshisReceived = Int64(jsonValueTotalSatoshisReceived)!
                } else if let jsonValueTotalSatoshisReceived = jsonMap["total_satoshis_received"] as? Int {
                    resultDecodedBuilder.totalSatoshisReceived = Int64(jsonValueTotalSatoshisReceived)
                }
                if let jsonValueNumUpdates = jsonMap["num_updates"] as? String {
                    resultDecodedBuilder.numUpdates = UInt64(jsonValueNumUpdates)!
                } else if let jsonValueNumUpdates = jsonMap["num_updates"] as? UInt {
                    resultDecodedBuilder.numUpdates = UInt64(jsonValueNumUpdates)
                }
                if let jsonValuePendingHtlcs = jsonMap["pending_htlcs"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayPendingHtlcs:Array<Lnrpc.Htlc> = []
                    for oneValuePendingHtlcs in jsonValuePendingHtlcs {
                        let messageFromStringPendingHtlcs = try Lnrpc.Htlc.Builder.decodeToBuilder(jsonMap:oneValuePendingHtlcs).build()

                        jsonArrayPendingHtlcs.append(messageFromStringPendingHtlcs)
                    }
                    resultDecodedBuilder.pendingHtlcs = jsonArrayPendingHtlcs
                }
                if let jsonValueCsvDelay = jsonMap["csv_delay"] as? UInt {
                    resultDecodedBuilder.csvDelay = UInt32(jsonValueCsvDelay)
                } else if let jsonValueCsvDelay = jsonMap["csv_delay"] as? String {
                    resultDecodedBuilder.csvDelay = UInt32(jsonValueCsvDelay)!
                }
                if let jsonValuePrivate = jsonMap["private"] as? Bool {
                    resultDecodedBuilder.private = jsonValuePrivate
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.Channel.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.Channel.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ListChannelsRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ListChannelsRequest.Builder

        public static func == (lhs: Lnrpc.ListChannelsRequest, rhs: Lnrpc.ListChannelsRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasActiveOnly == rhs.hasActiveOnly) && (!lhs.hasActiveOnly || lhs.activeOnly == rhs.activeOnly)
            fieldCheck = fieldCheck && (lhs.hasInactiveOnly == rhs.hasInactiveOnly) && (!lhs.hasInactiveOnly || lhs.inactiveOnly == rhs.inactiveOnly)
            fieldCheck = fieldCheck && (lhs.hasPublicOnly == rhs.hasPublicOnly) && (!lhs.hasPublicOnly || lhs.publicOnly == rhs.publicOnly)
            fieldCheck = fieldCheck && (lhs.hasPrivateOnly == rhs.hasPrivateOnly) && (!lhs.hasPrivateOnly || lhs.privateOnly == rhs.privateOnly)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var activeOnly:Bool! = nil
        public fileprivate(set) var hasActiveOnly:Bool = false

        public fileprivate(set) var inactiveOnly:Bool! = nil
        public fileprivate(set) var hasInactiveOnly:Bool = false

        public fileprivate(set) var publicOnly:Bool! = nil
        public fileprivate(set) var hasPublicOnly:Bool = false

        public fileprivate(set) var privateOnly:Bool! = nil
        public fileprivate(set) var hasPrivateOnly:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasActiveOnly {
                try codedOutputStream.writeBool(fieldNumber: 1, value:activeOnly)
            }
            if hasInactiveOnly {
                try codedOutputStream.writeBool(fieldNumber: 2, value:inactiveOnly)
            }
            if hasPublicOnly {
                try codedOutputStream.writeBool(fieldNumber: 3, value:publicOnly)
            }
            if hasPrivateOnly {
                try codedOutputStream.writeBool(fieldNumber: 4, value:privateOnly)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasActiveOnly {
                serialize_size += activeOnly.computeBoolSize(fieldNumber: 1)
            }
            if hasInactiveOnly {
                serialize_size += inactiveOnly.computeBoolSize(fieldNumber: 2)
            }
            if hasPublicOnly {
                serialize_size += publicOnly.computeBoolSize(fieldNumber: 3)
            }
            if hasPrivateOnly {
                serialize_size += privateOnly.computeBoolSize(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ListChannelsRequest.Builder {
            return Lnrpc.ListChannelsRequest.classBuilder() as! Lnrpc.ListChannelsRequest.Builder
        }
        public func getBuilder() -> Lnrpc.ListChannelsRequest.Builder {
            return classBuilder() as! Lnrpc.ListChannelsRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ListChannelsRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ListChannelsRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ListChannelsRequest.Builder {
            return try Lnrpc.ListChannelsRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ListChannelsRequest) throws -> Lnrpc.ListChannelsRequest.Builder {
            return try Lnrpc.ListChannelsRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasActiveOnly {
                jsonMap["activeOnly"] = activeOnly
            }
            if hasInactiveOnly {
                jsonMap["inactiveOnly"] = inactiveOnly
            }
            if hasPublicOnly {
                jsonMap["publicOnly"] = publicOnly
            }
            if hasPrivateOnly {
                jsonMap["privateOnly"] = privateOnly
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ListChannelsRequest {
            return try Lnrpc.ListChannelsRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ListChannelsRequest {
            return try Lnrpc.ListChannelsRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasActiveOnly {
                output += "\(indent) activeOnly: \(activeOnly) \n"
            }
            if hasInactiveOnly {
                output += "\(indent) inactiveOnly: \(inactiveOnly) \n"
            }
            if hasPublicOnly {
                output += "\(indent) publicOnly: \(publicOnly) \n"
            }
            if hasPrivateOnly {
                output += "\(indent) privateOnly: \(privateOnly) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasActiveOnly {
                    hashCode = (hashCode &* 31) &+ activeOnly.hashValue
                }
                if hasInactiveOnly {
                    hashCode = (hashCode &* 31) &+ inactiveOnly.hashValue
                }
                if hasPublicOnly {
                    hashCode = (hashCode &* 31) &+ publicOnly.hashValue
                }
                if hasPrivateOnly {
                    hashCode = (hashCode &* 31) &+ privateOnly.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ListChannelsRequest"
        }
        override public func className() -> String {
            return "Lnrpc.ListChannelsRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ListChannelsRequest = Lnrpc.ListChannelsRequest()
            public func getMessage() -> Lnrpc.ListChannelsRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var activeOnly:Bool {
                get {
                    return builderResult.activeOnly
                }
                set (value) {
                    builderResult.hasActiveOnly = true
                    builderResult.activeOnly = value
                }
            }
            public var hasActiveOnly:Bool {
                get {
                    return builderResult.hasActiveOnly
                }
            }
            @discardableResult
            public func setActiveOnly(_ value:Bool) -> Lnrpc.ListChannelsRequest.Builder {
                self.activeOnly = value
                return self
            }
            @discardableResult
            public func clearActiveOnly() -> Lnrpc.ListChannelsRequest.Builder{
                builderResult.hasActiveOnly = false
                builderResult.activeOnly = nil
                return self
            }
            public var inactiveOnly:Bool {
                get {
                    return builderResult.inactiveOnly
                }
                set (value) {
                    builderResult.hasInactiveOnly = true
                    builderResult.inactiveOnly = value
                }
            }
            public var hasInactiveOnly:Bool {
                get {
                    return builderResult.hasInactiveOnly
                }
            }
            @discardableResult
            public func setInactiveOnly(_ value:Bool) -> Lnrpc.ListChannelsRequest.Builder {
                self.inactiveOnly = value
                return self
            }
            @discardableResult
            public func clearInactiveOnly() -> Lnrpc.ListChannelsRequest.Builder{
                builderResult.hasInactiveOnly = false
                builderResult.inactiveOnly = nil
                return self
            }
            public var publicOnly:Bool {
                get {
                    return builderResult.publicOnly
                }
                set (value) {
                    builderResult.hasPublicOnly = true
                    builderResult.publicOnly = value
                }
            }
            public var hasPublicOnly:Bool {
                get {
                    return builderResult.hasPublicOnly
                }
            }
            @discardableResult
            public func setPublicOnly(_ value:Bool) -> Lnrpc.ListChannelsRequest.Builder {
                self.publicOnly = value
                return self
            }
            @discardableResult
            public func clearPublicOnly() -> Lnrpc.ListChannelsRequest.Builder{
                builderResult.hasPublicOnly = false
                builderResult.publicOnly = nil
                return self
            }
            public var privateOnly:Bool {
                get {
                    return builderResult.privateOnly
                }
                set (value) {
                    builderResult.hasPrivateOnly = true
                    builderResult.privateOnly = value
                }
            }
            public var hasPrivateOnly:Bool {
                get {
                    return builderResult.hasPrivateOnly
                }
            }
            @discardableResult
            public func setPrivateOnly(_ value:Bool) -> Lnrpc.ListChannelsRequest.Builder {
                self.privateOnly = value
                return self
            }
            @discardableResult
            public func clearPrivateOnly() -> Lnrpc.ListChannelsRequest.Builder{
                builderResult.hasPrivateOnly = false
                builderResult.privateOnly = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ListChannelsRequest.Builder {
                builderResult = Lnrpc.ListChannelsRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.ListChannelsRequest.Builder {
                return try Lnrpc.ListChannelsRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ListChannelsRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ListChannelsRequest {
                let returnMe:Lnrpc.ListChannelsRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ListChannelsRequest) throws -> Lnrpc.ListChannelsRequest.Builder {
                if other == Lnrpc.ListChannelsRequest() {
                    return self
                }
                if other.hasActiveOnly {
                    activeOnly = other.activeOnly
                }
                if other.hasInactiveOnly {
                    inactiveOnly = other.inactiveOnly
                }
                if other.hasPublicOnly {
                    publicOnly = other.publicOnly
                }
                if other.hasPrivateOnly {
                    privateOnly = other.privateOnly
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ListChannelsRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListChannelsRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        activeOnly = try codedInputStream.readBool()

                    case 16:
                        inactiveOnly = try codedInputStream.readBool()

                    case 24:
                        publicOnly = try codedInputStream.readBool()

                    case 32:
                        privateOnly = try codedInputStream.readBool()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ListChannelsRequest.Builder {
                let resultDecodedBuilder = Lnrpc.ListChannelsRequest.Builder()
                if let jsonValueActiveOnly = jsonMap["activeOnly"] as? Bool {
                    resultDecodedBuilder.activeOnly = jsonValueActiveOnly
                }
                if let jsonValueInactiveOnly = jsonMap["inactiveOnly"] as? Bool {
                    resultDecodedBuilder.inactiveOnly = jsonValueInactiveOnly
                }
                if let jsonValuePublicOnly = jsonMap["publicOnly"] as? Bool {
                    resultDecodedBuilder.publicOnly = jsonValuePublicOnly
                }
                if let jsonValuePrivateOnly = jsonMap["privateOnly"] as? Bool {
                    resultDecodedBuilder.privateOnly = jsonValuePrivateOnly
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ListChannelsRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ListChannelsRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ListChannelsResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ListChannelsResponse.Builder

        public static func == (lhs: Lnrpc.ListChannelsResponse, rhs: Lnrpc.ListChannelsResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.channels == rhs.channels)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var channels:Array<Lnrpc.Channel>  = Array<Lnrpc.Channel>()
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementChannels in channels {
                  try codedOutputStream.writeMessage(fieldNumber: 11, value:oneElementChannels)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementChannels in channels {
                serialize_size += oneElementChannels.computeMessageSize(fieldNumber: 11)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ListChannelsResponse.Builder {
            return Lnrpc.ListChannelsResponse.classBuilder() as! Lnrpc.ListChannelsResponse.Builder
        }
        public func getBuilder() -> Lnrpc.ListChannelsResponse.Builder {
            return classBuilder() as! Lnrpc.ListChannelsResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ListChannelsResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ListChannelsResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ListChannelsResponse.Builder {
            return try Lnrpc.ListChannelsResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ListChannelsResponse) throws -> Lnrpc.ListChannelsResponse.Builder {
            return try Lnrpc.ListChannelsResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !channels.isEmpty {
                var jsonArrayChannels:Array<Dictionary<String,Any>> = []
                for oneValueChannels in channels {
                    let ecodedMessageChannels = try oneValueChannels.encode()
                    jsonArrayChannels.append(ecodedMessageChannels)
                }
                jsonMap["channels"] = jsonArrayChannels
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ListChannelsResponse {
            return try Lnrpc.ListChannelsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ListChannelsResponse {
            return try Lnrpc.ListChannelsResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var channelsElementIndex:Int = 0
            for oneElementChannels in channels {
                output += "\(indent) channels[\(channelsElementIndex)] {\n"
                output += try oneElementChannels.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                channelsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementChannels in channels {
                    hashCode = (hashCode &* 31) &+ oneElementChannels.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ListChannelsResponse"
        }
        override public func className() -> String {
            return "Lnrpc.ListChannelsResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ListChannelsResponse = Lnrpc.ListChannelsResponse()
            public func getMessage() -> Lnrpc.ListChannelsResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The list of active channels
            public var channels:Array<Lnrpc.Channel> {
                get {
                    return builderResult.channels
                }
                set (value) {
                    builderResult.channels = value
                }
            }
            @discardableResult
            public func setChannels(_ value:Array<Lnrpc.Channel>) -> Lnrpc.ListChannelsResponse.Builder {
                self.channels = value
                return self
            }
            @discardableResult
            public func clearChannels() -> Lnrpc.ListChannelsResponse.Builder {
                builderResult.channels.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ListChannelsResponse.Builder {
                builderResult = Lnrpc.ListChannelsResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.ListChannelsResponse.Builder {
                return try Lnrpc.ListChannelsResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ListChannelsResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ListChannelsResponse {
                let returnMe:Lnrpc.ListChannelsResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ListChannelsResponse) throws -> Lnrpc.ListChannelsResponse.Builder {
                if other == Lnrpc.ListChannelsResponse() {
                    return self
                }
                if !other.channels.isEmpty  {
                     builderResult.channels += other.channels
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ListChannelsResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListChannelsResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 90:
                        let subBuilder = Lnrpc.Channel.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        channels.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ListChannelsResponse.Builder {
                let resultDecodedBuilder = Lnrpc.ListChannelsResponse.Builder()
                if let jsonValueChannels = jsonMap["channels"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayChannels:Array<Lnrpc.Channel> = []
                    for oneValueChannels in jsonValueChannels {
                        let messageFromStringChannels = try Lnrpc.Channel.Builder.decodeToBuilder(jsonMap:oneValueChannels).build()

                        jsonArrayChannels.append(messageFromStringChannels)
                    }
                    resultDecodedBuilder.channels = jsonArrayChannels
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ListChannelsResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ListChannelsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ChannelCloseSummary : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ChannelCloseSummary.Builder

        public static func == (lhs: Lnrpc.ChannelCloseSummary, rhs: Lnrpc.ChannelCloseSummary) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasChannelPoint == rhs.hasChannelPoint) && (!lhs.hasChannelPoint || lhs.channelPoint == rhs.channelPoint)
            fieldCheck = fieldCheck && (lhs.hasChanId == rhs.hasChanId) && (!lhs.hasChanId || lhs.chanId == rhs.chanId)
            fieldCheck = fieldCheck && (lhs.hasChainHash == rhs.hasChainHash) && (!lhs.hasChainHash || lhs.chainHash == rhs.chainHash)
            fieldCheck = fieldCheck && (lhs.hasClosingTxHash == rhs.hasClosingTxHash) && (!lhs.hasClosingTxHash || lhs.closingTxHash == rhs.closingTxHash)
            fieldCheck = fieldCheck && (lhs.hasRemotePubkey == rhs.hasRemotePubkey) && (!lhs.hasRemotePubkey || lhs.remotePubkey == rhs.remotePubkey)
            fieldCheck = fieldCheck && (lhs.hasCapacity == rhs.hasCapacity) && (!lhs.hasCapacity || lhs.capacity == rhs.capacity)
            fieldCheck = fieldCheck && (lhs.hasCloseHeight == rhs.hasCloseHeight) && (!lhs.hasCloseHeight || lhs.closeHeight == rhs.closeHeight)
            fieldCheck = fieldCheck && (lhs.hasSettledBalance == rhs.hasSettledBalance) && (!lhs.hasSettledBalance || lhs.settledBalance == rhs.settledBalance)
            fieldCheck = fieldCheck && (lhs.hasTimeLockedBalance == rhs.hasTimeLockedBalance) && (!lhs.hasTimeLockedBalance || lhs.timeLockedBalance == rhs.timeLockedBalance)
            fieldCheck = fieldCheck && (lhs.hasCloseType == rhs.hasCloseType) && (!lhs.hasCloseType || lhs.closeType == rhs.closeType)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



            //Enum type declaration start 

            public enum ClosureType:Int32, GeneratedEnum {
                case cooperativeClose = 0
                case localForceClose = 1
                case remoteForceClose = 2
                case breachClose = 3
                case fundingCanceled = 4
                public func toString() -> String {
                    switch self {
                    case .cooperativeClose: return "COOPERATIVE_CLOSE"
                    case .localForceClose: return "LOCAL_FORCE_CLOSE"
                    case .remoteForceClose: return "REMOTE_FORCE_CLOSE"
                    case .breachClose: return "BREACH_CLOSE"
                    case .fundingCanceled: return "FUNDING_CANCELED"
                    }
                }
                public static func fromString(_ str:String) throws -> Lnrpc.ChannelCloseSummary.ClosureType {
                    switch str {
                    case "COOPERATIVE_CLOSE":    return .cooperativeClose
                    case "LOCAL_FORCE_CLOSE":    return .localForceClose
                    case "REMOTE_FORCE_CLOSE":    return .remoteForceClose
                    case "BREACH_CLOSE":    return .breachClose
                    case "FUNDING_CANCELED":    return .fundingCanceled
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .cooperativeClose: return ".cooperativeClose"
                    case .localForceClose: return ".localForceClose"
                    case .remoteForceClose: return ".remoteForceClose"
                    case .breachClose: return ".breachClose"
                    case .fundingCanceled: return ".fundingCanceled"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:ClosureType, rhs:ClosureType) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        //// The outpoint (txid:index) of the funding transaction. 
        public fileprivate(set) var channelPoint:String! = nil
        public fileprivate(set) var hasChannelPoint:Bool = false

        ////  The unique channel ID for the channel. 
        public fileprivate(set) var chanId:UInt64! = nil
        public fileprivate(set) var hasChanId:Bool = false

        //// The hash of the genesis block that this channel resides within.
        public fileprivate(set) var chainHash:String! = nil
        public fileprivate(set) var hasChainHash:Bool = false

        //// The txid of the transaction which ultimately closed this channel.
        public fileprivate(set) var closingTxHash:String! = nil
        public fileprivate(set) var hasClosingTxHash:Bool = false

        //// Public key of the remote peer that we formerly had a channel with.
        public fileprivate(set) var remotePubkey:String! = nil
        public fileprivate(set) var hasRemotePubkey:Bool = false

        //// Total capacity of the channel.
        public fileprivate(set) var capacity:Int64! = nil
        public fileprivate(set) var hasCapacity:Bool = false

        //// Height at which the funding transaction was spent.
        public fileprivate(set) var closeHeight:UInt32! = nil
        public fileprivate(set) var hasCloseHeight:Bool = false

        //// Settled balance at the time of channel closure
        public fileprivate(set) var settledBalance:Int64! = nil
        public fileprivate(set) var hasSettledBalance:Bool = false

        //// The sum of all the time-locked outputs at the time of channel closure
        public fileprivate(set) var timeLockedBalance:Int64! = nil
        public fileprivate(set) var hasTimeLockedBalance:Bool = false

        public fileprivate(set) var closeType:Lnrpc.ChannelCloseSummary.ClosureType = Lnrpc.ChannelCloseSummary.ClosureType.cooperativeClose
        public fileprivate(set) var hasCloseType:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasChannelPoint {
                try codedOutputStream.writeString(fieldNumber: 1, value:channelPoint)
            }
            if hasChanId {
                try codedOutputStream.writeUInt64(fieldNumber: 2, value:chanId)
            }
            if hasChainHash {
                try codedOutputStream.writeString(fieldNumber: 3, value:chainHash)
            }
            if hasClosingTxHash {
                try codedOutputStream.writeString(fieldNumber: 4, value:closingTxHash)
            }
            if hasRemotePubkey {
                try codedOutputStream.writeString(fieldNumber: 5, value:remotePubkey)
            }
            if hasCapacity {
                try codedOutputStream.writeInt64(fieldNumber: 6, value:capacity)
            }
            if hasCloseHeight {
                try codedOutputStream.writeUInt32(fieldNumber: 7, value:closeHeight)
            }
            if hasSettledBalance {
                try codedOutputStream.writeInt64(fieldNumber: 8, value:settledBalance)
            }
            if hasTimeLockedBalance {
                try codedOutputStream.writeInt64(fieldNumber: 9, value:timeLockedBalance)
            }
            if hasCloseType {
                try codedOutputStream.writeEnum(fieldNumber: 10, value:closeType.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasChannelPoint {
                serialize_size += channelPoint.computeStringSize(fieldNumber: 1)
            }
            if hasChanId {
                serialize_size += chanId.computeUInt64Size(fieldNumber: 2)
            }
            if hasChainHash {
                serialize_size += chainHash.computeStringSize(fieldNumber: 3)
            }
            if hasClosingTxHash {
                serialize_size += closingTxHash.computeStringSize(fieldNumber: 4)
            }
            if hasRemotePubkey {
                serialize_size += remotePubkey.computeStringSize(fieldNumber: 5)
            }
            if hasCapacity {
                serialize_size += capacity.computeInt64Size(fieldNumber: 6)
            }
            if hasCloseHeight {
                serialize_size += closeHeight.computeUInt32Size(fieldNumber: 7)
            }
            if hasSettledBalance {
                serialize_size += settledBalance.computeInt64Size(fieldNumber: 8)
            }
            if hasTimeLockedBalance {
                serialize_size += timeLockedBalance.computeInt64Size(fieldNumber: 9)
            }
            if (hasCloseType) {
                serialize_size += closeType.rawValue.computeEnumSize(fieldNumber: 10)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ChannelCloseSummary.Builder {
            return Lnrpc.ChannelCloseSummary.classBuilder() as! Lnrpc.ChannelCloseSummary.Builder
        }
        public func getBuilder() -> Lnrpc.ChannelCloseSummary.Builder {
            return classBuilder() as! Lnrpc.ChannelCloseSummary.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChannelCloseSummary.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChannelCloseSummary.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ChannelCloseSummary.Builder {
            return try Lnrpc.ChannelCloseSummary.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ChannelCloseSummary) throws -> Lnrpc.ChannelCloseSummary.Builder {
            return try Lnrpc.ChannelCloseSummary.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasChannelPoint {
                jsonMap["channel_point"] = channelPoint
            }
            if hasChanId {
                jsonMap["chan_id"] = "\(chanId!)"
            }
            if hasChainHash {
                jsonMap["chain_hash"] = chainHash
            }
            if hasClosingTxHash {
                jsonMap["closing_tx_hash"] = closingTxHash
            }
            if hasRemotePubkey {
                jsonMap["remote_pubkey"] = remotePubkey
            }
            if hasCapacity {
                jsonMap["capacity"] = "\(capacity!)"
            }
            if hasCloseHeight {
                jsonMap["close_height"] = UInt(closeHeight)
            }
            if hasSettledBalance {
                jsonMap["settled_balance"] = "\(settledBalance!)"
            }
            if hasTimeLockedBalance {
                jsonMap["time_locked_balance"] = "\(timeLockedBalance!)"
            }
            if hasCloseType {
                jsonMap["close_type"] = closeType.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChannelCloseSummary {
            return try Lnrpc.ChannelCloseSummary.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChannelCloseSummary {
            return try Lnrpc.ChannelCloseSummary.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasChannelPoint {
                output += "\(indent) channelPoint: \(channelPoint) \n"
            }
            if hasChanId {
                output += "\(indent) chanId: \(chanId) \n"
            }
            if hasChainHash {
                output += "\(indent) chainHash: \(chainHash) \n"
            }
            if hasClosingTxHash {
                output += "\(indent) closingTxHash: \(closingTxHash) \n"
            }
            if hasRemotePubkey {
                output += "\(indent) remotePubkey: \(remotePubkey) \n"
            }
            if hasCapacity {
                output += "\(indent) capacity: \(capacity) \n"
            }
            if hasCloseHeight {
                output += "\(indent) closeHeight: \(closeHeight) \n"
            }
            if hasSettledBalance {
                output += "\(indent) settledBalance: \(settledBalance) \n"
            }
            if hasTimeLockedBalance {
                output += "\(indent) timeLockedBalance: \(timeLockedBalance) \n"
            }
            if (hasCloseType) {
                output += "\(indent) closeType: \(closeType.description)\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasChannelPoint {
                    hashCode = (hashCode &* 31) &+ channelPoint.hashValue
                }
                if hasChanId {
                    hashCode = (hashCode &* 31) &+ chanId.hashValue
                }
                if hasChainHash {
                    hashCode = (hashCode &* 31) &+ chainHash.hashValue
                }
                if hasClosingTxHash {
                    hashCode = (hashCode &* 31) &+ closingTxHash.hashValue
                }
                if hasRemotePubkey {
                    hashCode = (hashCode &* 31) &+ remotePubkey.hashValue
                }
                if hasCapacity {
                    hashCode = (hashCode &* 31) &+ capacity.hashValue
                }
                if hasCloseHeight {
                    hashCode = (hashCode &* 31) &+ closeHeight.hashValue
                }
                if hasSettledBalance {
                    hashCode = (hashCode &* 31) &+ settledBalance.hashValue
                }
                if hasTimeLockedBalance {
                    hashCode = (hashCode &* 31) &+ timeLockedBalance.hashValue
                }
                if hasCloseType {
                     hashCode = (hashCode &* 31) &+ closeType.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ChannelCloseSummary"
        }
        override public func className() -> String {
            return "Lnrpc.ChannelCloseSummary"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ChannelCloseSummary = Lnrpc.ChannelCloseSummary()
            public func getMessage() -> Lnrpc.ChannelCloseSummary {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The outpoint (txid:index) of the funding transaction. 
            public var channelPoint:String {
                get {
                    return builderResult.channelPoint
                }
                set (value) {
                    builderResult.hasChannelPoint = true
                    builderResult.channelPoint = value
                }
            }
            public var hasChannelPoint:Bool {
                get {
                    return builderResult.hasChannelPoint
                }
            }
            @discardableResult
            public func setChannelPoint(_ value:String) -> Lnrpc.ChannelCloseSummary.Builder {
                self.channelPoint = value
                return self
            }
            @discardableResult
            public func clearChannelPoint() -> Lnrpc.ChannelCloseSummary.Builder{
                builderResult.hasChannelPoint = false
                builderResult.channelPoint = nil
                return self
            }
            ////  The unique channel ID for the channel. 
            public var chanId:UInt64 {
                get {
                    return builderResult.chanId
                }
                set (value) {
                    builderResult.hasChanId = true
                    builderResult.chanId = value
                }
            }
            public var hasChanId:Bool {
                get {
                    return builderResult.hasChanId
                }
            }
            @discardableResult
            public func setChanId(_ value:UInt64) -> Lnrpc.ChannelCloseSummary.Builder {
                self.chanId = value
                return self
            }
            @discardableResult
            public func clearChanId() -> Lnrpc.ChannelCloseSummary.Builder{
                builderResult.hasChanId = false
                builderResult.chanId = nil
                return self
            }
            //// The hash of the genesis block that this channel resides within.
            public var chainHash:String {
                get {
                    return builderResult.chainHash
                }
                set (value) {
                    builderResult.hasChainHash = true
                    builderResult.chainHash = value
                }
            }
            public var hasChainHash:Bool {
                get {
                    return builderResult.hasChainHash
                }
            }
            @discardableResult
            public func setChainHash(_ value:String) -> Lnrpc.ChannelCloseSummary.Builder {
                self.chainHash = value
                return self
            }
            @discardableResult
            public func clearChainHash() -> Lnrpc.ChannelCloseSummary.Builder{
                builderResult.hasChainHash = false
                builderResult.chainHash = nil
                return self
            }
            //// The txid of the transaction which ultimately closed this channel.
            public var closingTxHash:String {
                get {
                    return builderResult.closingTxHash
                }
                set (value) {
                    builderResult.hasClosingTxHash = true
                    builderResult.closingTxHash = value
                }
            }
            public var hasClosingTxHash:Bool {
                get {
                    return builderResult.hasClosingTxHash
                }
            }
            @discardableResult
            public func setClosingTxHash(_ value:String) -> Lnrpc.ChannelCloseSummary.Builder {
                self.closingTxHash = value
                return self
            }
            @discardableResult
            public func clearClosingTxHash() -> Lnrpc.ChannelCloseSummary.Builder{
                builderResult.hasClosingTxHash = false
                builderResult.closingTxHash = nil
                return self
            }
            //// Public key of the remote peer that we formerly had a channel with.
            public var remotePubkey:String {
                get {
                    return builderResult.remotePubkey
                }
                set (value) {
                    builderResult.hasRemotePubkey = true
                    builderResult.remotePubkey = value
                }
            }
            public var hasRemotePubkey:Bool {
                get {
                    return builderResult.hasRemotePubkey
                }
            }
            @discardableResult
            public func setRemotePubkey(_ value:String) -> Lnrpc.ChannelCloseSummary.Builder {
                self.remotePubkey = value
                return self
            }
            @discardableResult
            public func clearRemotePubkey() -> Lnrpc.ChannelCloseSummary.Builder{
                builderResult.hasRemotePubkey = false
                builderResult.remotePubkey = nil
                return self
            }
            //// Total capacity of the channel.
            public var capacity:Int64 {
                get {
                    return builderResult.capacity
                }
                set (value) {
                    builderResult.hasCapacity = true
                    builderResult.capacity = value
                }
            }
            public var hasCapacity:Bool {
                get {
                    return builderResult.hasCapacity
                }
            }
            @discardableResult
            public func setCapacity(_ value:Int64) -> Lnrpc.ChannelCloseSummary.Builder {
                self.capacity = value
                return self
            }
            @discardableResult
            public func clearCapacity() -> Lnrpc.ChannelCloseSummary.Builder{
                builderResult.hasCapacity = false
                builderResult.capacity = nil
                return self
            }
            //// Height at which the funding transaction was spent.
            public var closeHeight:UInt32 {
                get {
                    return builderResult.closeHeight
                }
                set (value) {
                    builderResult.hasCloseHeight = true
                    builderResult.closeHeight = value
                }
            }
            public var hasCloseHeight:Bool {
                get {
                    return builderResult.hasCloseHeight
                }
            }
            @discardableResult
            public func setCloseHeight(_ value:UInt32) -> Lnrpc.ChannelCloseSummary.Builder {
                self.closeHeight = value
                return self
            }
            @discardableResult
            public func clearCloseHeight() -> Lnrpc.ChannelCloseSummary.Builder{
                builderResult.hasCloseHeight = false
                builderResult.closeHeight = nil
                return self
            }
            //// Settled balance at the time of channel closure
            public var settledBalance:Int64 {
                get {
                    return builderResult.settledBalance
                }
                set (value) {
                    builderResult.hasSettledBalance = true
                    builderResult.settledBalance = value
                }
            }
            public var hasSettledBalance:Bool {
                get {
                    return builderResult.hasSettledBalance
                }
            }
            @discardableResult
            public func setSettledBalance(_ value:Int64) -> Lnrpc.ChannelCloseSummary.Builder {
                self.settledBalance = value
                return self
            }
            @discardableResult
            public func clearSettledBalance() -> Lnrpc.ChannelCloseSummary.Builder{
                builderResult.hasSettledBalance = false
                builderResult.settledBalance = nil
                return self
            }
            //// The sum of all the time-locked outputs at the time of channel closure
            public var timeLockedBalance:Int64 {
                get {
                    return builderResult.timeLockedBalance
                }
                set (value) {
                    builderResult.hasTimeLockedBalance = true
                    builderResult.timeLockedBalance = value
                }
            }
            public var hasTimeLockedBalance:Bool {
                get {
                    return builderResult.hasTimeLockedBalance
                }
            }
            @discardableResult
            public func setTimeLockedBalance(_ value:Int64) -> Lnrpc.ChannelCloseSummary.Builder {
                self.timeLockedBalance = value
                return self
            }
            @discardableResult
            public func clearTimeLockedBalance() -> Lnrpc.ChannelCloseSummary.Builder{
                builderResult.hasTimeLockedBalance = false
                builderResult.timeLockedBalance = nil
                return self
            }
            //// Details on how the channel was closed.
                public var closeType:Lnrpc.ChannelCloseSummary.ClosureType {
                    get {
                        return builderResult.closeType
                    }
                    set (value) {
                        builderResult.hasCloseType = true
                        builderResult.closeType = value
                    }
                }
                public var hasCloseType:Bool{
                    get {
                        return builderResult.hasCloseType
                    }
                }
            @discardableResult
                public func setCloseType(_ value:Lnrpc.ChannelCloseSummary.ClosureType) -> Lnrpc.ChannelCloseSummary.Builder {
                  self.closeType = value
                  return self
                }
            @discardableResult
                public func clearCloseType() -> Lnrpc.ChannelCloseSummary.Builder {
                   builderResult.hasCloseType = false
                   builderResult.closeType = .cooperativeClose
                   return self
                }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ChannelCloseSummary.Builder {
                builderResult = Lnrpc.ChannelCloseSummary()
                return self
            }
            override public func clone() throws -> Lnrpc.ChannelCloseSummary.Builder {
                return try Lnrpc.ChannelCloseSummary.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ChannelCloseSummary {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ChannelCloseSummary {
                let returnMe:Lnrpc.ChannelCloseSummary = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ChannelCloseSummary) throws -> Lnrpc.ChannelCloseSummary.Builder {
                if other == Lnrpc.ChannelCloseSummary() {
                    return self
                }
                if other.hasChannelPoint {
                    channelPoint = other.channelPoint
                }
                if other.hasChanId {
                    chanId = other.chanId
                }
                if other.hasChainHash {
                    chainHash = other.chainHash
                }
                if other.hasClosingTxHash {
                    closingTxHash = other.closingTxHash
                }
                if other.hasRemotePubkey {
                    remotePubkey = other.remotePubkey
                }
                if other.hasCapacity {
                    capacity = other.capacity
                }
                if other.hasCloseHeight {
                    closeHeight = other.closeHeight
                }
                if other.hasSettledBalance {
                    settledBalance = other.settledBalance
                }
                if other.hasTimeLockedBalance {
                    timeLockedBalance = other.timeLockedBalance
                }
                if other.hasCloseType {
                    closeType = other.closeType
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChannelCloseSummary.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelCloseSummary.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        channelPoint = try codedInputStream.readString()

                    case 16:
                        chanId = try codedInputStream.readUInt64()

                    case 26:
                        chainHash = try codedInputStream.readString()

                    case 34:
                        closingTxHash = try codedInputStream.readString()

                    case 42:
                        remotePubkey = try codedInputStream.readString()

                    case 48:
                        capacity = try codedInputStream.readInt64()

                    case 56:
                        closeHeight = try codedInputStream.readUInt32()

                    case 64:
                        settledBalance = try codedInputStream.readInt64()

                    case 72:
                        timeLockedBalance = try codedInputStream.readInt64()

                    case 80:
                        let valueIntcloseType = try codedInputStream.readEnum()
                        if let enumscloseType = Lnrpc.ChannelCloseSummary.ClosureType(rawValue:valueIntcloseType){
                            closeType = enumscloseType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 10, value:Int64(valueIntcloseType))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChannelCloseSummary.Builder {
                let resultDecodedBuilder = Lnrpc.ChannelCloseSummary.Builder()
                if let jsonValueChannelPoint = jsonMap["channel_point"] as? String {
                    resultDecodedBuilder.channelPoint = jsonValueChannelPoint
                }
                if let jsonValueChanId = jsonMap["chan_id"] as? String {
                    resultDecodedBuilder.chanId = UInt64(jsonValueChanId)!
                } else if let jsonValueChanId = jsonMap["chan_id"] as? UInt {
                    resultDecodedBuilder.chanId = UInt64(jsonValueChanId)
                }
                if let jsonValueChainHash = jsonMap["chain_hash"] as? String {
                    resultDecodedBuilder.chainHash = jsonValueChainHash
                }
                if let jsonValueClosingTxHash = jsonMap["closing_tx_hash"] as? String {
                    resultDecodedBuilder.closingTxHash = jsonValueClosingTxHash
                }
                if let jsonValueRemotePubkey = jsonMap["remote_pubkey"] as? String {
                    resultDecodedBuilder.remotePubkey = jsonValueRemotePubkey
                }
                if let jsonValueCapacity = jsonMap["capacity"] as? String {
                    resultDecodedBuilder.capacity = Int64(jsonValueCapacity)!
                } else if let jsonValueCapacity = jsonMap["capacity"] as? Int {
                    resultDecodedBuilder.capacity = Int64(jsonValueCapacity)
                }
                if let jsonValueCloseHeight = jsonMap["close_height"] as? UInt {
                    resultDecodedBuilder.closeHeight = UInt32(jsonValueCloseHeight)
                } else if let jsonValueCloseHeight = jsonMap["close_height"] as? String {
                    resultDecodedBuilder.closeHeight = UInt32(jsonValueCloseHeight)!
                }
                if let jsonValueSettledBalance = jsonMap["settled_balance"] as? String {
                    resultDecodedBuilder.settledBalance = Int64(jsonValueSettledBalance)!
                } else if let jsonValueSettledBalance = jsonMap["settled_balance"] as? Int {
                    resultDecodedBuilder.settledBalance = Int64(jsonValueSettledBalance)
                }
                if let jsonValueTimeLockedBalance = jsonMap["time_locked_balance"] as? String {
                    resultDecodedBuilder.timeLockedBalance = Int64(jsonValueTimeLockedBalance)!
                } else if let jsonValueTimeLockedBalance = jsonMap["time_locked_balance"] as? Int {
                    resultDecodedBuilder.timeLockedBalance = Int64(jsonValueTimeLockedBalance)
                }
                if let jsonValueCloseType = jsonMap["close_type"] as? String {
                    resultDecodedBuilder.closeType = try Lnrpc.ChannelCloseSummary.ClosureType.fromString(jsonValueCloseType)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChannelCloseSummary.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ChannelCloseSummary.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ClosedChannelsRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ClosedChannelsRequest.Builder

        public static func == (lhs: Lnrpc.ClosedChannelsRequest, rhs: Lnrpc.ClosedChannelsRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasCooperative == rhs.hasCooperative) && (!lhs.hasCooperative || lhs.cooperative == rhs.cooperative)
            fieldCheck = fieldCheck && (lhs.hasLocalForce == rhs.hasLocalForce) && (!lhs.hasLocalForce || lhs.localForce == rhs.localForce)
            fieldCheck = fieldCheck && (lhs.hasRemoteForce == rhs.hasRemoteForce) && (!lhs.hasRemoteForce || lhs.remoteForce == rhs.remoteForce)
            fieldCheck = fieldCheck && (lhs.hasBreach == rhs.hasBreach) && (!lhs.hasBreach || lhs.breach == rhs.breach)
            fieldCheck = fieldCheck && (lhs.hasFundingCanceled == rhs.hasFundingCanceled) && (!lhs.hasFundingCanceled || lhs.fundingCanceled == rhs.fundingCanceled)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var cooperative:Bool! = nil
        public fileprivate(set) var hasCooperative:Bool = false

        public fileprivate(set) var localForce:Bool! = nil
        public fileprivate(set) var hasLocalForce:Bool = false

        public fileprivate(set) var remoteForce:Bool! = nil
        public fileprivate(set) var hasRemoteForce:Bool = false

        public fileprivate(set) var breach:Bool! = nil
        public fileprivate(set) var hasBreach:Bool = false

        public fileprivate(set) var fundingCanceled:Bool! = nil
        public fileprivate(set) var hasFundingCanceled:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasCooperative {
                try codedOutputStream.writeBool(fieldNumber: 1, value:cooperative)
            }
            if hasLocalForce {
                try codedOutputStream.writeBool(fieldNumber: 2, value:localForce)
            }
            if hasRemoteForce {
                try codedOutputStream.writeBool(fieldNumber: 3, value:remoteForce)
            }
            if hasBreach {
                try codedOutputStream.writeBool(fieldNumber: 4, value:breach)
            }
            if hasFundingCanceled {
                try codedOutputStream.writeBool(fieldNumber: 5, value:fundingCanceled)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasCooperative {
                serialize_size += cooperative.computeBoolSize(fieldNumber: 1)
            }
            if hasLocalForce {
                serialize_size += localForce.computeBoolSize(fieldNumber: 2)
            }
            if hasRemoteForce {
                serialize_size += remoteForce.computeBoolSize(fieldNumber: 3)
            }
            if hasBreach {
                serialize_size += breach.computeBoolSize(fieldNumber: 4)
            }
            if hasFundingCanceled {
                serialize_size += fundingCanceled.computeBoolSize(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ClosedChannelsRequest.Builder {
            return Lnrpc.ClosedChannelsRequest.classBuilder() as! Lnrpc.ClosedChannelsRequest.Builder
        }
        public func getBuilder() -> Lnrpc.ClosedChannelsRequest.Builder {
            return classBuilder() as! Lnrpc.ClosedChannelsRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ClosedChannelsRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ClosedChannelsRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ClosedChannelsRequest.Builder {
            return try Lnrpc.ClosedChannelsRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ClosedChannelsRequest) throws -> Lnrpc.ClosedChannelsRequest.Builder {
            return try Lnrpc.ClosedChannelsRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasCooperative {
                jsonMap["cooperative"] = cooperative
            }
            if hasLocalForce {
                jsonMap["localForce"] = localForce
            }
            if hasRemoteForce {
                jsonMap["remoteForce"] = remoteForce
            }
            if hasBreach {
                jsonMap["breach"] = breach
            }
            if hasFundingCanceled {
                jsonMap["fundingCanceled"] = fundingCanceled
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ClosedChannelsRequest {
            return try Lnrpc.ClosedChannelsRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ClosedChannelsRequest {
            return try Lnrpc.ClosedChannelsRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasCooperative {
                output += "\(indent) cooperative: \(cooperative) \n"
            }
            if hasLocalForce {
                output += "\(indent) localForce: \(localForce) \n"
            }
            if hasRemoteForce {
                output += "\(indent) remoteForce: \(remoteForce) \n"
            }
            if hasBreach {
                output += "\(indent) breach: \(breach) \n"
            }
            if hasFundingCanceled {
                output += "\(indent) fundingCanceled: \(fundingCanceled) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasCooperative {
                    hashCode = (hashCode &* 31) &+ cooperative.hashValue
                }
                if hasLocalForce {
                    hashCode = (hashCode &* 31) &+ localForce.hashValue
                }
                if hasRemoteForce {
                    hashCode = (hashCode &* 31) &+ remoteForce.hashValue
                }
                if hasBreach {
                    hashCode = (hashCode &* 31) &+ breach.hashValue
                }
                if hasFundingCanceled {
                    hashCode = (hashCode &* 31) &+ fundingCanceled.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ClosedChannelsRequest"
        }
        override public func className() -> String {
            return "Lnrpc.ClosedChannelsRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ClosedChannelsRequest = Lnrpc.ClosedChannelsRequest()
            public func getMessage() -> Lnrpc.ClosedChannelsRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var cooperative:Bool {
                get {
                    return builderResult.cooperative
                }
                set (value) {
                    builderResult.hasCooperative = true
                    builderResult.cooperative = value
                }
            }
            public var hasCooperative:Bool {
                get {
                    return builderResult.hasCooperative
                }
            }
            @discardableResult
            public func setCooperative(_ value:Bool) -> Lnrpc.ClosedChannelsRequest.Builder {
                self.cooperative = value
                return self
            }
            @discardableResult
            public func clearCooperative() -> Lnrpc.ClosedChannelsRequest.Builder{
                builderResult.hasCooperative = false
                builderResult.cooperative = nil
                return self
            }
            public var localForce:Bool {
                get {
                    return builderResult.localForce
                }
                set (value) {
                    builderResult.hasLocalForce = true
                    builderResult.localForce = value
                }
            }
            public var hasLocalForce:Bool {
                get {
                    return builderResult.hasLocalForce
                }
            }
            @discardableResult
            public func setLocalForce(_ value:Bool) -> Lnrpc.ClosedChannelsRequest.Builder {
                self.localForce = value
                return self
            }
            @discardableResult
            public func clearLocalForce() -> Lnrpc.ClosedChannelsRequest.Builder{
                builderResult.hasLocalForce = false
                builderResult.localForce = nil
                return self
            }
            public var remoteForce:Bool {
                get {
                    return builderResult.remoteForce
                }
                set (value) {
                    builderResult.hasRemoteForce = true
                    builderResult.remoteForce = value
                }
            }
            public var hasRemoteForce:Bool {
                get {
                    return builderResult.hasRemoteForce
                }
            }
            @discardableResult
            public func setRemoteForce(_ value:Bool) -> Lnrpc.ClosedChannelsRequest.Builder {
                self.remoteForce = value
                return self
            }
            @discardableResult
            public func clearRemoteForce() -> Lnrpc.ClosedChannelsRequest.Builder{
                builderResult.hasRemoteForce = false
                builderResult.remoteForce = nil
                return self
            }
            public var breach:Bool {
                get {
                    return builderResult.breach
                }
                set (value) {
                    builderResult.hasBreach = true
                    builderResult.breach = value
                }
            }
            public var hasBreach:Bool {
                get {
                    return builderResult.hasBreach
                }
            }
            @discardableResult
            public func setBreach(_ value:Bool) -> Lnrpc.ClosedChannelsRequest.Builder {
                self.breach = value
                return self
            }
            @discardableResult
            public func clearBreach() -> Lnrpc.ClosedChannelsRequest.Builder{
                builderResult.hasBreach = false
                builderResult.breach = nil
                return self
            }
            public var fundingCanceled:Bool {
                get {
                    return builderResult.fundingCanceled
                }
                set (value) {
                    builderResult.hasFundingCanceled = true
                    builderResult.fundingCanceled = value
                }
            }
            public var hasFundingCanceled:Bool {
                get {
                    return builderResult.hasFundingCanceled
                }
            }
            @discardableResult
            public func setFundingCanceled(_ value:Bool) -> Lnrpc.ClosedChannelsRequest.Builder {
                self.fundingCanceled = value
                return self
            }
            @discardableResult
            public func clearFundingCanceled() -> Lnrpc.ClosedChannelsRequest.Builder{
                builderResult.hasFundingCanceled = false
                builderResult.fundingCanceled = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ClosedChannelsRequest.Builder {
                builderResult = Lnrpc.ClosedChannelsRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.ClosedChannelsRequest.Builder {
                return try Lnrpc.ClosedChannelsRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ClosedChannelsRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ClosedChannelsRequest {
                let returnMe:Lnrpc.ClosedChannelsRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ClosedChannelsRequest) throws -> Lnrpc.ClosedChannelsRequest.Builder {
                if other == Lnrpc.ClosedChannelsRequest() {
                    return self
                }
                if other.hasCooperative {
                    cooperative = other.cooperative
                }
                if other.hasLocalForce {
                    localForce = other.localForce
                }
                if other.hasRemoteForce {
                    remoteForce = other.remoteForce
                }
                if other.hasBreach {
                    breach = other.breach
                }
                if other.hasFundingCanceled {
                    fundingCanceled = other.fundingCanceled
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ClosedChannelsRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ClosedChannelsRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        cooperative = try codedInputStream.readBool()

                    case 16:
                        localForce = try codedInputStream.readBool()

                    case 24:
                        remoteForce = try codedInputStream.readBool()

                    case 32:
                        breach = try codedInputStream.readBool()

                    case 40:
                        fundingCanceled = try codedInputStream.readBool()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ClosedChannelsRequest.Builder {
                let resultDecodedBuilder = Lnrpc.ClosedChannelsRequest.Builder()
                if let jsonValueCooperative = jsonMap["cooperative"] as? Bool {
                    resultDecodedBuilder.cooperative = jsonValueCooperative
                }
                if let jsonValueLocalForce = jsonMap["localForce"] as? Bool {
                    resultDecodedBuilder.localForce = jsonValueLocalForce
                }
                if let jsonValueRemoteForce = jsonMap["remoteForce"] as? Bool {
                    resultDecodedBuilder.remoteForce = jsonValueRemoteForce
                }
                if let jsonValueBreach = jsonMap["breach"] as? Bool {
                    resultDecodedBuilder.breach = jsonValueBreach
                }
                if let jsonValueFundingCanceled = jsonMap["fundingCanceled"] as? Bool {
                    resultDecodedBuilder.fundingCanceled = jsonValueFundingCanceled
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ClosedChannelsRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ClosedChannelsRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ClosedChannelsResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ClosedChannelsResponse.Builder

        public static func == (lhs: Lnrpc.ClosedChannelsResponse, rhs: Lnrpc.ClosedChannelsResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.channels == rhs.channels)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var channels:Array<Lnrpc.ChannelCloseSummary>  = Array<Lnrpc.ChannelCloseSummary>()
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementChannels in channels {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementChannels)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementChannels in channels {
                serialize_size += oneElementChannels.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ClosedChannelsResponse.Builder {
            return Lnrpc.ClosedChannelsResponse.classBuilder() as! Lnrpc.ClosedChannelsResponse.Builder
        }
        public func getBuilder() -> Lnrpc.ClosedChannelsResponse.Builder {
            return classBuilder() as! Lnrpc.ClosedChannelsResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ClosedChannelsResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ClosedChannelsResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ClosedChannelsResponse.Builder {
            return try Lnrpc.ClosedChannelsResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ClosedChannelsResponse) throws -> Lnrpc.ClosedChannelsResponse.Builder {
            return try Lnrpc.ClosedChannelsResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !channels.isEmpty {
                var jsonArrayChannels:Array<Dictionary<String,Any>> = []
                for oneValueChannels in channels {
                    let ecodedMessageChannels = try oneValueChannels.encode()
                    jsonArrayChannels.append(ecodedMessageChannels)
                }
                jsonMap["channels"] = jsonArrayChannels
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ClosedChannelsResponse {
            return try Lnrpc.ClosedChannelsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ClosedChannelsResponse {
            return try Lnrpc.ClosedChannelsResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var channelsElementIndex:Int = 0
            for oneElementChannels in channels {
                output += "\(indent) channels[\(channelsElementIndex)] {\n"
                output += try oneElementChannels.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                channelsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementChannels in channels {
                    hashCode = (hashCode &* 31) &+ oneElementChannels.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ClosedChannelsResponse"
        }
        override public func className() -> String {
            return "Lnrpc.ClosedChannelsResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ClosedChannelsResponse = Lnrpc.ClosedChannelsResponse()
            public func getMessage() -> Lnrpc.ClosedChannelsResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var channels:Array<Lnrpc.ChannelCloseSummary> {
                get {
                    return builderResult.channels
                }
                set (value) {
                    builderResult.channels = value
                }
            }
            @discardableResult
            public func setChannels(_ value:Array<Lnrpc.ChannelCloseSummary>) -> Lnrpc.ClosedChannelsResponse.Builder {
                self.channels = value
                return self
            }
            @discardableResult
            public func clearChannels() -> Lnrpc.ClosedChannelsResponse.Builder {
                builderResult.channels.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ClosedChannelsResponse.Builder {
                builderResult = Lnrpc.ClosedChannelsResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.ClosedChannelsResponse.Builder {
                return try Lnrpc.ClosedChannelsResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ClosedChannelsResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ClosedChannelsResponse {
                let returnMe:Lnrpc.ClosedChannelsResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ClosedChannelsResponse) throws -> Lnrpc.ClosedChannelsResponse.Builder {
                if other == Lnrpc.ClosedChannelsResponse() {
                    return self
                }
                if !other.channels.isEmpty  {
                     builderResult.channels += other.channels
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ClosedChannelsResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ClosedChannelsResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Lnrpc.ChannelCloseSummary.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        channels.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ClosedChannelsResponse.Builder {
                let resultDecodedBuilder = Lnrpc.ClosedChannelsResponse.Builder()
                if let jsonValueChannels = jsonMap["channels"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayChannels:Array<Lnrpc.ChannelCloseSummary> = []
                    for oneValueChannels in jsonValueChannels {
                        let messageFromStringChannels = try Lnrpc.ChannelCloseSummary.Builder.decodeToBuilder(jsonMap:oneValueChannels).build()

                        jsonArrayChannels.append(messageFromStringChannels)
                    }
                    resultDecodedBuilder.channels = jsonArrayChannels
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ClosedChannelsResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ClosedChannelsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class Peer : GeneratedMessage {
        public typealias BuilderType = Lnrpc.Peer.Builder

        public static func == (lhs: Lnrpc.Peer, rhs: Lnrpc.Peer) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasPubKey == rhs.hasPubKey) && (!lhs.hasPubKey || lhs.pubKey == rhs.pubKey)
            fieldCheck = fieldCheck && (lhs.hasAddress == rhs.hasAddress) && (!lhs.hasAddress || lhs.address == rhs.address)
            fieldCheck = fieldCheck && (lhs.hasBytesSent == rhs.hasBytesSent) && (!lhs.hasBytesSent || lhs.bytesSent == rhs.bytesSent)
            fieldCheck = fieldCheck && (lhs.hasBytesRecv == rhs.hasBytesRecv) && (!lhs.hasBytesRecv || lhs.bytesRecv == rhs.bytesRecv)
            fieldCheck = fieldCheck && (lhs.hasSatSent == rhs.hasSatSent) && (!lhs.hasSatSent || lhs.satSent == rhs.satSent)
            fieldCheck = fieldCheck && (lhs.hasSatRecv == rhs.hasSatRecv) && (!lhs.hasSatRecv || lhs.satRecv == rhs.satRecv)
            fieldCheck = fieldCheck && (lhs.hasInbound == rhs.hasInbound) && (!lhs.hasInbound || lhs.inbound == rhs.inbound)
            fieldCheck = fieldCheck && (lhs.hasPingTime == rhs.hasPingTime) && (!lhs.hasPingTime || lhs.pingTime == rhs.pingTime)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// The identity pubkey of the peer
        public fileprivate(set) var pubKey:String! = nil
        public fileprivate(set) var hasPubKey:Bool = false

        //// Network address of the peer; eg `127.0.0.1:10011`
        public fileprivate(set) var address:String! = nil
        public fileprivate(set) var hasAddress:Bool = false

        //// Bytes of data transmitted to this peer
        public fileprivate(set) var bytesSent:UInt64! = nil
        public fileprivate(set) var hasBytesSent:Bool = false

        //// Bytes of data transmitted from this peer
        public fileprivate(set) var bytesRecv:UInt64! = nil
        public fileprivate(set) var hasBytesRecv:Bool = false

        //// Satoshis sent to this peer
        public fileprivate(set) var satSent:Int64! = nil
        public fileprivate(set) var hasSatSent:Bool = false

        //// Satoshis received from this peer
        public fileprivate(set) var satRecv:Int64! = nil
        public fileprivate(set) var hasSatRecv:Bool = false

        //// A channel is inbound if the counterparty initiated the channel
        public fileprivate(set) var inbound:Bool! = nil
        public fileprivate(set) var hasInbound:Bool = false

        //// Ping time to this peer
        public fileprivate(set) var pingTime:Int64! = nil
        public fileprivate(set) var hasPingTime:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasPubKey {
                try codedOutputStream.writeString(fieldNumber: 1, value:pubKey)
            }
            if hasAddress {
                try codedOutputStream.writeString(fieldNumber: 3, value:address)
            }
            if hasBytesSent {
                try codedOutputStream.writeUInt64(fieldNumber: 4, value:bytesSent)
            }
            if hasBytesRecv {
                try codedOutputStream.writeUInt64(fieldNumber: 5, value:bytesRecv)
            }
            if hasSatSent {
                try codedOutputStream.writeInt64(fieldNumber: 6, value:satSent)
            }
            if hasSatRecv {
                try codedOutputStream.writeInt64(fieldNumber: 7, value:satRecv)
            }
            if hasInbound {
                try codedOutputStream.writeBool(fieldNumber: 8, value:inbound)
            }
            if hasPingTime {
                try codedOutputStream.writeInt64(fieldNumber: 9, value:pingTime)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasPubKey {
                serialize_size += pubKey.computeStringSize(fieldNumber: 1)
            }
            if hasAddress {
                serialize_size += address.computeStringSize(fieldNumber: 3)
            }
            if hasBytesSent {
                serialize_size += bytesSent.computeUInt64Size(fieldNumber: 4)
            }
            if hasBytesRecv {
                serialize_size += bytesRecv.computeUInt64Size(fieldNumber: 5)
            }
            if hasSatSent {
                serialize_size += satSent.computeInt64Size(fieldNumber: 6)
            }
            if hasSatRecv {
                serialize_size += satRecv.computeInt64Size(fieldNumber: 7)
            }
            if hasInbound {
                serialize_size += inbound.computeBoolSize(fieldNumber: 8)
            }
            if hasPingTime {
                serialize_size += pingTime.computeInt64Size(fieldNumber: 9)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.Peer.Builder {
            return Lnrpc.Peer.classBuilder() as! Lnrpc.Peer.Builder
        }
        public func getBuilder() -> Lnrpc.Peer.Builder {
            return classBuilder() as! Lnrpc.Peer.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.Peer.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.Peer.Builder()
        }
        public func toBuilder() throws -> Lnrpc.Peer.Builder {
            return try Lnrpc.Peer.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.Peer) throws -> Lnrpc.Peer.Builder {
            return try Lnrpc.Peer.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasPubKey {
                jsonMap["pub_key"] = pubKey
            }
            if hasAddress {
                jsonMap["address"] = address
            }
            if hasBytesSent {
                jsonMap["bytes_sent"] = "\(bytesSent!)"
            }
            if hasBytesRecv {
                jsonMap["bytes_recv"] = "\(bytesRecv!)"
            }
            if hasSatSent {
                jsonMap["sat_sent"] = "\(satSent!)"
            }
            if hasSatRecv {
                jsonMap["sat_recv"] = "\(satRecv!)"
            }
            if hasInbound {
                jsonMap["inbound"] = inbound
            }
            if hasPingTime {
                jsonMap["ping_time"] = "\(pingTime!)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.Peer {
            return try Lnrpc.Peer.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.Peer {
            return try Lnrpc.Peer.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasPubKey {
                output += "\(indent) pubKey: \(pubKey) \n"
            }
            if hasAddress {
                output += "\(indent) address: \(address) \n"
            }
            if hasBytesSent {
                output += "\(indent) bytesSent: \(bytesSent) \n"
            }
            if hasBytesRecv {
                output += "\(indent) bytesRecv: \(bytesRecv) \n"
            }
            if hasSatSent {
                output += "\(indent) satSent: \(satSent) \n"
            }
            if hasSatRecv {
                output += "\(indent) satRecv: \(satRecv) \n"
            }
            if hasInbound {
                output += "\(indent) inbound: \(inbound) \n"
            }
            if hasPingTime {
                output += "\(indent) pingTime: \(pingTime) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasPubKey {
                    hashCode = (hashCode &* 31) &+ pubKey.hashValue
                }
                if hasAddress {
                    hashCode = (hashCode &* 31) &+ address.hashValue
                }
                if hasBytesSent {
                    hashCode = (hashCode &* 31) &+ bytesSent.hashValue
                }
                if hasBytesRecv {
                    hashCode = (hashCode &* 31) &+ bytesRecv.hashValue
                }
                if hasSatSent {
                    hashCode = (hashCode &* 31) &+ satSent.hashValue
                }
                if hasSatRecv {
                    hashCode = (hashCode &* 31) &+ satRecv.hashValue
                }
                if hasInbound {
                    hashCode = (hashCode &* 31) &+ inbound.hashValue
                }
                if hasPingTime {
                    hashCode = (hashCode &* 31) &+ pingTime.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.Peer"
        }
        override public func className() -> String {
            return "Lnrpc.Peer"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.Peer = Lnrpc.Peer()
            public func getMessage() -> Lnrpc.Peer {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The identity pubkey of the peer
            public var pubKey:String {
                get {
                    return builderResult.pubKey
                }
                set (value) {
                    builderResult.hasPubKey = true
                    builderResult.pubKey = value
                }
            }
            public var hasPubKey:Bool {
                get {
                    return builderResult.hasPubKey
                }
            }
            @discardableResult
            public func setPubKey(_ value:String) -> Lnrpc.Peer.Builder {
                self.pubKey = value
                return self
            }
            @discardableResult
            public func clearPubKey() -> Lnrpc.Peer.Builder{
                builderResult.hasPubKey = false
                builderResult.pubKey = nil
                return self
            }
            //// Network address of the peer; eg `127.0.0.1:10011`
            public var address:String {
                get {
                    return builderResult.address
                }
                set (value) {
                    builderResult.hasAddress = true
                    builderResult.address = value
                }
            }
            public var hasAddress:Bool {
                get {
                    return builderResult.hasAddress
                }
            }
            @discardableResult
            public func setAddress(_ value:String) -> Lnrpc.Peer.Builder {
                self.address = value
                return self
            }
            @discardableResult
            public func clearAddress() -> Lnrpc.Peer.Builder{
                builderResult.hasAddress = false
                builderResult.address = nil
                return self
            }
            //// Bytes of data transmitted to this peer
            public var bytesSent:UInt64 {
                get {
                    return builderResult.bytesSent
                }
                set (value) {
                    builderResult.hasBytesSent = true
                    builderResult.bytesSent = value
                }
            }
            public var hasBytesSent:Bool {
                get {
                    return builderResult.hasBytesSent
                }
            }
            @discardableResult
            public func setBytesSent(_ value:UInt64) -> Lnrpc.Peer.Builder {
                self.bytesSent = value
                return self
            }
            @discardableResult
            public func clearBytesSent() -> Lnrpc.Peer.Builder{
                builderResult.hasBytesSent = false
                builderResult.bytesSent = nil
                return self
            }
            //// Bytes of data transmitted from this peer
            public var bytesRecv:UInt64 {
                get {
                    return builderResult.bytesRecv
                }
                set (value) {
                    builderResult.hasBytesRecv = true
                    builderResult.bytesRecv = value
                }
            }
            public var hasBytesRecv:Bool {
                get {
                    return builderResult.hasBytesRecv
                }
            }
            @discardableResult
            public func setBytesRecv(_ value:UInt64) -> Lnrpc.Peer.Builder {
                self.bytesRecv = value
                return self
            }
            @discardableResult
            public func clearBytesRecv() -> Lnrpc.Peer.Builder{
                builderResult.hasBytesRecv = false
                builderResult.bytesRecv = nil
                return self
            }
            //// Satoshis sent to this peer
            public var satSent:Int64 {
                get {
                    return builderResult.satSent
                }
                set (value) {
                    builderResult.hasSatSent = true
                    builderResult.satSent = value
                }
            }
            public var hasSatSent:Bool {
                get {
                    return builderResult.hasSatSent
                }
            }
            @discardableResult
            public func setSatSent(_ value:Int64) -> Lnrpc.Peer.Builder {
                self.satSent = value
                return self
            }
            @discardableResult
            public func clearSatSent() -> Lnrpc.Peer.Builder{
                builderResult.hasSatSent = false
                builderResult.satSent = nil
                return self
            }
            //// Satoshis received from this peer
            public var satRecv:Int64 {
                get {
                    return builderResult.satRecv
                }
                set (value) {
                    builderResult.hasSatRecv = true
                    builderResult.satRecv = value
                }
            }
            public var hasSatRecv:Bool {
                get {
                    return builderResult.hasSatRecv
                }
            }
            @discardableResult
            public func setSatRecv(_ value:Int64) -> Lnrpc.Peer.Builder {
                self.satRecv = value
                return self
            }
            @discardableResult
            public func clearSatRecv() -> Lnrpc.Peer.Builder{
                builderResult.hasSatRecv = false
                builderResult.satRecv = nil
                return self
            }
            //// A channel is inbound if the counterparty initiated the channel
            public var inbound:Bool {
                get {
                    return builderResult.inbound
                }
                set (value) {
                    builderResult.hasInbound = true
                    builderResult.inbound = value
                }
            }
            public var hasInbound:Bool {
                get {
                    return builderResult.hasInbound
                }
            }
            @discardableResult
            public func setInbound(_ value:Bool) -> Lnrpc.Peer.Builder {
                self.inbound = value
                return self
            }
            @discardableResult
            public func clearInbound() -> Lnrpc.Peer.Builder{
                builderResult.hasInbound = false
                builderResult.inbound = nil
                return self
            }
            //// Ping time to this peer
            public var pingTime:Int64 {
                get {
                    return builderResult.pingTime
                }
                set (value) {
                    builderResult.hasPingTime = true
                    builderResult.pingTime = value
                }
            }
            public var hasPingTime:Bool {
                get {
                    return builderResult.hasPingTime
                }
            }
            @discardableResult
            public func setPingTime(_ value:Int64) -> Lnrpc.Peer.Builder {
                self.pingTime = value
                return self
            }
            @discardableResult
            public func clearPingTime() -> Lnrpc.Peer.Builder{
                builderResult.hasPingTime = false
                builderResult.pingTime = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.Peer.Builder {
                builderResult = Lnrpc.Peer()
                return self
            }
            override public func clone() throws -> Lnrpc.Peer.Builder {
                return try Lnrpc.Peer.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.Peer {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.Peer {
                let returnMe:Lnrpc.Peer = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.Peer) throws -> Lnrpc.Peer.Builder {
                if other == Lnrpc.Peer() {
                    return self
                }
                if other.hasPubKey {
                    pubKey = other.pubKey
                }
                if other.hasAddress {
                    address = other.address
                }
                if other.hasBytesSent {
                    bytesSent = other.bytesSent
                }
                if other.hasBytesRecv {
                    bytesRecv = other.bytesRecv
                }
                if other.hasSatSent {
                    satSent = other.satSent
                }
                if other.hasSatRecv {
                    satRecv = other.satRecv
                }
                if other.hasInbound {
                    inbound = other.inbound
                }
                if other.hasPingTime {
                    pingTime = other.pingTime
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.Peer.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Peer.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        pubKey = try codedInputStream.readString()

                    case 26:
                        address = try codedInputStream.readString()

                    case 32:
                        bytesSent = try codedInputStream.readUInt64()

                    case 40:
                        bytesRecv = try codedInputStream.readUInt64()

                    case 48:
                        satSent = try codedInputStream.readInt64()

                    case 56:
                        satRecv = try codedInputStream.readInt64()

                    case 64:
                        inbound = try codedInputStream.readBool()

                    case 72:
                        pingTime = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.Peer.Builder {
                let resultDecodedBuilder = Lnrpc.Peer.Builder()
                if let jsonValuePubKey = jsonMap["pub_key"] as? String {
                    resultDecodedBuilder.pubKey = jsonValuePubKey
                }
                if let jsonValueAddress = jsonMap["address"] as? String {
                    resultDecodedBuilder.address = jsonValueAddress
                }
                if let jsonValueBytesSent = jsonMap["bytes_sent"] as? String {
                    resultDecodedBuilder.bytesSent = UInt64(jsonValueBytesSent)!
                } else if let jsonValueBytesSent = jsonMap["bytes_sent"] as? UInt {
                    resultDecodedBuilder.bytesSent = UInt64(jsonValueBytesSent)
                }
                if let jsonValueBytesRecv = jsonMap["bytes_recv"] as? String {
                    resultDecodedBuilder.bytesRecv = UInt64(jsonValueBytesRecv)!
                } else if let jsonValueBytesRecv = jsonMap["bytes_recv"] as? UInt {
                    resultDecodedBuilder.bytesRecv = UInt64(jsonValueBytesRecv)
                }
                if let jsonValueSatSent = jsonMap["sat_sent"] as? String {
                    resultDecodedBuilder.satSent = Int64(jsonValueSatSent)!
                } else if let jsonValueSatSent = jsonMap["sat_sent"] as? Int {
                    resultDecodedBuilder.satSent = Int64(jsonValueSatSent)
                }
                if let jsonValueSatRecv = jsonMap["sat_recv"] as? String {
                    resultDecodedBuilder.satRecv = Int64(jsonValueSatRecv)!
                } else if let jsonValueSatRecv = jsonMap["sat_recv"] as? Int {
                    resultDecodedBuilder.satRecv = Int64(jsonValueSatRecv)
                }
                if let jsonValueInbound = jsonMap["inbound"] as? Bool {
                    resultDecodedBuilder.inbound = jsonValueInbound
                }
                if let jsonValuePingTime = jsonMap["ping_time"] as? String {
                    resultDecodedBuilder.pingTime = Int64(jsonValuePingTime)!
                } else if let jsonValuePingTime = jsonMap["ping_time"] as? Int {
                    resultDecodedBuilder.pingTime = Int64(jsonValuePingTime)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.Peer.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.Peer.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ListPeersRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ListPeersRequest.Builder

        public static func == (lhs: Lnrpc.ListPeersRequest, rhs: Lnrpc.ListPeersRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ListPeersRequest.Builder {
            return Lnrpc.ListPeersRequest.classBuilder() as! Lnrpc.ListPeersRequest.Builder
        }
        public func getBuilder() -> Lnrpc.ListPeersRequest.Builder {
            return classBuilder() as! Lnrpc.ListPeersRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ListPeersRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ListPeersRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ListPeersRequest.Builder {
            return try Lnrpc.ListPeersRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ListPeersRequest) throws -> Lnrpc.ListPeersRequest.Builder {
            return try Lnrpc.ListPeersRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ListPeersRequest {
            return try Lnrpc.ListPeersRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ListPeersRequest {
            return try Lnrpc.ListPeersRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ListPeersRequest"
        }
        override public func className() -> String {
            return "Lnrpc.ListPeersRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ListPeersRequest = Lnrpc.ListPeersRequest()
            public func getMessage() -> Lnrpc.ListPeersRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ListPeersRequest.Builder {
                builderResult = Lnrpc.ListPeersRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.ListPeersRequest.Builder {
                return try Lnrpc.ListPeersRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ListPeersRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ListPeersRequest {
                let returnMe:Lnrpc.ListPeersRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ListPeersRequest) throws -> Lnrpc.ListPeersRequest.Builder {
                if other == Lnrpc.ListPeersRequest() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ListPeersRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListPeersRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ListPeersRequest.Builder {
                let resultDecodedBuilder = Lnrpc.ListPeersRequest.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ListPeersRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ListPeersRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ListPeersResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ListPeersResponse.Builder

        public static func == (lhs: Lnrpc.ListPeersResponse, rhs: Lnrpc.ListPeersResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.peers == rhs.peers)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var peers:Array<Lnrpc.Peer>  = Array<Lnrpc.Peer>()
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementPeers in peers {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementPeers)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementPeers in peers {
                serialize_size += oneElementPeers.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ListPeersResponse.Builder {
            return Lnrpc.ListPeersResponse.classBuilder() as! Lnrpc.ListPeersResponse.Builder
        }
        public func getBuilder() -> Lnrpc.ListPeersResponse.Builder {
            return classBuilder() as! Lnrpc.ListPeersResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ListPeersResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ListPeersResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ListPeersResponse.Builder {
            return try Lnrpc.ListPeersResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ListPeersResponse) throws -> Lnrpc.ListPeersResponse.Builder {
            return try Lnrpc.ListPeersResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !peers.isEmpty {
                var jsonArrayPeers:Array<Dictionary<String,Any>> = []
                for oneValuePeers in peers {
                    let ecodedMessagePeers = try oneValuePeers.encode()
                    jsonArrayPeers.append(ecodedMessagePeers)
                }
                jsonMap["peers"] = jsonArrayPeers
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ListPeersResponse {
            return try Lnrpc.ListPeersResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ListPeersResponse {
            return try Lnrpc.ListPeersResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var peersElementIndex:Int = 0
            for oneElementPeers in peers {
                output += "\(indent) peers[\(peersElementIndex)] {\n"
                output += try oneElementPeers.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                peersElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementPeers in peers {
                    hashCode = (hashCode &* 31) &+ oneElementPeers.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ListPeersResponse"
        }
        override public func className() -> String {
            return "Lnrpc.ListPeersResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ListPeersResponse = Lnrpc.ListPeersResponse()
            public func getMessage() -> Lnrpc.ListPeersResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The list of currently connected peers
            public var peers:Array<Lnrpc.Peer> {
                get {
                    return builderResult.peers
                }
                set (value) {
                    builderResult.peers = value
                }
            }
            @discardableResult
            public func setPeers(_ value:Array<Lnrpc.Peer>) -> Lnrpc.ListPeersResponse.Builder {
                self.peers = value
                return self
            }
            @discardableResult
            public func clearPeers() -> Lnrpc.ListPeersResponse.Builder {
                builderResult.peers.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ListPeersResponse.Builder {
                builderResult = Lnrpc.ListPeersResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.ListPeersResponse.Builder {
                return try Lnrpc.ListPeersResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ListPeersResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ListPeersResponse {
                let returnMe:Lnrpc.ListPeersResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ListPeersResponse) throws -> Lnrpc.ListPeersResponse.Builder {
                if other == Lnrpc.ListPeersResponse() {
                    return self
                }
                if !other.peers.isEmpty  {
                     builderResult.peers += other.peers
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ListPeersResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListPeersResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Lnrpc.Peer.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        peers.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ListPeersResponse.Builder {
                let resultDecodedBuilder = Lnrpc.ListPeersResponse.Builder()
                if let jsonValuePeers = jsonMap["peers"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayPeers:Array<Lnrpc.Peer> = []
                    for oneValuePeers in jsonValuePeers {
                        let messageFromStringPeers = try Lnrpc.Peer.Builder.decodeToBuilder(jsonMap:oneValuePeers).build()

                        jsonArrayPeers.append(messageFromStringPeers)
                    }
                    resultDecodedBuilder.peers = jsonArrayPeers
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ListPeersResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ListPeersResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GetInfoRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.GetInfoRequest.Builder

        public static func == (lhs: Lnrpc.GetInfoRequest, rhs: Lnrpc.GetInfoRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.GetInfoRequest.Builder {
            return Lnrpc.GetInfoRequest.classBuilder() as! Lnrpc.GetInfoRequest.Builder
        }
        public func getBuilder() -> Lnrpc.GetInfoRequest.Builder {
            return classBuilder() as! Lnrpc.GetInfoRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.GetInfoRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.GetInfoRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.GetInfoRequest.Builder {
            return try Lnrpc.GetInfoRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.GetInfoRequest) throws -> Lnrpc.GetInfoRequest.Builder {
            return try Lnrpc.GetInfoRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.GetInfoRequest {
            return try Lnrpc.GetInfoRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.GetInfoRequest {
            return try Lnrpc.GetInfoRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.GetInfoRequest"
        }
        override public func className() -> String {
            return "Lnrpc.GetInfoRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.GetInfoRequest = Lnrpc.GetInfoRequest()
            public func getMessage() -> Lnrpc.GetInfoRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.GetInfoRequest.Builder {
                builderResult = Lnrpc.GetInfoRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.GetInfoRequest.Builder {
                return try Lnrpc.GetInfoRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.GetInfoRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.GetInfoRequest {
                let returnMe:Lnrpc.GetInfoRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.GetInfoRequest) throws -> Lnrpc.GetInfoRequest.Builder {
                if other == Lnrpc.GetInfoRequest() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.GetInfoRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GetInfoRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.GetInfoRequest.Builder {
                let resultDecodedBuilder = Lnrpc.GetInfoRequest.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.GetInfoRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.GetInfoRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GetInfoResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.GetInfoResponse.Builder

        public static func == (lhs: Lnrpc.GetInfoResponse, rhs: Lnrpc.GetInfoResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasIdentityPubkey == rhs.hasIdentityPubkey) && (!lhs.hasIdentityPubkey || lhs.identityPubkey == rhs.identityPubkey)
            fieldCheck = fieldCheck && (lhs.hasAlias == rhs.hasAlias) && (!lhs.hasAlias || lhs.alias == rhs.alias)
            fieldCheck = fieldCheck && (lhs.hasNumPendingChannels == rhs.hasNumPendingChannels) && (!lhs.hasNumPendingChannels || lhs.numPendingChannels == rhs.numPendingChannels)
            fieldCheck = fieldCheck && (lhs.hasNumActiveChannels == rhs.hasNumActiveChannels) && (!lhs.hasNumActiveChannels || lhs.numActiveChannels == rhs.numActiveChannels)
            fieldCheck = fieldCheck && (lhs.hasNumPeers == rhs.hasNumPeers) && (!lhs.hasNumPeers || lhs.numPeers == rhs.numPeers)
            fieldCheck = fieldCheck && (lhs.hasBlockHeight == rhs.hasBlockHeight) && (!lhs.hasBlockHeight || lhs.blockHeight == rhs.blockHeight)
            fieldCheck = fieldCheck && (lhs.hasBlockHash == rhs.hasBlockHash) && (!lhs.hasBlockHash || lhs.blockHash == rhs.blockHash)
            fieldCheck = fieldCheck && (lhs.hasSyncedToChain == rhs.hasSyncedToChain) && (!lhs.hasSyncedToChain || lhs.syncedToChain == rhs.syncedToChain)
            fieldCheck = fieldCheck && (lhs.hasTestnet == rhs.hasTestnet) && (!lhs.hasTestnet || lhs.testnet == rhs.testnet)
            fieldCheck = fieldCheck && (lhs.chains == rhs.chains)
            fieldCheck = fieldCheck && (lhs.uris == rhs.uris)
            fieldCheck = fieldCheck && (lhs.hasBestHeaderTimestamp == rhs.hasBestHeaderTimestamp) && (!lhs.hasBestHeaderTimestamp || lhs.bestHeaderTimestamp == rhs.bestHeaderTimestamp)
            fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// The identity pubkey of the current node.
        public fileprivate(set) var identityPubkey:String! = nil
        public fileprivate(set) var hasIdentityPubkey:Bool = false

        //// If applicable, the alias of the current node, e.g. "bob"
        public fileprivate(set) var alias:String! = nil
        public fileprivate(set) var hasAlias:Bool = false

        //// Number of pending channels
        public fileprivate(set) var numPendingChannels:UInt32! = nil
        public fileprivate(set) var hasNumPendingChannels:Bool = false

        //// Number of active channels
        public fileprivate(set) var numActiveChannels:UInt32! = nil
        public fileprivate(set) var hasNumActiveChannels:Bool = false

        //// Number of peers
        public fileprivate(set) var numPeers:UInt32! = nil
        public fileprivate(set) var hasNumPeers:Bool = false

        //// The node's current view of the height of the best block
        public fileprivate(set) var blockHeight:UInt32! = nil
        public fileprivate(set) var hasBlockHeight:Bool = false

        //// The node's current view of the hash of the best block
        public fileprivate(set) var blockHash:String! = nil
        public fileprivate(set) var hasBlockHash:Bool = false

        //// Whether the wallet's view is synced to the main chain
        public fileprivate(set) var syncedToChain:Bool! = nil
        public fileprivate(set) var hasSyncedToChain:Bool = false

        //// Whether the current node is connected to testnet
        public fileprivate(set) var testnet:Bool! = nil
        public fileprivate(set) var hasTestnet:Bool = false

        //// A list of active chains the node is connected to
        public fileprivate(set) var chains:Array<String> = Array<String>()
        //// The URIs of the current node.
        public fileprivate(set) var uris:Array<String> = Array<String>()
        //// Timestamp of the block best known to the wallet
        public fileprivate(set) var bestHeaderTimestamp:Int64! = nil
        public fileprivate(set) var hasBestHeaderTimestamp:Bool = false

        //// The version of the LND software that the node is running.
        public fileprivate(set) var version:String! = nil
        public fileprivate(set) var hasVersion:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasIdentityPubkey {
                try codedOutputStream.writeString(fieldNumber: 1, value:identityPubkey)
            }
            if hasAlias {
                try codedOutputStream.writeString(fieldNumber: 2, value:alias)
            }
            if hasNumPendingChannels {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:numPendingChannels)
            }
            if hasNumActiveChannels {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:numActiveChannels)
            }
            if hasNumPeers {
                try codedOutputStream.writeUInt32(fieldNumber: 5, value:numPeers)
            }
            if hasBlockHeight {
                try codedOutputStream.writeUInt32(fieldNumber: 6, value:blockHeight)
            }
            if hasBlockHash {
                try codedOutputStream.writeString(fieldNumber: 8, value:blockHash)
            }
            if hasSyncedToChain {
                try codedOutputStream.writeBool(fieldNumber: 9, value:syncedToChain)
            }
            if hasTestnet {
                try codedOutputStream.writeBool(fieldNumber: 10, value:testnet)
            }
            if !chains.isEmpty {
                for oneValuechains in chains {
                    try codedOutputStream.writeString(fieldNumber: 11, value:oneValuechains)
                }
            }
            if !uris.isEmpty {
                for oneValueuris in uris {
                    try codedOutputStream.writeString(fieldNumber: 12, value:oneValueuris)
                }
            }
            if hasBestHeaderTimestamp {
                try codedOutputStream.writeInt64(fieldNumber: 13, value:bestHeaderTimestamp)
            }
            if hasVersion {
                try codedOutputStream.writeString(fieldNumber: 14, value:version)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasIdentityPubkey {
                serialize_size += identityPubkey.computeStringSize(fieldNumber: 1)
            }
            if hasAlias {
                serialize_size += alias.computeStringSize(fieldNumber: 2)
            }
            if hasNumPendingChannels {
                serialize_size += numPendingChannels.computeUInt32Size(fieldNumber: 3)
            }
            if hasNumActiveChannels {
                serialize_size += numActiveChannels.computeUInt32Size(fieldNumber: 4)
            }
            if hasNumPeers {
                serialize_size += numPeers.computeUInt32Size(fieldNumber: 5)
            }
            if hasBlockHeight {
                serialize_size += blockHeight.computeUInt32Size(fieldNumber: 6)
            }
            if hasBlockHash {
                serialize_size += blockHash.computeStringSize(fieldNumber: 8)
            }
            if hasSyncedToChain {
                serialize_size += syncedToChain.computeBoolSize(fieldNumber: 9)
            }
            if hasTestnet {
                serialize_size += testnet.computeBoolSize(fieldNumber: 10)
            }
            var dataSizeChains:Int32 = 0
            for oneValuechains in chains {
                dataSizeChains += oneValuechains.computeStringSizeNoTag()
            }
            serialize_size += dataSizeChains
            serialize_size += 1 * Int32(chains.count)
            var dataSizeUris:Int32 = 0
            for oneValueuris in uris {
                dataSizeUris += oneValueuris.computeStringSizeNoTag()
            }
            serialize_size += dataSizeUris
            serialize_size += 1 * Int32(uris.count)
            if hasBestHeaderTimestamp {
                serialize_size += bestHeaderTimestamp.computeInt64Size(fieldNumber: 13)
            }
            if hasVersion {
                serialize_size += version.computeStringSize(fieldNumber: 14)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.GetInfoResponse.Builder {
            return Lnrpc.GetInfoResponse.classBuilder() as! Lnrpc.GetInfoResponse.Builder
        }
        public func getBuilder() -> Lnrpc.GetInfoResponse.Builder {
            return classBuilder() as! Lnrpc.GetInfoResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.GetInfoResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.GetInfoResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.GetInfoResponse.Builder {
            return try Lnrpc.GetInfoResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.GetInfoResponse) throws -> Lnrpc.GetInfoResponse.Builder {
            return try Lnrpc.GetInfoResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasIdentityPubkey {
                jsonMap["identity_pubkey"] = identityPubkey
            }
            if hasAlias {
                jsonMap["alias"] = alias
            }
            if hasNumPendingChannels {
                jsonMap["num_pending_channels"] = UInt(numPendingChannels)
            }
            if hasNumActiveChannels {
                jsonMap["num_active_channels"] = UInt(numActiveChannels)
            }
            if hasNumPeers {
                jsonMap["num_peers"] = UInt(numPeers)
            }
            if hasBlockHeight {
                jsonMap["block_height"] = UInt(blockHeight)
            }
            if hasBlockHash {
                jsonMap["block_hash"] = blockHash
            }
            if hasSyncedToChain {
                jsonMap["synced_to_chain"] = syncedToChain
            }
            if hasTestnet {
                jsonMap["testnet"] = testnet
            }
            if !chains.isEmpty {
                var jsonArrayChains:Array<String> = []
                for oneValueChains in chains {
                    jsonArrayChains.append(oneValueChains)
                }
                jsonMap["chains"] = jsonArrayChains
            }
            if !uris.isEmpty {
                var jsonArrayUris:Array<String> = []
                for oneValueUris in uris {
                    jsonArrayUris.append(oneValueUris)
                }
                jsonMap["uris"] = jsonArrayUris
            }
            if hasBestHeaderTimestamp {
                jsonMap["best_header_timestamp"] = "\(bestHeaderTimestamp!)"
            }
            if hasVersion {
                jsonMap["version"] = version
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.GetInfoResponse {
            return try Lnrpc.GetInfoResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.GetInfoResponse {
            return try Lnrpc.GetInfoResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasIdentityPubkey {
                output += "\(indent) identityPubkey: \(identityPubkey) \n"
            }
            if hasAlias {
                output += "\(indent) alias: \(alias) \n"
            }
            if hasNumPendingChannels {
                output += "\(indent) numPendingChannels: \(numPendingChannels) \n"
            }
            if hasNumActiveChannels {
                output += "\(indent) numActiveChannels: \(numActiveChannels) \n"
            }
            if hasNumPeers {
                output += "\(indent) numPeers: \(numPeers) \n"
            }
            if hasBlockHeight {
                output += "\(indent) blockHeight: \(blockHeight) \n"
            }
            if hasBlockHash {
                output += "\(indent) blockHash: \(blockHash) \n"
            }
            if hasSyncedToChain {
                output += "\(indent) syncedToChain: \(syncedToChain) \n"
            }
            if hasTestnet {
                output += "\(indent) testnet: \(testnet) \n"
            }
            var chainsElementIndex:Int = 0
            for oneValueChains in chains  {
                output += "\(indent) chains[\(chainsElementIndex)]: \(oneValueChains)\n"
                chainsElementIndex += 1
            }
            var urisElementIndex:Int = 0
            for oneValueUris in uris  {
                output += "\(indent) uris[\(urisElementIndex)]: \(oneValueUris)\n"
                urisElementIndex += 1
            }
            if hasBestHeaderTimestamp {
                output += "\(indent) bestHeaderTimestamp: \(bestHeaderTimestamp) \n"
            }
            if hasVersion {
                output += "\(indent) version: \(version) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasIdentityPubkey {
                    hashCode = (hashCode &* 31) &+ identityPubkey.hashValue
                }
                if hasAlias {
                    hashCode = (hashCode &* 31) &+ alias.hashValue
                }
                if hasNumPendingChannels {
                    hashCode = (hashCode &* 31) &+ numPendingChannels.hashValue
                }
                if hasNumActiveChannels {
                    hashCode = (hashCode &* 31) &+ numActiveChannels.hashValue
                }
                if hasNumPeers {
                    hashCode = (hashCode &* 31) &+ numPeers.hashValue
                }
                if hasBlockHeight {
                    hashCode = (hashCode &* 31) &+ blockHeight.hashValue
                }
                if hasBlockHash {
                    hashCode = (hashCode &* 31) &+ blockHash.hashValue
                }
                if hasSyncedToChain {
                    hashCode = (hashCode &* 31) &+ syncedToChain.hashValue
                }
                if hasTestnet {
                    hashCode = (hashCode &* 31) &+ testnet.hashValue
                }
                for oneValueChains in chains {
                    hashCode = (hashCode &* 31) &+ oneValueChains.hashValue
                }
                for oneValueUris in uris {
                    hashCode = (hashCode &* 31) &+ oneValueUris.hashValue
                }
                if hasBestHeaderTimestamp {
                    hashCode = (hashCode &* 31) &+ bestHeaderTimestamp.hashValue
                }
                if hasVersion {
                    hashCode = (hashCode &* 31) &+ version.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.GetInfoResponse"
        }
        override public func className() -> String {
            return "Lnrpc.GetInfoResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.GetInfoResponse = Lnrpc.GetInfoResponse()
            public func getMessage() -> Lnrpc.GetInfoResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The identity pubkey of the current node.
            public var identityPubkey:String {
                get {
                    return builderResult.identityPubkey
                }
                set (value) {
                    builderResult.hasIdentityPubkey = true
                    builderResult.identityPubkey = value
                }
            }
            public var hasIdentityPubkey:Bool {
                get {
                    return builderResult.hasIdentityPubkey
                }
            }
            @discardableResult
            public func setIdentityPubkey(_ value:String) -> Lnrpc.GetInfoResponse.Builder {
                self.identityPubkey = value
                return self
            }
            @discardableResult
            public func clearIdentityPubkey() -> Lnrpc.GetInfoResponse.Builder{
                builderResult.hasIdentityPubkey = false
                builderResult.identityPubkey = nil
                return self
            }
            //// If applicable, the alias of the current node, e.g. "bob"
            public var alias:String {
                get {
                    return builderResult.alias
                }
                set (value) {
                    builderResult.hasAlias = true
                    builderResult.alias = value
                }
            }
            public var hasAlias:Bool {
                get {
                    return builderResult.hasAlias
                }
            }
            @discardableResult
            public func setAlias(_ value:String) -> Lnrpc.GetInfoResponse.Builder {
                self.alias = value
                return self
            }
            @discardableResult
            public func clearAlias() -> Lnrpc.GetInfoResponse.Builder{
                builderResult.hasAlias = false
                builderResult.alias = nil
                return self
            }
            //// Number of pending channels
            public var numPendingChannels:UInt32 {
                get {
                    return builderResult.numPendingChannels
                }
                set (value) {
                    builderResult.hasNumPendingChannels = true
                    builderResult.numPendingChannels = value
                }
            }
            public var hasNumPendingChannels:Bool {
                get {
                    return builderResult.hasNumPendingChannels
                }
            }
            @discardableResult
            public func setNumPendingChannels(_ value:UInt32) -> Lnrpc.GetInfoResponse.Builder {
                self.numPendingChannels = value
                return self
            }
            @discardableResult
            public func clearNumPendingChannels() -> Lnrpc.GetInfoResponse.Builder{
                builderResult.hasNumPendingChannels = false
                builderResult.numPendingChannels = nil
                return self
            }
            //// Number of active channels
            public var numActiveChannels:UInt32 {
                get {
                    return builderResult.numActiveChannels
                }
                set (value) {
                    builderResult.hasNumActiveChannels = true
                    builderResult.numActiveChannels = value
                }
            }
            public var hasNumActiveChannels:Bool {
                get {
                    return builderResult.hasNumActiveChannels
                }
            }
            @discardableResult
            public func setNumActiveChannels(_ value:UInt32) -> Lnrpc.GetInfoResponse.Builder {
                self.numActiveChannels = value
                return self
            }
            @discardableResult
            public func clearNumActiveChannels() -> Lnrpc.GetInfoResponse.Builder{
                builderResult.hasNumActiveChannels = false
                builderResult.numActiveChannels = nil
                return self
            }
            //// Number of peers
            public var numPeers:UInt32 {
                get {
                    return builderResult.numPeers
                }
                set (value) {
                    builderResult.hasNumPeers = true
                    builderResult.numPeers = value
                }
            }
            public var hasNumPeers:Bool {
                get {
                    return builderResult.hasNumPeers
                }
            }
            @discardableResult
            public func setNumPeers(_ value:UInt32) -> Lnrpc.GetInfoResponse.Builder {
                self.numPeers = value
                return self
            }
            @discardableResult
            public func clearNumPeers() -> Lnrpc.GetInfoResponse.Builder{
                builderResult.hasNumPeers = false
                builderResult.numPeers = nil
                return self
            }
            //// The node's current view of the height of the best block
            public var blockHeight:UInt32 {
                get {
                    return builderResult.blockHeight
                }
                set (value) {
                    builderResult.hasBlockHeight = true
                    builderResult.blockHeight = value
                }
            }
            public var hasBlockHeight:Bool {
                get {
                    return builderResult.hasBlockHeight
                }
            }
            @discardableResult
            public func setBlockHeight(_ value:UInt32) -> Lnrpc.GetInfoResponse.Builder {
                self.blockHeight = value
                return self
            }
            @discardableResult
            public func clearBlockHeight() -> Lnrpc.GetInfoResponse.Builder{
                builderResult.hasBlockHeight = false
                builderResult.blockHeight = nil
                return self
            }
            //// The node's current view of the hash of the best block
            public var blockHash:String {
                get {
                    return builderResult.blockHash
                }
                set (value) {
                    builderResult.hasBlockHash = true
                    builderResult.blockHash = value
                }
            }
            public var hasBlockHash:Bool {
                get {
                    return builderResult.hasBlockHash
                }
            }
            @discardableResult
            public func setBlockHash(_ value:String) -> Lnrpc.GetInfoResponse.Builder {
                self.blockHash = value
                return self
            }
            @discardableResult
            public func clearBlockHash() -> Lnrpc.GetInfoResponse.Builder{
                builderResult.hasBlockHash = false
                builderResult.blockHash = nil
                return self
            }
            //// Whether the wallet's view is synced to the main chain
            public var syncedToChain:Bool {
                get {
                    return builderResult.syncedToChain
                }
                set (value) {
                    builderResult.hasSyncedToChain = true
                    builderResult.syncedToChain = value
                }
            }
            public var hasSyncedToChain:Bool {
                get {
                    return builderResult.hasSyncedToChain
                }
            }
            @discardableResult
            public func setSyncedToChain(_ value:Bool) -> Lnrpc.GetInfoResponse.Builder {
                self.syncedToChain = value
                return self
            }
            @discardableResult
            public func clearSyncedToChain() -> Lnrpc.GetInfoResponse.Builder{
                builderResult.hasSyncedToChain = false
                builderResult.syncedToChain = nil
                return self
            }
            //// Whether the current node is connected to testnet
            public var testnet:Bool {
                get {
                    return builderResult.testnet
                }
                set (value) {
                    builderResult.hasTestnet = true
                    builderResult.testnet = value
                }
            }
            public var hasTestnet:Bool {
                get {
                    return builderResult.hasTestnet
                }
            }
            @discardableResult
            public func setTestnet(_ value:Bool) -> Lnrpc.GetInfoResponse.Builder {
                self.testnet = value
                return self
            }
            @discardableResult
            public func clearTestnet() -> Lnrpc.GetInfoResponse.Builder{
                builderResult.hasTestnet = false
                builderResult.testnet = nil
                return self
            }
            //// A list of active chains the node is connected to
            public var chains:Array<String> {
                get {
                    return builderResult.chains
                }
                set (array) {
                    builderResult.chains = array
                }
            }
            @discardableResult
            public func setChains(_ value:Array<String>) -> Lnrpc.GetInfoResponse.Builder {
                self.chains = value
                return self
            }
            @discardableResult
            public func clearChains() -> Lnrpc.GetInfoResponse.Builder {
                builderResult.chains.removeAll(keepingCapacity: false)
                return self
            }
            //// The URIs of the current node.
            public var uris:Array<String> {
                get {
                    return builderResult.uris
                }
                set (array) {
                    builderResult.uris = array
                }
            }
            @discardableResult
            public func setUris(_ value:Array<String>) -> Lnrpc.GetInfoResponse.Builder {
                self.uris = value
                return self
            }
            @discardableResult
            public func clearUris() -> Lnrpc.GetInfoResponse.Builder {
                builderResult.uris.removeAll(keepingCapacity: false)
                return self
            }
            //// Timestamp of the block best known to the wallet
            public var bestHeaderTimestamp:Int64 {
                get {
                    return builderResult.bestHeaderTimestamp
                }
                set (value) {
                    builderResult.hasBestHeaderTimestamp = true
                    builderResult.bestHeaderTimestamp = value
                }
            }
            public var hasBestHeaderTimestamp:Bool {
                get {
                    return builderResult.hasBestHeaderTimestamp
                }
            }
            @discardableResult
            public func setBestHeaderTimestamp(_ value:Int64) -> Lnrpc.GetInfoResponse.Builder {
                self.bestHeaderTimestamp = value
                return self
            }
            @discardableResult
            public func clearBestHeaderTimestamp() -> Lnrpc.GetInfoResponse.Builder{
                builderResult.hasBestHeaderTimestamp = false
                builderResult.bestHeaderTimestamp = nil
                return self
            }
            //// The version of the LND software that the node is running.
            public var version:String {
                get {
                    return builderResult.version
                }
                set (value) {
                    builderResult.hasVersion = true
                    builderResult.version = value
                }
            }
            public var hasVersion:Bool {
                get {
                    return builderResult.hasVersion
                }
            }
            @discardableResult
            public func setVersion(_ value:String) -> Lnrpc.GetInfoResponse.Builder {
                self.version = value
                return self
            }
            @discardableResult
            public func clearVersion() -> Lnrpc.GetInfoResponse.Builder{
                builderResult.hasVersion = false
                builderResult.version = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.GetInfoResponse.Builder {
                builderResult = Lnrpc.GetInfoResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.GetInfoResponse.Builder {
                return try Lnrpc.GetInfoResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.GetInfoResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.GetInfoResponse {
                let returnMe:Lnrpc.GetInfoResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.GetInfoResponse) throws -> Lnrpc.GetInfoResponse.Builder {
                if other == Lnrpc.GetInfoResponse() {
                    return self
                }
                if other.hasIdentityPubkey {
                    identityPubkey = other.identityPubkey
                }
                if other.hasAlias {
                    alias = other.alias
                }
                if other.hasNumPendingChannels {
                    numPendingChannels = other.numPendingChannels
                }
                if other.hasNumActiveChannels {
                    numActiveChannels = other.numActiveChannels
                }
                if other.hasNumPeers {
                    numPeers = other.numPeers
                }
                if other.hasBlockHeight {
                    blockHeight = other.blockHeight
                }
                if other.hasBlockHash {
                    blockHash = other.blockHash
                }
                if other.hasSyncedToChain {
                    syncedToChain = other.syncedToChain
                }
                if other.hasTestnet {
                    testnet = other.testnet
                }
                if !other.chains.isEmpty {
                    builderResult.chains += other.chains
                }
                if !other.uris.isEmpty {
                    builderResult.uris += other.uris
                }
                if other.hasBestHeaderTimestamp {
                    bestHeaderTimestamp = other.bestHeaderTimestamp
                }
                if other.hasVersion {
                    version = other.version
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.GetInfoResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GetInfoResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        identityPubkey = try codedInputStream.readString()

                    case 18:
                        alias = try codedInputStream.readString()

                    case 24:
                        numPendingChannels = try codedInputStream.readUInt32()

                    case 32:
                        numActiveChannels = try codedInputStream.readUInt32()

                    case 40:
                        numPeers = try codedInputStream.readUInt32()

                    case 48:
                        blockHeight = try codedInputStream.readUInt32()

                    case 66:
                        blockHash = try codedInputStream.readString()

                    case 72:
                        syncedToChain = try codedInputStream.readBool()

                    case 80:
                        testnet = try codedInputStream.readBool()

                    case 90:
                        chains += [try codedInputStream.readString()]

                    case 98:
                        uris += [try codedInputStream.readString()]

                    case 104:
                        bestHeaderTimestamp = try codedInputStream.readInt64()

                    case 114:
                        version = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.GetInfoResponse.Builder {
                let resultDecodedBuilder = Lnrpc.GetInfoResponse.Builder()
                if let jsonValueIdentityPubkey = jsonMap["identity_pubkey"] as? String {
                    resultDecodedBuilder.identityPubkey = jsonValueIdentityPubkey
                }
                if let jsonValueAlias = jsonMap["alias"] as? String {
                    resultDecodedBuilder.alias = jsonValueAlias
                }
                if let jsonValueNumPendingChannels = jsonMap["num_pending_channels"] as? UInt {
                    resultDecodedBuilder.numPendingChannels = UInt32(jsonValueNumPendingChannels)
                } else if let jsonValueNumPendingChannels = jsonMap["num_pending_channels"] as? String {
                    resultDecodedBuilder.numPendingChannels = UInt32(jsonValueNumPendingChannels)!
                }
                if let jsonValueNumActiveChannels = jsonMap["num_active_channels"] as? UInt {
                    resultDecodedBuilder.numActiveChannels = UInt32(jsonValueNumActiveChannels)
                } else if let jsonValueNumActiveChannels = jsonMap["num_active_channels"] as? String {
                    resultDecodedBuilder.numActiveChannels = UInt32(jsonValueNumActiveChannels)!
                }
                if let jsonValueNumPeers = jsonMap["num_peers"] as? UInt {
                    resultDecodedBuilder.numPeers = UInt32(jsonValueNumPeers)
                } else if let jsonValueNumPeers = jsonMap["num_peers"] as? String {
                    resultDecodedBuilder.numPeers = UInt32(jsonValueNumPeers)!
                }
                if let jsonValueBlockHeight = jsonMap["block_height"] as? UInt {
                    resultDecodedBuilder.blockHeight = UInt32(jsonValueBlockHeight)
                } else if let jsonValueBlockHeight = jsonMap["block_height"] as? String {
                    resultDecodedBuilder.blockHeight = UInt32(jsonValueBlockHeight)!
                }
                if let jsonValueBlockHash = jsonMap["block_hash"] as? String {
                    resultDecodedBuilder.blockHash = jsonValueBlockHash
                }
                if let jsonValueSyncedToChain = jsonMap["synced_to_chain"] as? Bool {
                    resultDecodedBuilder.syncedToChain = jsonValueSyncedToChain
                }
                if let jsonValueTestnet = jsonMap["testnet"] as? Bool {
                    resultDecodedBuilder.testnet = jsonValueTestnet
                }
                if let jsonValueChains = jsonMap["chains"] as? Array<String> {
                    var jsonArrayChains:Array<String> = []
                    for oneValueChains in jsonValueChains {
                        jsonArrayChains.append(oneValueChains)
                    }
                    resultDecodedBuilder.chains = jsonArrayChains
                }
                if let jsonValueUris = jsonMap["uris"] as? Array<String> {
                    var jsonArrayUris:Array<String> = []
                    for oneValueUris in jsonValueUris {
                        jsonArrayUris.append(oneValueUris)
                    }
                    resultDecodedBuilder.uris = jsonArrayUris
                }
                if let jsonValueBestHeaderTimestamp = jsonMap["best_header_timestamp"] as? String {
                    resultDecodedBuilder.bestHeaderTimestamp = Int64(jsonValueBestHeaderTimestamp)!
                } else if let jsonValueBestHeaderTimestamp = jsonMap["best_header_timestamp"] as? Int {
                    resultDecodedBuilder.bestHeaderTimestamp = Int64(jsonValueBestHeaderTimestamp)
                }
                if let jsonValueVersion = jsonMap["version"] as? String {
                    resultDecodedBuilder.version = jsonValueVersion
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.GetInfoResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.GetInfoResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ConfirmationUpdate : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ConfirmationUpdate.Builder

        public static func == (lhs: Lnrpc.ConfirmationUpdate, rhs: Lnrpc.ConfirmationUpdate) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasBlockSha == rhs.hasBlockSha) && (!lhs.hasBlockSha || lhs.blockSha == rhs.blockSha)
            fieldCheck = fieldCheck && (lhs.hasBlockHeight == rhs.hasBlockHeight) && (!lhs.hasBlockHeight || lhs.blockHeight == rhs.blockHeight)
            fieldCheck = fieldCheck && (lhs.hasNumConfsLeft == rhs.hasNumConfsLeft) && (!lhs.hasNumConfsLeft || lhs.numConfsLeft == rhs.numConfsLeft)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var blockSha:Data! = nil
        public fileprivate(set) var hasBlockSha:Bool = false

        public fileprivate(set) var blockHeight:Int32! = nil
        public fileprivate(set) var hasBlockHeight:Bool = false

        public fileprivate(set) var numConfsLeft:UInt32! = nil
        public fileprivate(set) var hasNumConfsLeft:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasBlockSha {
                try codedOutputStream.writeData(fieldNumber: 1, value:blockSha)
            }
            if hasBlockHeight {
                try codedOutputStream.writeInt32(fieldNumber: 2, value:blockHeight)
            }
            if hasNumConfsLeft {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:numConfsLeft)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasBlockSha {
                serialize_size += blockSha.computeDataSize(fieldNumber: 1)
            }
            if hasBlockHeight {
                serialize_size += blockHeight.computeInt32Size(fieldNumber: 2)
            }
            if hasNumConfsLeft {
                serialize_size += numConfsLeft.computeUInt32Size(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ConfirmationUpdate.Builder {
            return Lnrpc.ConfirmationUpdate.classBuilder() as! Lnrpc.ConfirmationUpdate.Builder
        }
        public func getBuilder() -> Lnrpc.ConfirmationUpdate.Builder {
            return classBuilder() as! Lnrpc.ConfirmationUpdate.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ConfirmationUpdate.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ConfirmationUpdate.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ConfirmationUpdate.Builder {
            return try Lnrpc.ConfirmationUpdate.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ConfirmationUpdate) throws -> Lnrpc.ConfirmationUpdate.Builder {
            return try Lnrpc.ConfirmationUpdate.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasBlockSha {
                jsonMap["blockSha"] = blockSha.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasBlockHeight {
                jsonMap["blockHeight"] = Int(blockHeight)
            }
            if hasNumConfsLeft {
                jsonMap["numConfsLeft"] = UInt(numConfsLeft)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ConfirmationUpdate {
            return try Lnrpc.ConfirmationUpdate.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ConfirmationUpdate {
            return try Lnrpc.ConfirmationUpdate.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasBlockSha {
                output += "\(indent) blockSha: \(blockSha) \n"
            }
            if hasBlockHeight {
                output += "\(indent) blockHeight: \(blockHeight) \n"
            }
            if hasNumConfsLeft {
                output += "\(indent) numConfsLeft: \(numConfsLeft) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasBlockSha {
                    hashCode = (hashCode &* 31) &+ blockSha.hashValue
                }
                if hasBlockHeight {
                    hashCode = (hashCode &* 31) &+ blockHeight.hashValue
                }
                if hasNumConfsLeft {
                    hashCode = (hashCode &* 31) &+ numConfsLeft.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ConfirmationUpdate"
        }
        override public func className() -> String {
            return "Lnrpc.ConfirmationUpdate"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ConfirmationUpdate = Lnrpc.ConfirmationUpdate()
            public func getMessage() -> Lnrpc.ConfirmationUpdate {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var blockSha:Data {
                get {
                    return builderResult.blockSha
                }
                set (value) {
                    builderResult.hasBlockSha = true
                    builderResult.blockSha = value
                }
            }
            public var hasBlockSha:Bool {
                get {
                    return builderResult.hasBlockSha
                }
            }
            @discardableResult
            public func setBlockSha(_ value:Data) -> Lnrpc.ConfirmationUpdate.Builder {
                self.blockSha = value
                return self
            }
            @discardableResult
            public func clearBlockSha() -> Lnrpc.ConfirmationUpdate.Builder{
                builderResult.hasBlockSha = false
                builderResult.blockSha = nil
                return self
            }
            public var blockHeight:Int32 {
                get {
                    return builderResult.blockHeight
                }
                set (value) {
                    builderResult.hasBlockHeight = true
                    builderResult.blockHeight = value
                }
            }
            public var hasBlockHeight:Bool {
                get {
                    return builderResult.hasBlockHeight
                }
            }
            @discardableResult
            public func setBlockHeight(_ value:Int32) -> Lnrpc.ConfirmationUpdate.Builder {
                self.blockHeight = value
                return self
            }
            @discardableResult
            public func clearBlockHeight() -> Lnrpc.ConfirmationUpdate.Builder{
                builderResult.hasBlockHeight = false
                builderResult.blockHeight = nil
                return self
            }
            public var numConfsLeft:UInt32 {
                get {
                    return builderResult.numConfsLeft
                }
                set (value) {
                    builderResult.hasNumConfsLeft = true
                    builderResult.numConfsLeft = value
                }
            }
            public var hasNumConfsLeft:Bool {
                get {
                    return builderResult.hasNumConfsLeft
                }
            }
            @discardableResult
            public func setNumConfsLeft(_ value:UInt32) -> Lnrpc.ConfirmationUpdate.Builder {
                self.numConfsLeft = value
                return self
            }
            @discardableResult
            public func clearNumConfsLeft() -> Lnrpc.ConfirmationUpdate.Builder{
                builderResult.hasNumConfsLeft = false
                builderResult.numConfsLeft = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ConfirmationUpdate.Builder {
                builderResult = Lnrpc.ConfirmationUpdate()
                return self
            }
            override public func clone() throws -> Lnrpc.ConfirmationUpdate.Builder {
                return try Lnrpc.ConfirmationUpdate.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ConfirmationUpdate {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ConfirmationUpdate {
                let returnMe:Lnrpc.ConfirmationUpdate = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ConfirmationUpdate) throws -> Lnrpc.ConfirmationUpdate.Builder {
                if other == Lnrpc.ConfirmationUpdate() {
                    return self
                }
                if other.hasBlockSha {
                    blockSha = other.blockSha
                }
                if other.hasBlockHeight {
                    blockHeight = other.blockHeight
                }
                if other.hasNumConfsLeft {
                    numConfsLeft = other.numConfsLeft
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ConfirmationUpdate.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ConfirmationUpdate.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        blockSha = try codedInputStream.readData()

                    case 16:
                        blockHeight = try codedInputStream.readInt32()

                    case 24:
                        numConfsLeft = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ConfirmationUpdate.Builder {
                let resultDecodedBuilder = Lnrpc.ConfirmationUpdate.Builder()
                if let jsonValueBlockSha = jsonMap["blockSha"] as? String {
                    resultDecodedBuilder.blockSha = Data(base64Encoded:jsonValueBlockSha, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueBlockHeight = jsonMap["blockHeight"] as? Int {
                    resultDecodedBuilder.blockHeight = Int32(jsonValueBlockHeight)
                } else if let jsonValueBlockHeight = jsonMap["blockHeight"] as? String {
                    resultDecodedBuilder.blockHeight = Int32(jsonValueBlockHeight)!
                }
                if let jsonValueNumConfsLeft = jsonMap["numConfsLeft"] as? UInt {
                    resultDecodedBuilder.numConfsLeft = UInt32(jsonValueNumConfsLeft)
                } else if let jsonValueNumConfsLeft = jsonMap["numConfsLeft"] as? String {
                    resultDecodedBuilder.numConfsLeft = UInt32(jsonValueNumConfsLeft)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ConfirmationUpdate.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ConfirmationUpdate.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ChannelOpenUpdate : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ChannelOpenUpdate.Builder

        public static func == (lhs: Lnrpc.ChannelOpenUpdate, rhs: Lnrpc.ChannelOpenUpdate) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasChannelPoint == rhs.hasChannelPoint) && (!lhs.hasChannelPoint || lhs.channelPoint == rhs.channelPoint)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var channelPoint:Lnrpc.ChannelPoint!
        public fileprivate(set) var hasChannelPoint:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasChannelPoint {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:channelPoint)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasChannelPoint {
                if let varSizechannelPoint = channelPoint?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizechannelPoint
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ChannelOpenUpdate.Builder {
            return Lnrpc.ChannelOpenUpdate.classBuilder() as! Lnrpc.ChannelOpenUpdate.Builder
        }
        public func getBuilder() -> Lnrpc.ChannelOpenUpdate.Builder {
            return classBuilder() as! Lnrpc.ChannelOpenUpdate.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChannelOpenUpdate.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChannelOpenUpdate.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ChannelOpenUpdate.Builder {
            return try Lnrpc.ChannelOpenUpdate.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ChannelOpenUpdate) throws -> Lnrpc.ChannelOpenUpdate.Builder {
            return try Lnrpc.ChannelOpenUpdate.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasChannelPoint {
                jsonMap["channel_point"] = try channelPoint.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChannelOpenUpdate {
            return try Lnrpc.ChannelOpenUpdate.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChannelOpenUpdate {
            return try Lnrpc.ChannelOpenUpdate.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasChannelPoint {
                output += "\(indent) channelPoint {\n"
                if let outDescChannelPoint = channelPoint {
                    output += try outDescChannelPoint.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasChannelPoint {
                    if let hashValuechannelPoint = channelPoint?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuechannelPoint
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ChannelOpenUpdate"
        }
        override public func className() -> String {
            return "Lnrpc.ChannelOpenUpdate"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ChannelOpenUpdate = Lnrpc.ChannelOpenUpdate()
            public func getMessage() -> Lnrpc.ChannelOpenUpdate {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var channelPoint:Lnrpc.ChannelPoint! {
                get {
                    if channelPointBuilder_ != nil {
                        builderResult.channelPoint = channelPointBuilder_.getMessage()
                    }
                    return builderResult.channelPoint
                }
                set (value) {
                    builderResult.hasChannelPoint = value != nil
                    builderResult.channelPoint = value
                }
            }
            public var hasChannelPoint:Bool {
                get {
                    return builderResult.hasChannelPoint
                }
            }
            fileprivate var channelPointBuilder_:Lnrpc.ChannelPoint.Builder! {
                didSet {
                    builderResult.hasChannelPoint = true
                }
            }
            public func getChannelPointBuilder() -> Lnrpc.ChannelPoint.Builder {
                if channelPointBuilder_ == nil {
                    channelPointBuilder_ = Lnrpc.ChannelPoint.Builder()
                    builderResult.channelPoint = channelPointBuilder_.getMessage()
                    if channelPoint != nil {
                        try! channelPointBuilder_.mergeFrom(other: channelPoint)
                    }
                }
                return channelPointBuilder_
            }
            @discardableResult
            public func setChannelPoint(_ value:Lnrpc.ChannelPoint!) -> Lnrpc.ChannelOpenUpdate.Builder {
                self.channelPoint = value
                return self
            }
            @discardableResult
            public func mergeChannelPoint(value:Lnrpc.ChannelPoint) throws -> Lnrpc.ChannelOpenUpdate.Builder {
                if builderResult.hasChannelPoint {
                    builderResult.channelPoint = try Lnrpc.ChannelPoint.builderWithPrototype(prototype:builderResult.channelPoint).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.channelPoint = value
                }
                builderResult.hasChannelPoint = true
                return self
            }
            @discardableResult
            public func clearChannelPoint() -> Lnrpc.ChannelOpenUpdate.Builder {
                channelPointBuilder_ = nil
                builderResult.hasChannelPoint = false
                builderResult.channelPoint = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ChannelOpenUpdate.Builder {
                builderResult = Lnrpc.ChannelOpenUpdate()
                return self
            }
            override public func clone() throws -> Lnrpc.ChannelOpenUpdate.Builder {
                return try Lnrpc.ChannelOpenUpdate.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ChannelOpenUpdate {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ChannelOpenUpdate {
                let returnMe:Lnrpc.ChannelOpenUpdate = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ChannelOpenUpdate) throws -> Lnrpc.ChannelOpenUpdate.Builder {
                if other == Lnrpc.ChannelOpenUpdate() {
                    return self
                }
                if (other.hasChannelPoint) {
                    try mergeChannelPoint(value: other.channelPoint)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChannelOpenUpdate.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelOpenUpdate.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Lnrpc.ChannelPoint.Builder = Lnrpc.ChannelPoint.Builder()
                        if hasChannelPoint {
                            try subBuilder.mergeFrom(other: channelPoint)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        channelPoint = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChannelOpenUpdate.Builder {
                let resultDecodedBuilder = Lnrpc.ChannelOpenUpdate.Builder()
                if let jsonValueChannelPoint = jsonMap["channel_point"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.channelPoint = try Lnrpc.ChannelPoint.Builder.decodeToBuilder(jsonMap:jsonValueChannelPoint).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChannelOpenUpdate.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ChannelOpenUpdate.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ChannelCloseUpdate : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ChannelCloseUpdate.Builder

        public static func == (lhs: Lnrpc.ChannelCloseUpdate, rhs: Lnrpc.ChannelCloseUpdate) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasClosingTxid == rhs.hasClosingTxid) && (!lhs.hasClosingTxid || lhs.closingTxid == rhs.closingTxid)
            fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var closingTxid:Data! = nil
        public fileprivate(set) var hasClosingTxid:Bool = false

        public fileprivate(set) var success:Bool! = nil
        public fileprivate(set) var hasSuccess:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasClosingTxid {
                try codedOutputStream.writeData(fieldNumber: 1, value:closingTxid)
            }
            if hasSuccess {
                try codedOutputStream.writeBool(fieldNumber: 2, value:success)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasClosingTxid {
                serialize_size += closingTxid.computeDataSize(fieldNumber: 1)
            }
            if hasSuccess {
                serialize_size += success.computeBoolSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ChannelCloseUpdate.Builder {
            return Lnrpc.ChannelCloseUpdate.classBuilder() as! Lnrpc.ChannelCloseUpdate.Builder
        }
        public func getBuilder() -> Lnrpc.ChannelCloseUpdate.Builder {
            return classBuilder() as! Lnrpc.ChannelCloseUpdate.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChannelCloseUpdate.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChannelCloseUpdate.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ChannelCloseUpdate.Builder {
            return try Lnrpc.ChannelCloseUpdate.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ChannelCloseUpdate) throws -> Lnrpc.ChannelCloseUpdate.Builder {
            return try Lnrpc.ChannelCloseUpdate.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasClosingTxid {
                jsonMap["closing_txid"] = closingTxid.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasSuccess {
                jsonMap["success"] = success
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChannelCloseUpdate {
            return try Lnrpc.ChannelCloseUpdate.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChannelCloseUpdate {
            return try Lnrpc.ChannelCloseUpdate.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasClosingTxid {
                output += "\(indent) closingTxid: \(closingTxid) \n"
            }
            if hasSuccess {
                output += "\(indent) success: \(success) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasClosingTxid {
                    hashCode = (hashCode &* 31) &+ closingTxid.hashValue
                }
                if hasSuccess {
                    hashCode = (hashCode &* 31) &+ success.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ChannelCloseUpdate"
        }
        override public func className() -> String {
            return "Lnrpc.ChannelCloseUpdate"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ChannelCloseUpdate = Lnrpc.ChannelCloseUpdate()
            public func getMessage() -> Lnrpc.ChannelCloseUpdate {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var closingTxid:Data {
                get {
                    return builderResult.closingTxid
                }
                set (value) {
                    builderResult.hasClosingTxid = true
                    builderResult.closingTxid = value
                }
            }
            public var hasClosingTxid:Bool {
                get {
                    return builderResult.hasClosingTxid
                }
            }
            @discardableResult
            public func setClosingTxid(_ value:Data) -> Lnrpc.ChannelCloseUpdate.Builder {
                self.closingTxid = value
                return self
            }
            @discardableResult
            public func clearClosingTxid() -> Lnrpc.ChannelCloseUpdate.Builder{
                builderResult.hasClosingTxid = false
                builderResult.closingTxid = nil
                return self
            }
            public var success:Bool {
                get {
                    return builderResult.success
                }
                set (value) {
                    builderResult.hasSuccess = true
                    builderResult.success = value
                }
            }
            public var hasSuccess:Bool {
                get {
                    return builderResult.hasSuccess
                }
            }
            @discardableResult
            public func setSuccess(_ value:Bool) -> Lnrpc.ChannelCloseUpdate.Builder {
                self.success = value
                return self
            }
            @discardableResult
            public func clearSuccess() -> Lnrpc.ChannelCloseUpdate.Builder{
                builderResult.hasSuccess = false
                builderResult.success = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ChannelCloseUpdate.Builder {
                builderResult = Lnrpc.ChannelCloseUpdate()
                return self
            }
            override public func clone() throws -> Lnrpc.ChannelCloseUpdate.Builder {
                return try Lnrpc.ChannelCloseUpdate.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ChannelCloseUpdate {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ChannelCloseUpdate {
                let returnMe:Lnrpc.ChannelCloseUpdate = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ChannelCloseUpdate) throws -> Lnrpc.ChannelCloseUpdate.Builder {
                if other == Lnrpc.ChannelCloseUpdate() {
                    return self
                }
                if other.hasClosingTxid {
                    closingTxid = other.closingTxid
                }
                if other.hasSuccess {
                    success = other.success
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChannelCloseUpdate.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelCloseUpdate.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        closingTxid = try codedInputStream.readData()

                    case 16:
                        success = try codedInputStream.readBool()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChannelCloseUpdate.Builder {
                let resultDecodedBuilder = Lnrpc.ChannelCloseUpdate.Builder()
                if let jsonValueClosingTxid = jsonMap["closing_txid"] as? String {
                    resultDecodedBuilder.closingTxid = Data(base64Encoded:jsonValueClosingTxid, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueSuccess = jsonMap["success"] as? Bool {
                    resultDecodedBuilder.success = jsonValueSuccess
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChannelCloseUpdate.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ChannelCloseUpdate.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class CloseChannelRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.CloseChannelRequest.Builder

        public static func == (lhs: Lnrpc.CloseChannelRequest, rhs: Lnrpc.CloseChannelRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasChannelPoint == rhs.hasChannelPoint) && (!lhs.hasChannelPoint || lhs.channelPoint == rhs.channelPoint)
            fieldCheck = fieldCheck && (lhs.hasForce == rhs.hasForce) && (!lhs.hasForce || lhs.force == rhs.force)
            fieldCheck = fieldCheck && (lhs.hasTargetConf == rhs.hasTargetConf) && (!lhs.hasTargetConf || lhs.targetConf == rhs.targetConf)
            fieldCheck = fieldCheck && (lhs.hasSatPerByte == rhs.hasSatPerByte) && (!lhs.hasSatPerByte || lhs.satPerByte == rhs.satPerByte)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var channelPoint:Lnrpc.ChannelPoint!
        public fileprivate(set) var hasChannelPoint:Bool = false
        //// If true, then the channel will be closed forcibly. This means the current commitment transaction will be signed and broadcast.
        public fileprivate(set) var force:Bool! = nil
        public fileprivate(set) var hasForce:Bool = false

        //// The target number of blocks that the closure transaction should be confirmed by.
        public fileprivate(set) var targetConf:Int32! = nil
        public fileprivate(set) var hasTargetConf:Bool = false

        //// A manual fee rate set in sat/byte that should be used when crafting the closure transaction.
        public fileprivate(set) var satPerByte:Int64! = nil
        public fileprivate(set) var hasSatPerByte:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasChannelPoint {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:channelPoint)
            }
            if hasForce {
                try codedOutputStream.writeBool(fieldNumber: 2, value:force)
            }
            if hasTargetConf {
                try codedOutputStream.writeInt32(fieldNumber: 3, value:targetConf)
            }
            if hasSatPerByte {
                try codedOutputStream.writeInt64(fieldNumber: 4, value:satPerByte)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasChannelPoint {
                if let varSizechannelPoint = channelPoint?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizechannelPoint
                }
            }
            if hasForce {
                serialize_size += force.computeBoolSize(fieldNumber: 2)
            }
            if hasTargetConf {
                serialize_size += targetConf.computeInt32Size(fieldNumber: 3)
            }
            if hasSatPerByte {
                serialize_size += satPerByte.computeInt64Size(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.CloseChannelRequest.Builder {
            return Lnrpc.CloseChannelRequest.classBuilder() as! Lnrpc.CloseChannelRequest.Builder
        }
        public func getBuilder() -> Lnrpc.CloseChannelRequest.Builder {
            return classBuilder() as! Lnrpc.CloseChannelRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.CloseChannelRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.CloseChannelRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.CloseChannelRequest.Builder {
            return try Lnrpc.CloseChannelRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.CloseChannelRequest) throws -> Lnrpc.CloseChannelRequest.Builder {
            return try Lnrpc.CloseChannelRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasChannelPoint {
                jsonMap["channelPoint"] = try channelPoint.encode()
            }
            if hasForce {
                jsonMap["force"] = force
            }
            if hasTargetConf {
                jsonMap["targetConf"] = Int(targetConf)
            }
            if hasSatPerByte {
                jsonMap["satPerByte"] = "\(satPerByte!)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.CloseChannelRequest {
            return try Lnrpc.CloseChannelRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.CloseChannelRequest {
            return try Lnrpc.CloseChannelRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasChannelPoint {
                output += "\(indent) channelPoint {\n"
                if let outDescChannelPoint = channelPoint {
                    output += try outDescChannelPoint.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasForce {
                output += "\(indent) force: \(force) \n"
            }
            if hasTargetConf {
                output += "\(indent) targetConf: \(targetConf) \n"
            }
            if hasSatPerByte {
                output += "\(indent) satPerByte: \(satPerByte) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasChannelPoint {
                    if let hashValuechannelPoint = channelPoint?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuechannelPoint
                    }
                }
                if hasForce {
                    hashCode = (hashCode &* 31) &+ force.hashValue
                }
                if hasTargetConf {
                    hashCode = (hashCode &* 31) &+ targetConf.hashValue
                }
                if hasSatPerByte {
                    hashCode = (hashCode &* 31) &+ satPerByte.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.CloseChannelRequest"
        }
        override public func className() -> String {
            return "Lnrpc.CloseChannelRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.CloseChannelRequest = Lnrpc.CloseChannelRequest()
            public func getMessage() -> Lnrpc.CloseChannelRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///*
            ///The outpoint (txid:index) of the funding transaction. With this value, Bob
            ///will be able to generate a signature for Alice's version of the commitment
            ///transaction.
            public var channelPoint:Lnrpc.ChannelPoint! {
                get {
                    if channelPointBuilder_ != nil {
                        builderResult.channelPoint = channelPointBuilder_.getMessage()
                    }
                    return builderResult.channelPoint
                }
                set (value) {
                    builderResult.hasChannelPoint = value != nil
                    builderResult.channelPoint = value
                }
            }
            public var hasChannelPoint:Bool {
                get {
                    return builderResult.hasChannelPoint
                }
            }
            fileprivate var channelPointBuilder_:Lnrpc.ChannelPoint.Builder! {
                didSet {
                    builderResult.hasChannelPoint = true
                }
            }
            public func getChannelPointBuilder() -> Lnrpc.ChannelPoint.Builder {
                if channelPointBuilder_ == nil {
                    channelPointBuilder_ = Lnrpc.ChannelPoint.Builder()
                    builderResult.channelPoint = channelPointBuilder_.getMessage()
                    if channelPoint != nil {
                        try! channelPointBuilder_.mergeFrom(other: channelPoint)
                    }
                }
                return channelPointBuilder_
            }
            @discardableResult
            public func setChannelPoint(_ value:Lnrpc.ChannelPoint!) -> Lnrpc.CloseChannelRequest.Builder {
                self.channelPoint = value
                return self
            }
            @discardableResult
            public func mergeChannelPoint(value:Lnrpc.ChannelPoint) throws -> Lnrpc.CloseChannelRequest.Builder {
                if builderResult.hasChannelPoint {
                    builderResult.channelPoint = try Lnrpc.ChannelPoint.builderWithPrototype(prototype:builderResult.channelPoint).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.channelPoint = value
                }
                builderResult.hasChannelPoint = true
                return self
            }
            @discardableResult
            public func clearChannelPoint() -> Lnrpc.CloseChannelRequest.Builder {
                channelPointBuilder_ = nil
                builderResult.hasChannelPoint = false
                builderResult.channelPoint = nil
                return self
            }
            //// If true, then the channel will be closed forcibly. This means the current commitment transaction will be signed and broadcast.
            public var force:Bool {
                get {
                    return builderResult.force
                }
                set (value) {
                    builderResult.hasForce = true
                    builderResult.force = value
                }
            }
            public var hasForce:Bool {
                get {
                    return builderResult.hasForce
                }
            }
            @discardableResult
            public func setForce(_ value:Bool) -> Lnrpc.CloseChannelRequest.Builder {
                self.force = value
                return self
            }
            @discardableResult
            public func clearForce() -> Lnrpc.CloseChannelRequest.Builder{
                builderResult.hasForce = false
                builderResult.force = nil
                return self
            }
            //// The target number of blocks that the closure transaction should be confirmed by.
            public var targetConf:Int32 {
                get {
                    return builderResult.targetConf
                }
                set (value) {
                    builderResult.hasTargetConf = true
                    builderResult.targetConf = value
                }
            }
            public var hasTargetConf:Bool {
                get {
                    return builderResult.hasTargetConf
                }
            }
            @discardableResult
            public func setTargetConf(_ value:Int32) -> Lnrpc.CloseChannelRequest.Builder {
                self.targetConf = value
                return self
            }
            @discardableResult
            public func clearTargetConf() -> Lnrpc.CloseChannelRequest.Builder{
                builderResult.hasTargetConf = false
                builderResult.targetConf = nil
                return self
            }
            //// A manual fee rate set in sat/byte that should be used when crafting the closure transaction.
            public var satPerByte:Int64 {
                get {
                    return builderResult.satPerByte
                }
                set (value) {
                    builderResult.hasSatPerByte = true
                    builderResult.satPerByte = value
                }
            }
            public var hasSatPerByte:Bool {
                get {
                    return builderResult.hasSatPerByte
                }
            }
            @discardableResult
            public func setSatPerByte(_ value:Int64) -> Lnrpc.CloseChannelRequest.Builder {
                self.satPerByte = value
                return self
            }
            @discardableResult
            public func clearSatPerByte() -> Lnrpc.CloseChannelRequest.Builder{
                builderResult.hasSatPerByte = false
                builderResult.satPerByte = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.CloseChannelRequest.Builder {
                builderResult = Lnrpc.CloseChannelRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.CloseChannelRequest.Builder {
                return try Lnrpc.CloseChannelRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.CloseChannelRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.CloseChannelRequest {
                let returnMe:Lnrpc.CloseChannelRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.CloseChannelRequest) throws -> Lnrpc.CloseChannelRequest.Builder {
                if other == Lnrpc.CloseChannelRequest() {
                    return self
                }
                if (other.hasChannelPoint) {
                    try mergeChannelPoint(value: other.channelPoint)
                }
                if other.hasForce {
                    force = other.force
                }
                if other.hasTargetConf {
                    targetConf = other.targetConf
                }
                if other.hasSatPerByte {
                    satPerByte = other.satPerByte
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.CloseChannelRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.CloseChannelRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Lnrpc.ChannelPoint.Builder = Lnrpc.ChannelPoint.Builder()
                        if hasChannelPoint {
                            try subBuilder.mergeFrom(other: channelPoint)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        channelPoint = subBuilder.buildPartial()

                    case 16:
                        force = try codedInputStream.readBool()

                    case 24:
                        targetConf = try codedInputStream.readInt32()

                    case 32:
                        satPerByte = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.CloseChannelRequest.Builder {
                let resultDecodedBuilder = Lnrpc.CloseChannelRequest.Builder()
                if let jsonValueChannelPoint = jsonMap["channelPoint"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.channelPoint = try Lnrpc.ChannelPoint.Builder.decodeToBuilder(jsonMap:jsonValueChannelPoint).build()

                }
                if let jsonValueForce = jsonMap["force"] as? Bool {
                    resultDecodedBuilder.force = jsonValueForce
                }
                if let jsonValueTargetConf = jsonMap["targetConf"] as? Int {
                    resultDecodedBuilder.targetConf = Int32(jsonValueTargetConf)
                } else if let jsonValueTargetConf = jsonMap["targetConf"] as? String {
                    resultDecodedBuilder.targetConf = Int32(jsonValueTargetConf)!
                }
                if let jsonValueSatPerByte = jsonMap["satPerByte"] as? String {
                    resultDecodedBuilder.satPerByte = Int64(jsonValueSatPerByte)!
                } else if let jsonValueSatPerByte = jsonMap["satPerByte"] as? Int {
                    resultDecodedBuilder.satPerByte = Int64(jsonValueSatPerByte)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.CloseChannelRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.CloseChannelRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class CloseStatusUpdate : GeneratedMessage {
        public typealias BuilderType = Lnrpc.CloseStatusUpdate.Builder

        public static func == (lhs: Lnrpc.CloseStatusUpdate, rhs: Lnrpc.CloseStatusUpdate) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasClosePending == rhs.hasClosePending) && (!lhs.hasClosePending || lhs.closePending == rhs.closePending)
            fieldCheck = fieldCheck && (lhs.hasConfirmation == rhs.hasConfirmation) && (!lhs.hasConfirmation || lhs.confirmation == rhs.confirmation)
            fieldCheck = fieldCheck && (lhs.hasChanClose == rhs.hasChanClose) && (!lhs.hasChanClose || lhs.chanClose == rhs.chanClose)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        public enum Update {
            case oneOfUpdateNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .oneOfUpdateNotSet: return false
                default: return true
                }
            }
            case closePending(Lnrpc.PendingUpdate)

            public static func getClosePending(_ value:Update) -> Lnrpc.PendingUpdate? {
                switch value {
                case .closePending(let messageValue): return messageValue
                default: return nil
                }
            }
            public func getClosePending() -> Lnrpc.PendingUpdate? {
                switch self {
                case .closePending(let messageValue): return messageValue
                default: return nil
                }
            }
            case confirmation(Lnrpc.ConfirmationUpdate)

            public static func getConfirmation(_ value:Update) -> Lnrpc.ConfirmationUpdate? {
                switch value {
                case .confirmation(let messageValue): return messageValue
                default: return nil
                }
            }
            public func getConfirmation() -> Lnrpc.ConfirmationUpdate? {
                switch self {
                case .confirmation(let messageValue): return messageValue
                default: return nil
                }
            }
            case chanClose(Lnrpc.ChannelCloseUpdate)

            public static func getChanClose(_ value:Update) -> Lnrpc.ChannelCloseUpdate? {
                switch value {
                case .chanClose(let messageValue): return messageValue
                default: return nil
                }
            }
            public func getChanClose() -> Lnrpc.ChannelCloseUpdate? {
                switch self {
                case .chanClose(let messageValue): return messageValue
                default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageUpdate:CloseStatusUpdate.Update =  CloseStatusUpdate.Update.oneOfUpdateNotSet
        public func getOneOfUpdate() ->  CloseStatusUpdate.Update {
            let copyObjectUpdate = storageUpdate
            return copyObjectUpdate
        }
        public fileprivate(set) var closePending:Lnrpc.PendingUpdate!{
            get {
                return CloseStatusUpdate.Update.getClosePending(storageUpdate)
            }
            set (newvalue) {
                storageUpdate = CloseStatusUpdate.Update.closePending(newvalue)
            }
        }
        public fileprivate(set) var hasClosePending:Bool {
            get {
                return CloseStatusUpdate.Update.getClosePending(storageUpdate) != nil
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var confirmation:Lnrpc.ConfirmationUpdate!{
            get {
                return CloseStatusUpdate.Update.getConfirmation(storageUpdate)
            }
            set (newvalue) {
                storageUpdate = CloseStatusUpdate.Update.confirmation(newvalue)
            }
        }
        public fileprivate(set) var hasConfirmation:Bool {
            get {
                return CloseStatusUpdate.Update.getConfirmation(storageUpdate) != nil
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var chanClose:Lnrpc.ChannelCloseUpdate!{
            get {
                return CloseStatusUpdate.Update.getChanClose(storageUpdate)
            }
            set (newvalue) {
                storageUpdate = CloseStatusUpdate.Update.chanClose(newvalue)
            }
        }
        public fileprivate(set) var hasChanClose:Bool {
            get {
                return CloseStatusUpdate.Update.getChanClose(storageUpdate) != nil
            }
            set(newValue) {
            }
        }
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasClosePending {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:closePending)
            }
            if hasConfirmation {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:confirmation)
            }
            if hasChanClose {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:chanClose)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasClosePending {
                if let varSizeclosePending = closePending?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeclosePending
                }
            }
            if hasConfirmation {
                if let varSizeconfirmation = confirmation?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeconfirmation
                }
            }
            if hasChanClose {
                if let varSizechanClose = chanClose?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizechanClose
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.CloseStatusUpdate.Builder {
            return Lnrpc.CloseStatusUpdate.classBuilder() as! Lnrpc.CloseStatusUpdate.Builder
        }
        public func getBuilder() -> Lnrpc.CloseStatusUpdate.Builder {
            return classBuilder() as! Lnrpc.CloseStatusUpdate.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.CloseStatusUpdate.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.CloseStatusUpdate.Builder()
        }
        public func toBuilder() throws -> Lnrpc.CloseStatusUpdate.Builder {
            return try Lnrpc.CloseStatusUpdate.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.CloseStatusUpdate) throws -> Lnrpc.CloseStatusUpdate.Builder {
            return try Lnrpc.CloseStatusUpdate.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasClosePending {
                jsonMap["close_pending"] = try closePending.encode()
            }
            if hasConfirmation {
                jsonMap["confirmation"] = try confirmation.encode()
            }
            if hasChanClose {
                jsonMap["chan_close"] = try chanClose.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.CloseStatusUpdate {
            return try Lnrpc.CloseStatusUpdate.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.CloseStatusUpdate {
            return try Lnrpc.CloseStatusUpdate.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasClosePending {
                output += "\(indent) closePending {\n"
                if let outDescClosePending = closePending {
                    output += try outDescClosePending.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasConfirmation {
                output += "\(indent) confirmation {\n"
                if let outDescConfirmation = confirmation {
                    output += try outDescConfirmation.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasChanClose {
                output += "\(indent) chanClose {\n"
                if let outDescChanClose = chanClose {
                    output += try outDescChanClose.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasClosePending {
                    if let hashValueclosePending = closePending?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueclosePending
                    }
                }
                if hasConfirmation {
                    if let hashValueconfirmation = confirmation?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueconfirmation
                    }
                }
                if hasChanClose {
                    if let hashValuechanClose = chanClose?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuechanClose
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.CloseStatusUpdate"
        }
        override public func className() -> String {
            return "Lnrpc.CloseStatusUpdate"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.CloseStatusUpdate = Lnrpc.CloseStatusUpdate()
            public func getMessage() -> Lnrpc.CloseStatusUpdate {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public func setUpdate(_ oneOf:CloseStatusUpdate.Update) ->  Lnrpc.CloseStatusUpdate.Builder {
                builderResult.storageUpdate = oneOf
                return self
            }
            public var closePending:Lnrpc.PendingUpdate! {
                get {
                    if closePendingBuilder_ != nil {
                        builderResult.closePending = closePendingBuilder_.getMessage()
                    }
                    return builderResult.closePending
                }
                set (value) {
                    builderResult.hasClosePending = value != nil
                    builderResult.closePending = value
                }
            }
            public var hasClosePending:Bool {
                get {
                    return builderResult.hasClosePending
                }
            }
            fileprivate var closePendingBuilder_:Lnrpc.PendingUpdate.Builder! {
                didSet {
                    builderResult.hasClosePending = true
                }
            }
            public func getClosePendingBuilder() -> Lnrpc.PendingUpdate.Builder {
                if closePendingBuilder_ == nil {
                    closePendingBuilder_ = Lnrpc.PendingUpdate.Builder()
                    builderResult.closePending = closePendingBuilder_.getMessage()
                    if closePending != nil {
                        try! closePendingBuilder_.mergeFrom(other: closePending)
                    }
                }
                return closePendingBuilder_
            }
            @discardableResult
            public func setClosePending(_ value:Lnrpc.PendingUpdate!) -> Lnrpc.CloseStatusUpdate.Builder {
                self.closePending = value
                return self
            }
            @discardableResult
            public func mergeClosePending(value:Lnrpc.PendingUpdate) throws -> Lnrpc.CloseStatusUpdate.Builder {
                if builderResult.hasClosePending {
                    builderResult.closePending = try Lnrpc.PendingUpdate.builderWithPrototype(prototype:builderResult.closePending).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.closePending = value
                }
                builderResult.hasClosePending = true
                return self
            }
            @discardableResult
            public func clearClosePending() -> Lnrpc.CloseStatusUpdate.Builder {
                closePendingBuilder_ = nil
                builderResult.hasClosePending = false
                builderResult.closePending = nil
                return self
            }
            public var confirmation:Lnrpc.ConfirmationUpdate! {
                get {
                    if confirmationBuilder_ != nil {
                        builderResult.confirmation = confirmationBuilder_.getMessage()
                    }
                    return builderResult.confirmation
                }
                set (value) {
                    builderResult.hasConfirmation = value != nil
                    builderResult.confirmation = value
                }
            }
            public var hasConfirmation:Bool {
                get {
                    return builderResult.hasConfirmation
                }
            }
            fileprivate var confirmationBuilder_:Lnrpc.ConfirmationUpdate.Builder! {
                didSet {
                    builderResult.hasConfirmation = true
                }
            }
            public func getConfirmationBuilder() -> Lnrpc.ConfirmationUpdate.Builder {
                if confirmationBuilder_ == nil {
                    confirmationBuilder_ = Lnrpc.ConfirmationUpdate.Builder()
                    builderResult.confirmation = confirmationBuilder_.getMessage()
                    if confirmation != nil {
                        try! confirmationBuilder_.mergeFrom(other: confirmation)
                    }
                }
                return confirmationBuilder_
            }
            @discardableResult
            public func setConfirmation(_ value:Lnrpc.ConfirmationUpdate!) -> Lnrpc.CloseStatusUpdate.Builder {
                self.confirmation = value
                return self
            }
            @discardableResult
            public func mergeConfirmation(value:Lnrpc.ConfirmationUpdate) throws -> Lnrpc.CloseStatusUpdate.Builder {
                if builderResult.hasConfirmation {
                    builderResult.confirmation = try Lnrpc.ConfirmationUpdate.builderWithPrototype(prototype:builderResult.confirmation).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.confirmation = value
                }
                builderResult.hasConfirmation = true
                return self
            }
            @discardableResult
            public func clearConfirmation() -> Lnrpc.CloseStatusUpdate.Builder {
                confirmationBuilder_ = nil
                builderResult.hasConfirmation = false
                builderResult.confirmation = nil
                return self
            }
            public var chanClose:Lnrpc.ChannelCloseUpdate! {
                get {
                    if chanCloseBuilder_ != nil {
                        builderResult.chanClose = chanCloseBuilder_.getMessage()
                    }
                    return builderResult.chanClose
                }
                set (value) {
                    builderResult.hasChanClose = value != nil
                    builderResult.chanClose = value
                }
            }
            public var hasChanClose:Bool {
                get {
                    return builderResult.hasChanClose
                }
            }
            fileprivate var chanCloseBuilder_:Lnrpc.ChannelCloseUpdate.Builder! {
                didSet {
                    builderResult.hasChanClose = true
                }
            }
            public func getChanCloseBuilder() -> Lnrpc.ChannelCloseUpdate.Builder {
                if chanCloseBuilder_ == nil {
                    chanCloseBuilder_ = Lnrpc.ChannelCloseUpdate.Builder()
                    builderResult.chanClose = chanCloseBuilder_.getMessage()
                    if chanClose != nil {
                        try! chanCloseBuilder_.mergeFrom(other: chanClose)
                    }
                }
                return chanCloseBuilder_
            }
            @discardableResult
            public func setChanClose(_ value:Lnrpc.ChannelCloseUpdate!) -> Lnrpc.CloseStatusUpdate.Builder {
                self.chanClose = value
                return self
            }
            @discardableResult
            public func mergeChanClose(value:Lnrpc.ChannelCloseUpdate) throws -> Lnrpc.CloseStatusUpdate.Builder {
                if builderResult.hasChanClose {
                    builderResult.chanClose = try Lnrpc.ChannelCloseUpdate.builderWithPrototype(prototype:builderResult.chanClose).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.chanClose = value
                }
                builderResult.hasChanClose = true
                return self
            }
            @discardableResult
            public func clearChanClose() -> Lnrpc.CloseStatusUpdate.Builder {
                chanCloseBuilder_ = nil
                builderResult.hasChanClose = false
                builderResult.chanClose = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.CloseStatusUpdate.Builder {
                builderResult = Lnrpc.CloseStatusUpdate()
                return self
            }
            override public func clone() throws -> Lnrpc.CloseStatusUpdate.Builder {
                return try Lnrpc.CloseStatusUpdate.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.CloseStatusUpdate {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.CloseStatusUpdate {
                let returnMe:Lnrpc.CloseStatusUpdate = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.CloseStatusUpdate) throws -> Lnrpc.CloseStatusUpdate.Builder {
                if other == Lnrpc.CloseStatusUpdate() {
                    return self
                }
                if (other.hasClosePending) {
                    try mergeClosePending(value: other.closePending)
                }
                if (other.hasConfirmation) {
                    try mergeConfirmation(value: other.confirmation)
                }
                if (other.hasChanClose) {
                    try mergeChanClose(value: other.chanClose)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.CloseStatusUpdate.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.CloseStatusUpdate.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Lnrpc.PendingUpdate.Builder = Lnrpc.PendingUpdate.Builder()
                        if hasClosePending {
                            try subBuilder.mergeFrom(other: closePending)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        closePending = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Lnrpc.ConfirmationUpdate.Builder = Lnrpc.ConfirmationUpdate.Builder()
                        if hasConfirmation {
                            try subBuilder.mergeFrom(other: confirmation)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        confirmation = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Lnrpc.ChannelCloseUpdate.Builder = Lnrpc.ChannelCloseUpdate.Builder()
                        if hasChanClose {
                            try subBuilder.mergeFrom(other: chanClose)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        chanClose = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.CloseStatusUpdate.Builder {
                let resultDecodedBuilder = Lnrpc.CloseStatusUpdate.Builder()
                if let jsonValueClosePending = jsonMap["close_pending"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.closePending = try Lnrpc.PendingUpdate.Builder.decodeToBuilder(jsonMap:jsonValueClosePending).build()

                }
                if let jsonValueConfirmation = jsonMap["confirmation"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.confirmation = try Lnrpc.ConfirmationUpdate.Builder.decodeToBuilder(jsonMap:jsonValueConfirmation).build()

                }
                if let jsonValueChanClose = jsonMap["chan_close"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.chanClose = try Lnrpc.ChannelCloseUpdate.Builder.decodeToBuilder(jsonMap:jsonValueChanClose).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.CloseStatusUpdate.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.CloseStatusUpdate.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class PendingUpdate : GeneratedMessage {
        public typealias BuilderType = Lnrpc.PendingUpdate.Builder

        public static func == (lhs: Lnrpc.PendingUpdate, rhs: Lnrpc.PendingUpdate) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTxid == rhs.hasTxid) && (!lhs.hasTxid || lhs.txid == rhs.txid)
            fieldCheck = fieldCheck && (lhs.hasOutputIndex == rhs.hasOutputIndex) && (!lhs.hasOutputIndex || lhs.outputIndex == rhs.outputIndex)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var txid:Data! = nil
        public fileprivate(set) var hasTxid:Bool = false

        public fileprivate(set) var outputIndex:UInt32! = nil
        public fileprivate(set) var hasOutputIndex:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTxid {
                try codedOutputStream.writeData(fieldNumber: 1, value:txid)
            }
            if hasOutputIndex {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:outputIndex)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTxid {
                serialize_size += txid.computeDataSize(fieldNumber: 1)
            }
            if hasOutputIndex {
                serialize_size += outputIndex.computeUInt32Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.PendingUpdate.Builder {
            return Lnrpc.PendingUpdate.classBuilder() as! Lnrpc.PendingUpdate.Builder
        }
        public func getBuilder() -> Lnrpc.PendingUpdate.Builder {
            return classBuilder() as! Lnrpc.PendingUpdate.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.PendingUpdate.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.PendingUpdate.Builder()
        }
        public func toBuilder() throws -> Lnrpc.PendingUpdate.Builder {
            return try Lnrpc.PendingUpdate.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.PendingUpdate) throws -> Lnrpc.PendingUpdate.Builder {
            return try Lnrpc.PendingUpdate.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTxid {
                jsonMap["txid"] = txid.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasOutputIndex {
                jsonMap["output_index"] = UInt(outputIndex)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PendingUpdate {
            return try Lnrpc.PendingUpdate.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PendingUpdate {
            return try Lnrpc.PendingUpdate.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTxid {
                output += "\(indent) txid: \(txid) \n"
            }
            if hasOutputIndex {
                output += "\(indent) outputIndex: \(outputIndex) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTxid {
                    hashCode = (hashCode &* 31) &+ txid.hashValue
                }
                if hasOutputIndex {
                    hashCode = (hashCode &* 31) &+ outputIndex.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.PendingUpdate"
        }
        override public func className() -> String {
            return "Lnrpc.PendingUpdate"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.PendingUpdate = Lnrpc.PendingUpdate()
            public func getMessage() -> Lnrpc.PendingUpdate {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var txid:Data {
                get {
                    return builderResult.txid
                }
                set (value) {
                    builderResult.hasTxid = true
                    builderResult.txid = value
                }
            }
            public var hasTxid:Bool {
                get {
                    return builderResult.hasTxid
                }
            }
            @discardableResult
            public func setTxid(_ value:Data) -> Lnrpc.PendingUpdate.Builder {
                self.txid = value
                return self
            }
            @discardableResult
            public func clearTxid() -> Lnrpc.PendingUpdate.Builder{
                builderResult.hasTxid = false
                builderResult.txid = nil
                return self
            }
            public var outputIndex:UInt32 {
                get {
                    return builderResult.outputIndex
                }
                set (value) {
                    builderResult.hasOutputIndex = true
                    builderResult.outputIndex = value
                }
            }
            public var hasOutputIndex:Bool {
                get {
                    return builderResult.hasOutputIndex
                }
            }
            @discardableResult
            public func setOutputIndex(_ value:UInt32) -> Lnrpc.PendingUpdate.Builder {
                self.outputIndex = value
                return self
            }
            @discardableResult
            public func clearOutputIndex() -> Lnrpc.PendingUpdate.Builder{
                builderResult.hasOutputIndex = false
                builderResult.outputIndex = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.PendingUpdate.Builder {
                builderResult = Lnrpc.PendingUpdate()
                return self
            }
            override public func clone() throws -> Lnrpc.PendingUpdate.Builder {
                return try Lnrpc.PendingUpdate.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.PendingUpdate {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.PendingUpdate {
                let returnMe:Lnrpc.PendingUpdate = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.PendingUpdate) throws -> Lnrpc.PendingUpdate.Builder {
                if other == Lnrpc.PendingUpdate() {
                    return self
                }
                if other.hasTxid {
                    txid = other.txid
                }
                if other.hasOutputIndex {
                    outputIndex = other.outputIndex
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PendingUpdate.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingUpdate.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        txid = try codedInputStream.readData()

                    case 16:
                        outputIndex = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PendingUpdate.Builder {
                let resultDecodedBuilder = Lnrpc.PendingUpdate.Builder()
                if let jsonValueTxid = jsonMap["txid"] as? String {
                    resultDecodedBuilder.txid = Data(base64Encoded:jsonValueTxid, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueOutputIndex = jsonMap["output_index"] as? UInt {
                    resultDecodedBuilder.outputIndex = UInt32(jsonValueOutputIndex)
                } else if let jsonValueOutputIndex = jsonMap["output_index"] as? String {
                    resultDecodedBuilder.outputIndex = UInt32(jsonValueOutputIndex)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PendingUpdate.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.PendingUpdate.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class OpenChannelRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.OpenChannelRequest.Builder

        public static func == (lhs: Lnrpc.OpenChannelRequest, rhs: Lnrpc.OpenChannelRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasNodePubkey == rhs.hasNodePubkey) && (!lhs.hasNodePubkey || lhs.nodePubkey == rhs.nodePubkey)
            fieldCheck = fieldCheck && (lhs.hasNodePubkeyString == rhs.hasNodePubkeyString) && (!lhs.hasNodePubkeyString || lhs.nodePubkeyString == rhs.nodePubkeyString)
            fieldCheck = fieldCheck && (lhs.hasLocalFundingAmount == rhs.hasLocalFundingAmount) && (!lhs.hasLocalFundingAmount || lhs.localFundingAmount == rhs.localFundingAmount)
            fieldCheck = fieldCheck && (lhs.hasPushSat == rhs.hasPushSat) && (!lhs.hasPushSat || lhs.pushSat == rhs.pushSat)
            fieldCheck = fieldCheck && (lhs.hasTargetConf == rhs.hasTargetConf) && (!lhs.hasTargetConf || lhs.targetConf == rhs.targetConf)
            fieldCheck = fieldCheck && (lhs.hasSatPerByte == rhs.hasSatPerByte) && (!lhs.hasSatPerByte || lhs.satPerByte == rhs.satPerByte)
            fieldCheck = fieldCheck && (lhs.hasPrivate == rhs.hasPrivate) && (!lhs.hasPrivate || lhs.private == rhs.private)
            fieldCheck = fieldCheck && (lhs.hasMinHtlcMsat == rhs.hasMinHtlcMsat) && (!lhs.hasMinHtlcMsat || lhs.minHtlcMsat == rhs.minHtlcMsat)
            fieldCheck = fieldCheck && (lhs.hasRemoteCsvDelay == rhs.hasRemoteCsvDelay) && (!lhs.hasRemoteCsvDelay || lhs.remoteCsvDelay == rhs.remoteCsvDelay)
            fieldCheck = fieldCheck && (lhs.hasMinConfs == rhs.hasMinConfs) && (!lhs.hasMinConfs || lhs.minConfs == rhs.minConfs)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// The pubkey of the node to open a channel with
        public fileprivate(set) var nodePubkey:Data! = nil
        public fileprivate(set) var hasNodePubkey:Bool = false

        //// The hex encoded pubkey of the node to open a channel with
        public fileprivate(set) var nodePubkeyString:String! = nil
        public fileprivate(set) var hasNodePubkeyString:Bool = false

        //// The number of satoshis the wallet should commit to the channel
        public fileprivate(set) var localFundingAmount:Int64! = nil
        public fileprivate(set) var hasLocalFundingAmount:Bool = false

        //// The number of satoshis to push to the remote side as part of the initial commitment state
        public fileprivate(set) var pushSat:Int64! = nil
        public fileprivate(set) var hasPushSat:Bool = false

        //// The target number of blocks that the funding transaction should be confirmed by.
        public fileprivate(set) var targetConf:Int32! = nil
        public fileprivate(set) var hasTargetConf:Bool = false

        //// A manual fee rate set in sat/byte that should be used when crafting the funding transaction.
        public fileprivate(set) var satPerByte:Int64! = nil
        public fileprivate(set) var hasSatPerByte:Bool = false

        //// Whether this channel should be private, not announced to the greater network.
        public fileprivate(set) var private:Bool! = nil
        public fileprivate(set) var hasPrivate:Bool = false

        //// The minimum value in millisatoshi we will require for incoming HTLCs on the channel.
        public fileprivate(set) var minHtlcMsat:Int64! = nil
        public fileprivate(set) var hasMinHtlcMsat:Bool = false

        //// The delay we require on the remote's commitment transaction. If this is not set, it will be scaled automatically with the channel size.
        public fileprivate(set) var remoteCsvDelay:UInt32! = nil
        public fileprivate(set) var hasRemoteCsvDelay:Bool = false

        //// The minimum number of confirmations each one of your outputs used for the funding transaction must satisfy.
        public fileprivate(set) var minConfs:Int32! = nil
        public fileprivate(set) var hasMinConfs:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasNodePubkey {
                try codedOutputStream.writeData(fieldNumber: 2, value:nodePubkey)
            }
            if hasNodePubkeyString {
                try codedOutputStream.writeString(fieldNumber: 3, value:nodePubkeyString)
            }
            if hasLocalFundingAmount {
                try codedOutputStream.writeInt64(fieldNumber: 4, value:localFundingAmount)
            }
            if hasPushSat {
                try codedOutputStream.writeInt64(fieldNumber: 5, value:pushSat)
            }
            if hasTargetConf {
                try codedOutputStream.writeInt32(fieldNumber: 6, value:targetConf)
            }
            if hasSatPerByte {
                try codedOutputStream.writeInt64(fieldNumber: 7, value:satPerByte)
            }
            if hasPrivate {
                try codedOutputStream.writeBool(fieldNumber: 8, value:private)
            }
            if hasMinHtlcMsat {
                try codedOutputStream.writeInt64(fieldNumber: 9, value:minHtlcMsat)
            }
            if hasRemoteCsvDelay {
                try codedOutputStream.writeUInt32(fieldNumber: 10, value:remoteCsvDelay)
            }
            if hasMinConfs {
                try codedOutputStream.writeInt32(fieldNumber: 11, value:minConfs)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasNodePubkey {
                serialize_size += nodePubkey.computeDataSize(fieldNumber: 2)
            }
            if hasNodePubkeyString {
                serialize_size += nodePubkeyString.computeStringSize(fieldNumber: 3)
            }
            if hasLocalFundingAmount {
                serialize_size += localFundingAmount.computeInt64Size(fieldNumber: 4)
            }
            if hasPushSat {
                serialize_size += pushSat.computeInt64Size(fieldNumber: 5)
            }
            if hasTargetConf {
                serialize_size += targetConf.computeInt32Size(fieldNumber: 6)
            }
            if hasSatPerByte {
                serialize_size += satPerByte.computeInt64Size(fieldNumber: 7)
            }
            if hasPrivate {
                serialize_size += private.computeBoolSize(fieldNumber: 8)
            }
            if hasMinHtlcMsat {
                serialize_size += minHtlcMsat.computeInt64Size(fieldNumber: 9)
            }
            if hasRemoteCsvDelay {
                serialize_size += remoteCsvDelay.computeUInt32Size(fieldNumber: 10)
            }
            if hasMinConfs {
                serialize_size += minConfs.computeInt32Size(fieldNumber: 11)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.OpenChannelRequest.Builder {
            return Lnrpc.OpenChannelRequest.classBuilder() as! Lnrpc.OpenChannelRequest.Builder
        }
        public func getBuilder() -> Lnrpc.OpenChannelRequest.Builder {
            return classBuilder() as! Lnrpc.OpenChannelRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.OpenChannelRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.OpenChannelRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.OpenChannelRequest.Builder {
            return try Lnrpc.OpenChannelRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.OpenChannelRequest) throws -> Lnrpc.OpenChannelRequest.Builder {
            return try Lnrpc.OpenChannelRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasNodePubkey {
                jsonMap["node_pubkey"] = nodePubkey.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasNodePubkeyString {
                jsonMap["node_pubkey_string"] = nodePubkeyString
            }
            if hasLocalFundingAmount {
                jsonMap["local_funding_amount"] = "\(localFundingAmount!)"
            }
            if hasPushSat {
                jsonMap["push_sat"] = "\(pushSat!)"
            }
            if hasTargetConf {
                jsonMap["targetConf"] = Int(targetConf)
            }
            if hasSatPerByte {
                jsonMap["satPerByte"] = "\(satPerByte!)"
            }
            if hasPrivate {
                jsonMap["private"] = private
            }
            if hasMinHtlcMsat {
                jsonMap["min_htlc_msat"] = "\(minHtlcMsat!)"
            }
            if hasRemoteCsvDelay {
                jsonMap["remote_csv_delay"] = UInt(remoteCsvDelay)
            }
            if hasMinConfs {
                jsonMap["min_confs"] = Int(minConfs)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.OpenChannelRequest {
            return try Lnrpc.OpenChannelRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.OpenChannelRequest {
            return try Lnrpc.OpenChannelRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasNodePubkey {
                output += "\(indent) nodePubkey: \(nodePubkey) \n"
            }
            if hasNodePubkeyString {
                output += "\(indent) nodePubkeyString: \(nodePubkeyString) \n"
            }
            if hasLocalFundingAmount {
                output += "\(indent) localFundingAmount: \(localFundingAmount) \n"
            }
            if hasPushSat {
                output += "\(indent) pushSat: \(pushSat) \n"
            }
            if hasTargetConf {
                output += "\(indent) targetConf: \(targetConf) \n"
            }
            if hasSatPerByte {
                output += "\(indent) satPerByte: \(satPerByte) \n"
            }
            if hasPrivate {
                output += "\(indent) private: \(private) \n"
            }
            if hasMinHtlcMsat {
                output += "\(indent) minHtlcMsat: \(minHtlcMsat) \n"
            }
            if hasRemoteCsvDelay {
                output += "\(indent) remoteCsvDelay: \(remoteCsvDelay) \n"
            }
            if hasMinConfs {
                output += "\(indent) minConfs: \(minConfs) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasNodePubkey {
                    hashCode = (hashCode &* 31) &+ nodePubkey.hashValue
                }
                if hasNodePubkeyString {
                    hashCode = (hashCode &* 31) &+ nodePubkeyString.hashValue
                }
                if hasLocalFundingAmount {
                    hashCode = (hashCode &* 31) &+ localFundingAmount.hashValue
                }
                if hasPushSat {
                    hashCode = (hashCode &* 31) &+ pushSat.hashValue
                }
                if hasTargetConf {
                    hashCode = (hashCode &* 31) &+ targetConf.hashValue
                }
                if hasSatPerByte {
                    hashCode = (hashCode &* 31) &+ satPerByte.hashValue
                }
                if hasPrivate {
                    hashCode = (hashCode &* 31) &+ private.hashValue
                }
                if hasMinHtlcMsat {
                    hashCode = (hashCode &* 31) &+ minHtlcMsat.hashValue
                }
                if hasRemoteCsvDelay {
                    hashCode = (hashCode &* 31) &+ remoteCsvDelay.hashValue
                }
                if hasMinConfs {
                    hashCode = (hashCode &* 31) &+ minConfs.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.OpenChannelRequest"
        }
        override public func className() -> String {
            return "Lnrpc.OpenChannelRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.OpenChannelRequest = Lnrpc.OpenChannelRequest()
            public func getMessage() -> Lnrpc.OpenChannelRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The pubkey of the node to open a channel with
            public var nodePubkey:Data {
                get {
                    return builderResult.nodePubkey
                }
                set (value) {
                    builderResult.hasNodePubkey = true
                    builderResult.nodePubkey = value
                }
            }
            public var hasNodePubkey:Bool {
                get {
                    return builderResult.hasNodePubkey
                }
            }
            @discardableResult
            public func setNodePubkey(_ value:Data) -> Lnrpc.OpenChannelRequest.Builder {
                self.nodePubkey = value
                return self
            }
            @discardableResult
            public func clearNodePubkey() -> Lnrpc.OpenChannelRequest.Builder{
                builderResult.hasNodePubkey = false
                builderResult.nodePubkey = nil
                return self
            }
            //// The hex encoded pubkey of the node to open a channel with
            public var nodePubkeyString:String {
                get {
                    return builderResult.nodePubkeyString
                }
                set (value) {
                    builderResult.hasNodePubkeyString = true
                    builderResult.nodePubkeyString = value
                }
            }
            public var hasNodePubkeyString:Bool {
                get {
                    return builderResult.hasNodePubkeyString
                }
            }
            @discardableResult
            public func setNodePubkeyString(_ value:String) -> Lnrpc.OpenChannelRequest.Builder {
                self.nodePubkeyString = value
                return self
            }
            @discardableResult
            public func clearNodePubkeyString() -> Lnrpc.OpenChannelRequest.Builder{
                builderResult.hasNodePubkeyString = false
                builderResult.nodePubkeyString = nil
                return self
            }
            //// The number of satoshis the wallet should commit to the channel
            public var localFundingAmount:Int64 {
                get {
                    return builderResult.localFundingAmount
                }
                set (value) {
                    builderResult.hasLocalFundingAmount = true
                    builderResult.localFundingAmount = value
                }
            }
            public var hasLocalFundingAmount:Bool {
                get {
                    return builderResult.hasLocalFundingAmount
                }
            }
            @discardableResult
            public func setLocalFundingAmount(_ value:Int64) -> Lnrpc.OpenChannelRequest.Builder {
                self.localFundingAmount = value
                return self
            }
            @discardableResult
            public func clearLocalFundingAmount() -> Lnrpc.OpenChannelRequest.Builder{
                builderResult.hasLocalFundingAmount = false
                builderResult.localFundingAmount = nil
                return self
            }
            //// The number of satoshis to push to the remote side as part of the initial commitment state
            public var pushSat:Int64 {
                get {
                    return builderResult.pushSat
                }
                set (value) {
                    builderResult.hasPushSat = true
                    builderResult.pushSat = value
                }
            }
            public var hasPushSat:Bool {
                get {
                    return builderResult.hasPushSat
                }
            }
            @discardableResult
            public func setPushSat(_ value:Int64) -> Lnrpc.OpenChannelRequest.Builder {
                self.pushSat = value
                return self
            }
            @discardableResult
            public func clearPushSat() -> Lnrpc.OpenChannelRequest.Builder{
                builderResult.hasPushSat = false
                builderResult.pushSat = nil
                return self
            }
            //// The target number of blocks that the funding transaction should be confirmed by.
            public var targetConf:Int32 {
                get {
                    return builderResult.targetConf
                }
                set (value) {
                    builderResult.hasTargetConf = true
                    builderResult.targetConf = value
                }
            }
            public var hasTargetConf:Bool {
                get {
                    return builderResult.hasTargetConf
                }
            }
            @discardableResult
            public func setTargetConf(_ value:Int32) -> Lnrpc.OpenChannelRequest.Builder {
                self.targetConf = value
                return self
            }
            @discardableResult
            public func clearTargetConf() -> Lnrpc.OpenChannelRequest.Builder{
                builderResult.hasTargetConf = false
                builderResult.targetConf = nil
                return self
            }
            //// A manual fee rate set in sat/byte that should be used when crafting the funding transaction.
            public var satPerByte:Int64 {
                get {
                    return builderResult.satPerByte
                }
                set (value) {
                    builderResult.hasSatPerByte = true
                    builderResult.satPerByte = value
                }
            }
            public var hasSatPerByte:Bool {
                get {
                    return builderResult.hasSatPerByte
                }
            }
            @discardableResult
            public func setSatPerByte(_ value:Int64) -> Lnrpc.OpenChannelRequest.Builder {
                self.satPerByte = value
                return self
            }
            @discardableResult
            public func clearSatPerByte() -> Lnrpc.OpenChannelRequest.Builder{
                builderResult.hasSatPerByte = false
                builderResult.satPerByte = nil
                return self
            }
            //// Whether this channel should be private, not announced to the greater network.
            public var private:Bool {
                get {
                    return builderResult.private
                }
                set (value) {
                    builderResult.hasPrivate = true
                    builderResult.private = value
                }
            }
            public var hasPrivate:Bool {
                get {
                    return builderResult.hasPrivate
                }
            }
            @discardableResult
            public func setPrivate(_ value:Bool) -> Lnrpc.OpenChannelRequest.Builder {
                self.private = value
                return self
            }
            @discardableResult
            public func clearPrivate() -> Lnrpc.OpenChannelRequest.Builder{
                builderResult.hasPrivate = false
                builderResult.private = nil
                return self
            }
            //// The minimum value in millisatoshi we will require for incoming HTLCs on the channel.
            public var minHtlcMsat:Int64 {
                get {
                    return builderResult.minHtlcMsat
                }
                set (value) {
                    builderResult.hasMinHtlcMsat = true
                    builderResult.minHtlcMsat = value
                }
            }
            public var hasMinHtlcMsat:Bool {
                get {
                    return builderResult.hasMinHtlcMsat
                }
            }
            @discardableResult
            public func setMinHtlcMsat(_ value:Int64) -> Lnrpc.OpenChannelRequest.Builder {
                self.minHtlcMsat = value
                return self
            }
            @discardableResult
            public func clearMinHtlcMsat() -> Lnrpc.OpenChannelRequest.Builder{
                builderResult.hasMinHtlcMsat = false
                builderResult.minHtlcMsat = nil
                return self
            }
            //// The delay we require on the remote's commitment transaction. If this is not set, it will be scaled automatically with the channel size.
            public var remoteCsvDelay:UInt32 {
                get {
                    return builderResult.remoteCsvDelay
                }
                set (value) {
                    builderResult.hasRemoteCsvDelay = true
                    builderResult.remoteCsvDelay = value
                }
            }
            public var hasRemoteCsvDelay:Bool {
                get {
                    return builderResult.hasRemoteCsvDelay
                }
            }
            @discardableResult
            public func setRemoteCsvDelay(_ value:UInt32) -> Lnrpc.OpenChannelRequest.Builder {
                self.remoteCsvDelay = value
                return self
            }
            @discardableResult
            public func clearRemoteCsvDelay() -> Lnrpc.OpenChannelRequest.Builder{
                builderResult.hasRemoteCsvDelay = false
                builderResult.remoteCsvDelay = nil
                return self
            }
            //// The minimum number of confirmations each one of your outputs used for the funding transaction must satisfy.
            public var minConfs:Int32 {
                get {
                    return builderResult.minConfs
                }
                set (value) {
                    builderResult.hasMinConfs = true
                    builderResult.minConfs = value
                }
            }
            public var hasMinConfs:Bool {
                get {
                    return builderResult.hasMinConfs
                }
            }
            @discardableResult
            public func setMinConfs(_ value:Int32) -> Lnrpc.OpenChannelRequest.Builder {
                self.minConfs = value
                return self
            }
            @discardableResult
            public func clearMinConfs() -> Lnrpc.OpenChannelRequest.Builder{
                builderResult.hasMinConfs = false
                builderResult.minConfs = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.OpenChannelRequest.Builder {
                builderResult = Lnrpc.OpenChannelRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.OpenChannelRequest.Builder {
                return try Lnrpc.OpenChannelRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.OpenChannelRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.OpenChannelRequest {
                let returnMe:Lnrpc.OpenChannelRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.OpenChannelRequest) throws -> Lnrpc.OpenChannelRequest.Builder {
                if other == Lnrpc.OpenChannelRequest() {
                    return self
                }
                if other.hasNodePubkey {
                    nodePubkey = other.nodePubkey
                }
                if other.hasNodePubkeyString {
                    nodePubkeyString = other.nodePubkeyString
                }
                if other.hasLocalFundingAmount {
                    localFundingAmount = other.localFundingAmount
                }
                if other.hasPushSat {
                    pushSat = other.pushSat
                }
                if other.hasTargetConf {
                    targetConf = other.targetConf
                }
                if other.hasSatPerByte {
                    satPerByte = other.satPerByte
                }
                if other.hasPrivate {
                    private = other.private
                }
                if other.hasMinHtlcMsat {
                    minHtlcMsat = other.minHtlcMsat
                }
                if other.hasRemoteCsvDelay {
                    remoteCsvDelay = other.remoteCsvDelay
                }
                if other.hasMinConfs {
                    minConfs = other.minConfs
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.OpenChannelRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.OpenChannelRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 18:
                        nodePubkey = try codedInputStream.readData()

                    case 26:
                        nodePubkeyString = try codedInputStream.readString()

                    case 32:
                        localFundingAmount = try codedInputStream.readInt64()

                    case 40:
                        pushSat = try codedInputStream.readInt64()

                    case 48:
                        targetConf = try codedInputStream.readInt32()

                    case 56:
                        satPerByte = try codedInputStream.readInt64()

                    case 64:
                        private = try codedInputStream.readBool()

                    case 72:
                        minHtlcMsat = try codedInputStream.readInt64()

                    case 80:
                        remoteCsvDelay = try codedInputStream.readUInt32()

                    case 88:
                        minConfs = try codedInputStream.readInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.OpenChannelRequest.Builder {
                let resultDecodedBuilder = Lnrpc.OpenChannelRequest.Builder()
                if let jsonValueNodePubkey = jsonMap["node_pubkey"] as? String {
                    resultDecodedBuilder.nodePubkey = Data(base64Encoded:jsonValueNodePubkey, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueNodePubkeyString = jsonMap["node_pubkey_string"] as? String {
                    resultDecodedBuilder.nodePubkeyString = jsonValueNodePubkeyString
                }
                if let jsonValueLocalFundingAmount = jsonMap["local_funding_amount"] as? String {
                    resultDecodedBuilder.localFundingAmount = Int64(jsonValueLocalFundingAmount)!
                } else if let jsonValueLocalFundingAmount = jsonMap["local_funding_amount"] as? Int {
                    resultDecodedBuilder.localFundingAmount = Int64(jsonValueLocalFundingAmount)
                }
                if let jsonValuePushSat = jsonMap["push_sat"] as? String {
                    resultDecodedBuilder.pushSat = Int64(jsonValuePushSat)!
                } else if let jsonValuePushSat = jsonMap["push_sat"] as? Int {
                    resultDecodedBuilder.pushSat = Int64(jsonValuePushSat)
                }
                if let jsonValueTargetConf = jsonMap["targetConf"] as? Int {
                    resultDecodedBuilder.targetConf = Int32(jsonValueTargetConf)
                } else if let jsonValueTargetConf = jsonMap["targetConf"] as? String {
                    resultDecodedBuilder.targetConf = Int32(jsonValueTargetConf)!
                }
                if let jsonValueSatPerByte = jsonMap["satPerByte"] as? String {
                    resultDecodedBuilder.satPerByte = Int64(jsonValueSatPerByte)!
                } else if let jsonValueSatPerByte = jsonMap["satPerByte"] as? Int {
                    resultDecodedBuilder.satPerByte = Int64(jsonValueSatPerByte)
                }
                if let jsonValuePrivate = jsonMap["private"] as? Bool {
                    resultDecodedBuilder.private = jsonValuePrivate
                }
                if let jsonValueMinHtlcMsat = jsonMap["min_htlc_msat"] as? String {
                    resultDecodedBuilder.minHtlcMsat = Int64(jsonValueMinHtlcMsat)!
                } else if let jsonValueMinHtlcMsat = jsonMap["min_htlc_msat"] as? Int {
                    resultDecodedBuilder.minHtlcMsat = Int64(jsonValueMinHtlcMsat)
                }
                if let jsonValueRemoteCsvDelay = jsonMap["remote_csv_delay"] as? UInt {
                    resultDecodedBuilder.remoteCsvDelay = UInt32(jsonValueRemoteCsvDelay)
                } else if let jsonValueRemoteCsvDelay = jsonMap["remote_csv_delay"] as? String {
                    resultDecodedBuilder.remoteCsvDelay = UInt32(jsonValueRemoteCsvDelay)!
                }
                if let jsonValueMinConfs = jsonMap["min_confs"] as? Int {
                    resultDecodedBuilder.minConfs = Int32(jsonValueMinConfs)
                } else if let jsonValueMinConfs = jsonMap["min_confs"] as? String {
                    resultDecodedBuilder.minConfs = Int32(jsonValueMinConfs)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.OpenChannelRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.OpenChannelRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class OpenStatusUpdate : GeneratedMessage {
        public typealias BuilderType = Lnrpc.OpenStatusUpdate.Builder

        public static func == (lhs: Lnrpc.OpenStatusUpdate, rhs: Lnrpc.OpenStatusUpdate) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasChanPending == rhs.hasChanPending) && (!lhs.hasChanPending || lhs.chanPending == rhs.chanPending)
            fieldCheck = fieldCheck && (lhs.hasConfirmation == rhs.hasConfirmation) && (!lhs.hasConfirmation || lhs.confirmation == rhs.confirmation)
            fieldCheck = fieldCheck && (lhs.hasChanOpen == rhs.hasChanOpen) && (!lhs.hasChanOpen || lhs.chanOpen == rhs.chanOpen)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        public enum Update {
            case oneOfUpdateNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .oneOfUpdateNotSet: return false
                default: return true
                }
            }
            case chanPending(Lnrpc.PendingUpdate)

            public static func getChanPending(_ value:Update) -> Lnrpc.PendingUpdate? {
                switch value {
                case .chanPending(let messageValue): return messageValue
                default: return nil
                }
            }
            public func getChanPending() -> Lnrpc.PendingUpdate? {
                switch self {
                case .chanPending(let messageValue): return messageValue
                default: return nil
                }
            }
            case confirmation(Lnrpc.ConfirmationUpdate)

            public static func getConfirmation(_ value:Update) -> Lnrpc.ConfirmationUpdate? {
                switch value {
                case .confirmation(let messageValue): return messageValue
                default: return nil
                }
            }
            public func getConfirmation() -> Lnrpc.ConfirmationUpdate? {
                switch self {
                case .confirmation(let messageValue): return messageValue
                default: return nil
                }
            }
            case chanOpen(Lnrpc.ChannelOpenUpdate)

            public static func getChanOpen(_ value:Update) -> Lnrpc.ChannelOpenUpdate? {
                switch value {
                case .chanOpen(let messageValue): return messageValue
                default: return nil
                }
            }
            public func getChanOpen() -> Lnrpc.ChannelOpenUpdate? {
                switch self {
                case .chanOpen(let messageValue): return messageValue
                default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageUpdate:OpenStatusUpdate.Update =  OpenStatusUpdate.Update.oneOfUpdateNotSet
        public func getOneOfUpdate() ->  OpenStatusUpdate.Update {
            let copyObjectUpdate = storageUpdate
            return copyObjectUpdate
        }
        public fileprivate(set) var chanPending:Lnrpc.PendingUpdate!{
            get {
                return OpenStatusUpdate.Update.getChanPending(storageUpdate)
            }
            set (newvalue) {
                storageUpdate = OpenStatusUpdate.Update.chanPending(newvalue)
            }
        }
        public fileprivate(set) var hasChanPending:Bool {
            get {
                return OpenStatusUpdate.Update.getChanPending(storageUpdate) != nil
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var confirmation:Lnrpc.ConfirmationUpdate!{
            get {
                return OpenStatusUpdate.Update.getConfirmation(storageUpdate)
            }
            set (newvalue) {
                storageUpdate = OpenStatusUpdate.Update.confirmation(newvalue)
            }
        }
        public fileprivate(set) var hasConfirmation:Bool {
            get {
                return OpenStatusUpdate.Update.getConfirmation(storageUpdate) != nil
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var chanOpen:Lnrpc.ChannelOpenUpdate!{
            get {
                return OpenStatusUpdate.Update.getChanOpen(storageUpdate)
            }
            set (newvalue) {
                storageUpdate = OpenStatusUpdate.Update.chanOpen(newvalue)
            }
        }
        public fileprivate(set) var hasChanOpen:Bool {
            get {
                return OpenStatusUpdate.Update.getChanOpen(storageUpdate) != nil
            }
            set(newValue) {
            }
        }
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasChanPending {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:chanPending)
            }
            if hasConfirmation {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:confirmation)
            }
            if hasChanOpen {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:chanOpen)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasChanPending {
                if let varSizechanPending = chanPending?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizechanPending
                }
            }
            if hasConfirmation {
                if let varSizeconfirmation = confirmation?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeconfirmation
                }
            }
            if hasChanOpen {
                if let varSizechanOpen = chanOpen?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizechanOpen
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.OpenStatusUpdate.Builder {
            return Lnrpc.OpenStatusUpdate.classBuilder() as! Lnrpc.OpenStatusUpdate.Builder
        }
        public func getBuilder() -> Lnrpc.OpenStatusUpdate.Builder {
            return classBuilder() as! Lnrpc.OpenStatusUpdate.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.OpenStatusUpdate.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.OpenStatusUpdate.Builder()
        }
        public func toBuilder() throws -> Lnrpc.OpenStatusUpdate.Builder {
            return try Lnrpc.OpenStatusUpdate.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.OpenStatusUpdate) throws -> Lnrpc.OpenStatusUpdate.Builder {
            return try Lnrpc.OpenStatusUpdate.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasChanPending {
                jsonMap["chan_pending"] = try chanPending.encode()
            }
            if hasConfirmation {
                jsonMap["confirmation"] = try confirmation.encode()
            }
            if hasChanOpen {
                jsonMap["chan_open"] = try chanOpen.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.OpenStatusUpdate {
            return try Lnrpc.OpenStatusUpdate.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.OpenStatusUpdate {
            return try Lnrpc.OpenStatusUpdate.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasChanPending {
                output += "\(indent) chanPending {\n"
                if let outDescChanPending = chanPending {
                    output += try outDescChanPending.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasConfirmation {
                output += "\(indent) confirmation {\n"
                if let outDescConfirmation = confirmation {
                    output += try outDescConfirmation.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasChanOpen {
                output += "\(indent) chanOpen {\n"
                if let outDescChanOpen = chanOpen {
                    output += try outDescChanOpen.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasChanPending {
                    if let hashValuechanPending = chanPending?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuechanPending
                    }
                }
                if hasConfirmation {
                    if let hashValueconfirmation = confirmation?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueconfirmation
                    }
                }
                if hasChanOpen {
                    if let hashValuechanOpen = chanOpen?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuechanOpen
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.OpenStatusUpdate"
        }
        override public func className() -> String {
            return "Lnrpc.OpenStatusUpdate"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.OpenStatusUpdate = Lnrpc.OpenStatusUpdate()
            public func getMessage() -> Lnrpc.OpenStatusUpdate {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public func setUpdate(_ oneOf:OpenStatusUpdate.Update) ->  Lnrpc.OpenStatusUpdate.Builder {
                builderResult.storageUpdate = oneOf
                return self
            }
            public var chanPending:Lnrpc.PendingUpdate! {
                get {
                    if chanPendingBuilder_ != nil {
                        builderResult.chanPending = chanPendingBuilder_.getMessage()
                    }
                    return builderResult.chanPending
                }
                set (value) {
                    builderResult.hasChanPending = value != nil
                    builderResult.chanPending = value
                }
            }
            public var hasChanPending:Bool {
                get {
                    return builderResult.hasChanPending
                }
            }
            fileprivate var chanPendingBuilder_:Lnrpc.PendingUpdate.Builder! {
                didSet {
                    builderResult.hasChanPending = true
                }
            }
            public func getChanPendingBuilder() -> Lnrpc.PendingUpdate.Builder {
                if chanPendingBuilder_ == nil {
                    chanPendingBuilder_ = Lnrpc.PendingUpdate.Builder()
                    builderResult.chanPending = chanPendingBuilder_.getMessage()
                    if chanPending != nil {
                        try! chanPendingBuilder_.mergeFrom(other: chanPending)
                    }
                }
                return chanPendingBuilder_
            }
            @discardableResult
            public func setChanPending(_ value:Lnrpc.PendingUpdate!) -> Lnrpc.OpenStatusUpdate.Builder {
                self.chanPending = value
                return self
            }
            @discardableResult
            public func mergeChanPending(value:Lnrpc.PendingUpdate) throws -> Lnrpc.OpenStatusUpdate.Builder {
                if builderResult.hasChanPending {
                    builderResult.chanPending = try Lnrpc.PendingUpdate.builderWithPrototype(prototype:builderResult.chanPending).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.chanPending = value
                }
                builderResult.hasChanPending = true
                return self
            }
            @discardableResult
            public func clearChanPending() -> Lnrpc.OpenStatusUpdate.Builder {
                chanPendingBuilder_ = nil
                builderResult.hasChanPending = false
                builderResult.chanPending = nil
                return self
            }
            public var confirmation:Lnrpc.ConfirmationUpdate! {
                get {
                    if confirmationBuilder_ != nil {
                        builderResult.confirmation = confirmationBuilder_.getMessage()
                    }
                    return builderResult.confirmation
                }
                set (value) {
                    builderResult.hasConfirmation = value != nil
                    builderResult.confirmation = value
                }
            }
            public var hasConfirmation:Bool {
                get {
                    return builderResult.hasConfirmation
                }
            }
            fileprivate var confirmationBuilder_:Lnrpc.ConfirmationUpdate.Builder! {
                didSet {
                    builderResult.hasConfirmation = true
                }
            }
            public func getConfirmationBuilder() -> Lnrpc.ConfirmationUpdate.Builder {
                if confirmationBuilder_ == nil {
                    confirmationBuilder_ = Lnrpc.ConfirmationUpdate.Builder()
                    builderResult.confirmation = confirmationBuilder_.getMessage()
                    if confirmation != nil {
                        try! confirmationBuilder_.mergeFrom(other: confirmation)
                    }
                }
                return confirmationBuilder_
            }
            @discardableResult
            public func setConfirmation(_ value:Lnrpc.ConfirmationUpdate!) -> Lnrpc.OpenStatusUpdate.Builder {
                self.confirmation = value
                return self
            }
            @discardableResult
            public func mergeConfirmation(value:Lnrpc.ConfirmationUpdate) throws -> Lnrpc.OpenStatusUpdate.Builder {
                if builderResult.hasConfirmation {
                    builderResult.confirmation = try Lnrpc.ConfirmationUpdate.builderWithPrototype(prototype:builderResult.confirmation).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.confirmation = value
                }
                builderResult.hasConfirmation = true
                return self
            }
            @discardableResult
            public func clearConfirmation() -> Lnrpc.OpenStatusUpdate.Builder {
                confirmationBuilder_ = nil
                builderResult.hasConfirmation = false
                builderResult.confirmation = nil
                return self
            }
            public var chanOpen:Lnrpc.ChannelOpenUpdate! {
                get {
                    if chanOpenBuilder_ != nil {
                        builderResult.chanOpen = chanOpenBuilder_.getMessage()
                    }
                    return builderResult.chanOpen
                }
                set (value) {
                    builderResult.hasChanOpen = value != nil
                    builderResult.chanOpen = value
                }
            }
            public var hasChanOpen:Bool {
                get {
                    return builderResult.hasChanOpen
                }
            }
            fileprivate var chanOpenBuilder_:Lnrpc.ChannelOpenUpdate.Builder! {
                didSet {
                    builderResult.hasChanOpen = true
                }
            }
            public func getChanOpenBuilder() -> Lnrpc.ChannelOpenUpdate.Builder {
                if chanOpenBuilder_ == nil {
                    chanOpenBuilder_ = Lnrpc.ChannelOpenUpdate.Builder()
                    builderResult.chanOpen = chanOpenBuilder_.getMessage()
                    if chanOpen != nil {
                        try! chanOpenBuilder_.mergeFrom(other: chanOpen)
                    }
                }
                return chanOpenBuilder_
            }
            @discardableResult
            public func setChanOpen(_ value:Lnrpc.ChannelOpenUpdate!) -> Lnrpc.OpenStatusUpdate.Builder {
                self.chanOpen = value
                return self
            }
            @discardableResult
            public func mergeChanOpen(value:Lnrpc.ChannelOpenUpdate) throws -> Lnrpc.OpenStatusUpdate.Builder {
                if builderResult.hasChanOpen {
                    builderResult.chanOpen = try Lnrpc.ChannelOpenUpdate.builderWithPrototype(prototype:builderResult.chanOpen).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.chanOpen = value
                }
                builderResult.hasChanOpen = true
                return self
            }
            @discardableResult
            public func clearChanOpen() -> Lnrpc.OpenStatusUpdate.Builder {
                chanOpenBuilder_ = nil
                builderResult.hasChanOpen = false
                builderResult.chanOpen = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.OpenStatusUpdate.Builder {
                builderResult = Lnrpc.OpenStatusUpdate()
                return self
            }
            override public func clone() throws -> Lnrpc.OpenStatusUpdate.Builder {
                return try Lnrpc.OpenStatusUpdate.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.OpenStatusUpdate {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.OpenStatusUpdate {
                let returnMe:Lnrpc.OpenStatusUpdate = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.OpenStatusUpdate) throws -> Lnrpc.OpenStatusUpdate.Builder {
                if other == Lnrpc.OpenStatusUpdate() {
                    return self
                }
                if (other.hasChanPending) {
                    try mergeChanPending(value: other.chanPending)
                }
                if (other.hasConfirmation) {
                    try mergeConfirmation(value: other.confirmation)
                }
                if (other.hasChanOpen) {
                    try mergeChanOpen(value: other.chanOpen)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.OpenStatusUpdate.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.OpenStatusUpdate.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Lnrpc.PendingUpdate.Builder = Lnrpc.PendingUpdate.Builder()
                        if hasChanPending {
                            try subBuilder.mergeFrom(other: chanPending)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        chanPending = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:Lnrpc.ConfirmationUpdate.Builder = Lnrpc.ConfirmationUpdate.Builder()
                        if hasConfirmation {
                            try subBuilder.mergeFrom(other: confirmation)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        confirmation = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Lnrpc.ChannelOpenUpdate.Builder = Lnrpc.ChannelOpenUpdate.Builder()
                        if hasChanOpen {
                            try subBuilder.mergeFrom(other: chanOpen)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        chanOpen = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.OpenStatusUpdate.Builder {
                let resultDecodedBuilder = Lnrpc.OpenStatusUpdate.Builder()
                if let jsonValueChanPending = jsonMap["chan_pending"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.chanPending = try Lnrpc.PendingUpdate.Builder.decodeToBuilder(jsonMap:jsonValueChanPending).build()

                }
                if let jsonValueConfirmation = jsonMap["confirmation"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.confirmation = try Lnrpc.ConfirmationUpdate.Builder.decodeToBuilder(jsonMap:jsonValueConfirmation).build()

                }
                if let jsonValueChanOpen = jsonMap["chan_open"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.chanOpen = try Lnrpc.ChannelOpenUpdate.Builder.decodeToBuilder(jsonMap:jsonValueChanOpen).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.OpenStatusUpdate.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.OpenStatusUpdate.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class PendingHtlc : GeneratedMessage {
        public typealias BuilderType = Lnrpc.PendingHtlc.Builder

        public static func == (lhs: Lnrpc.PendingHtlc, rhs: Lnrpc.PendingHtlc) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasIncoming == rhs.hasIncoming) && (!lhs.hasIncoming || lhs.incoming == rhs.incoming)
            fieldCheck = fieldCheck && (lhs.hasAmount == rhs.hasAmount) && (!lhs.hasAmount || lhs.amount == rhs.amount)
            fieldCheck = fieldCheck && (lhs.hasOutpoint == rhs.hasOutpoint) && (!lhs.hasOutpoint || lhs.outpoint == rhs.outpoint)
            fieldCheck = fieldCheck && (lhs.hasMaturityHeight == rhs.hasMaturityHeight) && (!lhs.hasMaturityHeight || lhs.maturityHeight == rhs.maturityHeight)
            fieldCheck = fieldCheck && (lhs.hasBlocksTilMaturity == rhs.hasBlocksTilMaturity) && (!lhs.hasBlocksTilMaturity || lhs.blocksTilMaturity == rhs.blocksTilMaturity)
            fieldCheck = fieldCheck && (lhs.hasStage == rhs.hasStage) && (!lhs.hasStage || lhs.stage == rhs.stage)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// The direction within the channel that the htlc was sent
        public fileprivate(set) var incoming:Bool! = nil
        public fileprivate(set) var hasIncoming:Bool = false

        //// The total value of the htlc
        public fileprivate(set) var amount:Int64! = nil
        public fileprivate(set) var hasAmount:Bool = false

        //// The final output to be swept back to the user's wallet
        public fileprivate(set) var outpoint:String! = nil
        public fileprivate(set) var hasOutpoint:Bool = false

        //// The next block height at which we can spend the current stage
        public fileprivate(set) var maturityHeight:UInt32! = nil
        public fileprivate(set) var hasMaturityHeight:Bool = false

        ///*
        ///The number of blocks remaining until the current stage can be swept.
        ///Negative values indicate how many blocks have passed since becoming
        ///mature.
        public fileprivate(set) var blocksTilMaturity:Int32! = nil
        public fileprivate(set) var hasBlocksTilMaturity:Bool = false

        //// Indicates whether the htlc is in its first or second stage of recovery
        public fileprivate(set) var stage:UInt32! = nil
        public fileprivate(set) var hasStage:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasIncoming {
                try codedOutputStream.writeBool(fieldNumber: 1, value:incoming)
            }
            if hasAmount {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:amount)
            }
            if hasOutpoint {
                try codedOutputStream.writeString(fieldNumber: 3, value:outpoint)
            }
            if hasMaturityHeight {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:maturityHeight)
            }
            if hasBlocksTilMaturity {
                try codedOutputStream.writeInt32(fieldNumber: 5, value:blocksTilMaturity)
            }
            if hasStage {
                try codedOutputStream.writeUInt32(fieldNumber: 6, value:stage)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasIncoming {
                serialize_size += incoming.computeBoolSize(fieldNumber: 1)
            }
            if hasAmount {
                serialize_size += amount.computeInt64Size(fieldNumber: 2)
            }
            if hasOutpoint {
                serialize_size += outpoint.computeStringSize(fieldNumber: 3)
            }
            if hasMaturityHeight {
                serialize_size += maturityHeight.computeUInt32Size(fieldNumber: 4)
            }
            if hasBlocksTilMaturity {
                serialize_size += blocksTilMaturity.computeInt32Size(fieldNumber: 5)
            }
            if hasStage {
                serialize_size += stage.computeUInt32Size(fieldNumber: 6)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.PendingHtlc.Builder {
            return Lnrpc.PendingHtlc.classBuilder() as! Lnrpc.PendingHtlc.Builder
        }
        public func getBuilder() -> Lnrpc.PendingHtlc.Builder {
            return classBuilder() as! Lnrpc.PendingHtlc.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.PendingHtlc.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.PendingHtlc.Builder()
        }
        public func toBuilder() throws -> Lnrpc.PendingHtlc.Builder {
            return try Lnrpc.PendingHtlc.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.PendingHtlc) throws -> Lnrpc.PendingHtlc.Builder {
            return try Lnrpc.PendingHtlc.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasIncoming {
                jsonMap["incoming"] = incoming
            }
            if hasAmount {
                jsonMap["amount"] = "\(amount!)"
            }
            if hasOutpoint {
                jsonMap["outpoint"] = outpoint
            }
            if hasMaturityHeight {
                jsonMap["maturity_height"] = UInt(maturityHeight)
            }
            if hasBlocksTilMaturity {
                jsonMap["blocks_til_maturity"] = Int(blocksTilMaturity)
            }
            if hasStage {
                jsonMap["stage"] = UInt(stage)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PendingHtlc {
            return try Lnrpc.PendingHtlc.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PendingHtlc {
            return try Lnrpc.PendingHtlc.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasIncoming {
                output += "\(indent) incoming: \(incoming) \n"
            }
            if hasAmount {
                output += "\(indent) amount: \(amount) \n"
            }
            if hasOutpoint {
                output += "\(indent) outpoint: \(outpoint) \n"
            }
            if hasMaturityHeight {
                output += "\(indent) maturityHeight: \(maturityHeight) \n"
            }
            if hasBlocksTilMaturity {
                output += "\(indent) blocksTilMaturity: \(blocksTilMaturity) \n"
            }
            if hasStage {
                output += "\(indent) stage: \(stage) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasIncoming {
                    hashCode = (hashCode &* 31) &+ incoming.hashValue
                }
                if hasAmount {
                    hashCode = (hashCode &* 31) &+ amount.hashValue
                }
                if hasOutpoint {
                    hashCode = (hashCode &* 31) &+ outpoint.hashValue
                }
                if hasMaturityHeight {
                    hashCode = (hashCode &* 31) &+ maturityHeight.hashValue
                }
                if hasBlocksTilMaturity {
                    hashCode = (hashCode &* 31) &+ blocksTilMaturity.hashValue
                }
                if hasStage {
                    hashCode = (hashCode &* 31) &+ stage.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.PendingHtlc"
        }
        override public func className() -> String {
            return "Lnrpc.PendingHtlc"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.PendingHtlc = Lnrpc.PendingHtlc()
            public func getMessage() -> Lnrpc.PendingHtlc {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The direction within the channel that the htlc was sent
            public var incoming:Bool {
                get {
                    return builderResult.incoming
                }
                set (value) {
                    builderResult.hasIncoming = true
                    builderResult.incoming = value
                }
            }
            public var hasIncoming:Bool {
                get {
                    return builderResult.hasIncoming
                }
            }
            @discardableResult
            public func setIncoming(_ value:Bool) -> Lnrpc.PendingHtlc.Builder {
                self.incoming = value
                return self
            }
            @discardableResult
            public func clearIncoming() -> Lnrpc.PendingHtlc.Builder{
                builderResult.hasIncoming = false
                builderResult.incoming = nil
                return self
            }
            //// The total value of the htlc
            public var amount:Int64 {
                get {
                    return builderResult.amount
                }
                set (value) {
                    builderResult.hasAmount = true
                    builderResult.amount = value
                }
            }
            public var hasAmount:Bool {
                get {
                    return builderResult.hasAmount
                }
            }
            @discardableResult
            public func setAmount(_ value:Int64) -> Lnrpc.PendingHtlc.Builder {
                self.amount = value
                return self
            }
            @discardableResult
            public func clearAmount() -> Lnrpc.PendingHtlc.Builder{
                builderResult.hasAmount = false
                builderResult.amount = nil
                return self
            }
            //// The final output to be swept back to the user's wallet
            public var outpoint:String {
                get {
                    return builderResult.outpoint
                }
                set (value) {
                    builderResult.hasOutpoint = true
                    builderResult.outpoint = value
                }
            }
            public var hasOutpoint:Bool {
                get {
                    return builderResult.hasOutpoint
                }
            }
            @discardableResult
            public func setOutpoint(_ value:String) -> Lnrpc.PendingHtlc.Builder {
                self.outpoint = value
                return self
            }
            @discardableResult
            public func clearOutpoint() -> Lnrpc.PendingHtlc.Builder{
                builderResult.hasOutpoint = false
                builderResult.outpoint = nil
                return self
            }
            //// The next block height at which we can spend the current stage
            public var maturityHeight:UInt32 {
                get {
                    return builderResult.maturityHeight
                }
                set (value) {
                    builderResult.hasMaturityHeight = true
                    builderResult.maturityHeight = value
                }
            }
            public var hasMaturityHeight:Bool {
                get {
                    return builderResult.hasMaturityHeight
                }
            }
            @discardableResult
            public func setMaturityHeight(_ value:UInt32) -> Lnrpc.PendingHtlc.Builder {
                self.maturityHeight = value
                return self
            }
            @discardableResult
            public func clearMaturityHeight() -> Lnrpc.PendingHtlc.Builder{
                builderResult.hasMaturityHeight = false
                builderResult.maturityHeight = nil
                return self
            }
            ///*
            ///The number of blocks remaining until the current stage can be swept.
            ///Negative values indicate how many blocks have passed since becoming
            ///mature.
            public var blocksTilMaturity:Int32 {
                get {
                    return builderResult.blocksTilMaturity
                }
                set (value) {
                    builderResult.hasBlocksTilMaturity = true
                    builderResult.blocksTilMaturity = value
                }
            }
            public var hasBlocksTilMaturity:Bool {
                get {
                    return builderResult.hasBlocksTilMaturity
                }
            }
            @discardableResult
            public func setBlocksTilMaturity(_ value:Int32) -> Lnrpc.PendingHtlc.Builder {
                self.blocksTilMaturity = value
                return self
            }
            @discardableResult
            public func clearBlocksTilMaturity() -> Lnrpc.PendingHtlc.Builder{
                builderResult.hasBlocksTilMaturity = false
                builderResult.blocksTilMaturity = nil
                return self
            }
            //// Indicates whether the htlc is in its first or second stage of recovery
            public var stage:UInt32 {
                get {
                    return builderResult.stage
                }
                set (value) {
                    builderResult.hasStage = true
                    builderResult.stage = value
                }
            }
            public var hasStage:Bool {
                get {
                    return builderResult.hasStage
                }
            }
            @discardableResult
            public func setStage(_ value:UInt32) -> Lnrpc.PendingHtlc.Builder {
                self.stage = value
                return self
            }
            @discardableResult
            public func clearStage() -> Lnrpc.PendingHtlc.Builder{
                builderResult.hasStage = false
                builderResult.stage = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.PendingHtlc.Builder {
                builderResult = Lnrpc.PendingHtlc()
                return self
            }
            override public func clone() throws -> Lnrpc.PendingHtlc.Builder {
                return try Lnrpc.PendingHtlc.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.PendingHtlc {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.PendingHtlc {
                let returnMe:Lnrpc.PendingHtlc = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.PendingHtlc) throws -> Lnrpc.PendingHtlc.Builder {
                if other == Lnrpc.PendingHtlc() {
                    return self
                }
                if other.hasIncoming {
                    incoming = other.incoming
                }
                if other.hasAmount {
                    amount = other.amount
                }
                if other.hasOutpoint {
                    outpoint = other.outpoint
                }
                if other.hasMaturityHeight {
                    maturityHeight = other.maturityHeight
                }
                if other.hasBlocksTilMaturity {
                    blocksTilMaturity = other.blocksTilMaturity
                }
                if other.hasStage {
                    stage = other.stage
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PendingHtlc.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingHtlc.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        incoming = try codedInputStream.readBool()

                    case 16:
                        amount = try codedInputStream.readInt64()

                    case 26:
                        outpoint = try codedInputStream.readString()

                    case 32:
                        maturityHeight = try codedInputStream.readUInt32()

                    case 40:
                        blocksTilMaturity = try codedInputStream.readInt32()

                    case 48:
                        stage = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PendingHtlc.Builder {
                let resultDecodedBuilder = Lnrpc.PendingHtlc.Builder()
                if let jsonValueIncoming = jsonMap["incoming"] as? Bool {
                    resultDecodedBuilder.incoming = jsonValueIncoming
                }
                if let jsonValueAmount = jsonMap["amount"] as? String {
                    resultDecodedBuilder.amount = Int64(jsonValueAmount)!
                } else if let jsonValueAmount = jsonMap["amount"] as? Int {
                    resultDecodedBuilder.amount = Int64(jsonValueAmount)
                }
                if let jsonValueOutpoint = jsonMap["outpoint"] as? String {
                    resultDecodedBuilder.outpoint = jsonValueOutpoint
                }
                if let jsonValueMaturityHeight = jsonMap["maturity_height"] as? UInt {
                    resultDecodedBuilder.maturityHeight = UInt32(jsonValueMaturityHeight)
                } else if let jsonValueMaturityHeight = jsonMap["maturity_height"] as? String {
                    resultDecodedBuilder.maturityHeight = UInt32(jsonValueMaturityHeight)!
                }
                if let jsonValueBlocksTilMaturity = jsonMap["blocks_til_maturity"] as? Int {
                    resultDecodedBuilder.blocksTilMaturity = Int32(jsonValueBlocksTilMaturity)
                } else if let jsonValueBlocksTilMaturity = jsonMap["blocks_til_maturity"] as? String {
                    resultDecodedBuilder.blocksTilMaturity = Int32(jsonValueBlocksTilMaturity)!
                }
                if let jsonValueStage = jsonMap["stage"] as? UInt {
                    resultDecodedBuilder.stage = UInt32(jsonValueStage)
                } else if let jsonValueStage = jsonMap["stage"] as? String {
                    resultDecodedBuilder.stage = UInt32(jsonValueStage)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PendingHtlc.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.PendingHtlc.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class PendingChannelsRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.PendingChannelsRequest.Builder

        public static func == (lhs: Lnrpc.PendingChannelsRequest, rhs: Lnrpc.PendingChannelsRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.PendingChannelsRequest.Builder {
            return Lnrpc.PendingChannelsRequest.classBuilder() as! Lnrpc.PendingChannelsRequest.Builder
        }
        public func getBuilder() -> Lnrpc.PendingChannelsRequest.Builder {
            return classBuilder() as! Lnrpc.PendingChannelsRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.PendingChannelsRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.PendingChannelsRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.PendingChannelsRequest.Builder {
            return try Lnrpc.PendingChannelsRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.PendingChannelsRequest) throws -> Lnrpc.PendingChannelsRequest.Builder {
            return try Lnrpc.PendingChannelsRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PendingChannelsRequest {
            return try Lnrpc.PendingChannelsRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PendingChannelsRequest {
            return try Lnrpc.PendingChannelsRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.PendingChannelsRequest"
        }
        override public func className() -> String {
            return "Lnrpc.PendingChannelsRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.PendingChannelsRequest = Lnrpc.PendingChannelsRequest()
            public func getMessage() -> Lnrpc.PendingChannelsRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.PendingChannelsRequest.Builder {
                builderResult = Lnrpc.PendingChannelsRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.PendingChannelsRequest.Builder {
                return try Lnrpc.PendingChannelsRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.PendingChannelsRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.PendingChannelsRequest {
                let returnMe:Lnrpc.PendingChannelsRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.PendingChannelsRequest) throws -> Lnrpc.PendingChannelsRequest.Builder {
                if other == Lnrpc.PendingChannelsRequest() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PendingChannelsRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PendingChannelsRequest.Builder {
                let resultDecodedBuilder = Lnrpc.PendingChannelsRequest.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PendingChannelsRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.PendingChannelsRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class PendingChannelsResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.PendingChannelsResponse.Builder

        public static func == (lhs: Lnrpc.PendingChannelsResponse, rhs: Lnrpc.PendingChannelsResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTotalLimboBalance == rhs.hasTotalLimboBalance) && (!lhs.hasTotalLimboBalance || lhs.totalLimboBalance == rhs.totalLimboBalance)
            fieldCheck = fieldCheck && (lhs.pendingOpenChannels == rhs.pendingOpenChannels)
            fieldCheck = fieldCheck && (lhs.pendingClosingChannels == rhs.pendingClosingChannels)
            fieldCheck = fieldCheck && (lhs.pendingForceClosingChannels == rhs.pendingForceClosingChannels)
            fieldCheck = fieldCheck && (lhs.waitingCloseChannels == rhs.waitingCloseChannels)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class PendingChannel : GeneratedMessage {
            public typealias BuilderType = Lnrpc.PendingChannelsResponse.PendingChannel.Builder

            public static func == (lhs: Lnrpc.PendingChannelsResponse.PendingChannel, rhs: Lnrpc.PendingChannelsResponse.PendingChannel) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasRemoteNodePub == rhs.hasRemoteNodePub) && (!lhs.hasRemoteNodePub || lhs.remoteNodePub == rhs.remoteNodePub)
                fieldCheck = fieldCheck && (lhs.hasChannelPoint == rhs.hasChannelPoint) && (!lhs.hasChannelPoint || lhs.channelPoint == rhs.channelPoint)
                fieldCheck = fieldCheck && (lhs.hasCapacity == rhs.hasCapacity) && (!lhs.hasCapacity || lhs.capacity == rhs.capacity)
                fieldCheck = fieldCheck && (lhs.hasLocalBalance == rhs.hasLocalBalance) && (!lhs.hasLocalBalance || lhs.localBalance == rhs.localBalance)
                fieldCheck = fieldCheck && (lhs.hasRemoteBalance == rhs.hasRemoteBalance) && (!lhs.hasRemoteBalance || lhs.remoteBalance == rhs.remoteBalance)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var remoteNodePub:String! = nil
            public fileprivate(set) var hasRemoteNodePub:Bool = false

            public fileprivate(set) var channelPoint:String! = nil
            public fileprivate(set) var hasChannelPoint:Bool = false

            public fileprivate(set) var capacity:Int64! = nil
            public fileprivate(set) var hasCapacity:Bool = false

            public fileprivate(set) var localBalance:Int64! = nil
            public fileprivate(set) var hasLocalBalance:Bool = false

            public fileprivate(set) var remoteBalance:Int64! = nil
            public fileprivate(set) var hasRemoteBalance:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() throws {
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasRemoteNodePub {
                    try codedOutputStream.writeString(fieldNumber: 1, value:remoteNodePub)
                }
                if hasChannelPoint {
                    try codedOutputStream.writeString(fieldNumber: 2, value:channelPoint)
                }
                if hasCapacity {
                    try codedOutputStream.writeInt64(fieldNumber: 3, value:capacity)
                }
                if hasLocalBalance {
                    try codedOutputStream.writeInt64(fieldNumber: 4, value:localBalance)
                }
                if hasRemoteBalance {
                    try codedOutputStream.writeInt64(fieldNumber: 5, value:remoteBalance)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasRemoteNodePub {
                    serialize_size += remoteNodePub.computeStringSize(fieldNumber: 1)
                }
                if hasChannelPoint {
                    serialize_size += channelPoint.computeStringSize(fieldNumber: 2)
                }
                if hasCapacity {
                    serialize_size += capacity.computeInt64Size(fieldNumber: 3)
                }
                if hasLocalBalance {
                    serialize_size += localBalance.computeInt64Size(fieldNumber: 4)
                }
                if hasRemoteBalance {
                    serialize_size += remoteBalance.computeInt64Size(fieldNumber: 5)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder {
                return Lnrpc.PendingChannelsResponse.PendingChannel.classBuilder() as! Lnrpc.PendingChannelsResponse.PendingChannel.Builder
            }
            public func getBuilder() -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder {
                return classBuilder() as! Lnrpc.PendingChannelsResponse.PendingChannel.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Lnrpc.PendingChannelsResponse.PendingChannel.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Lnrpc.PendingChannelsResponse.PendingChannel.Builder()
            }
            public func toBuilder() throws -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder {
                return try Lnrpc.PendingChannelsResponse.PendingChannel.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Lnrpc.PendingChannelsResponse.PendingChannel) throws -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder {
                return try Lnrpc.PendingChannelsResponse.PendingChannel.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                try isInitialized()
                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasRemoteNodePub {
                    jsonMap["remote_node_pub"] = remoteNodePub
                }
                if hasChannelPoint {
                    jsonMap["channel_point"] = channelPoint
                }
                if hasCapacity {
                    jsonMap["capacity"] = "\(capacity!)"
                }
                if hasLocalBalance {
                    jsonMap["local_balance"] = "\(localBalance!)"
                }
                if hasRemoteBalance {
                    jsonMap["remote_balance"] = "\(remoteBalance!)"
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PendingChannelsResponse.PendingChannel {
                return try Lnrpc.PendingChannelsResponse.PendingChannel.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PendingChannelsResponse.PendingChannel {
                return try Lnrpc.PendingChannelsResponse.PendingChannel.Builder.fromJSONToBuilder(data:data, options:options).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasRemoteNodePub {
                    output += "\(indent) remoteNodePub: \(remoteNodePub) \n"
                }
                if hasChannelPoint {
                    output += "\(indent) channelPoint: \(channelPoint) \n"
                }
                if hasCapacity {
                    output += "\(indent) capacity: \(capacity) \n"
                }
                if hasLocalBalance {
                    output += "\(indent) localBalance: \(localBalance) \n"
                }
                if hasRemoteBalance {
                    output += "\(indent) remoteBalance: \(remoteBalance) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasRemoteNodePub {
                        hashCode = (hashCode &* 31) &+ remoteNodePub.hashValue
                    }
                    if hasChannelPoint {
                        hashCode = (hashCode &* 31) &+ channelPoint.hashValue
                    }
                    if hasCapacity {
                        hashCode = (hashCode &* 31) &+ capacity.hashValue
                    }
                    if hasLocalBalance {
                        hashCode = (hashCode &* 31) &+ localBalance.hashValue
                    }
                    if hasRemoteBalance {
                        hashCode = (hashCode &* 31) &+ remoteBalance.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Lnrpc.PendingChannelsResponse.PendingChannel"
            }
            override public func className() -> String {
                return "Lnrpc.PendingChannelsResponse.PendingChannel"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Lnrpc.PendingChannelsResponse.PendingChannel = Lnrpc.PendingChannelsResponse.PendingChannel()
                public func getMessage() -> Lnrpc.PendingChannelsResponse.PendingChannel {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var remoteNodePub:String {
                    get {
                        return builderResult.remoteNodePub
                    }
                    set (value) {
                        builderResult.hasRemoteNodePub = true
                        builderResult.remoteNodePub = value
                    }
                }
                public var hasRemoteNodePub:Bool {
                    get {
                        return builderResult.hasRemoteNodePub
                    }
                }
                @discardableResult
                public func setRemoteNodePub(_ value:String) -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder {
                    self.remoteNodePub = value
                    return self
                }
                @discardableResult
                public func clearRemoteNodePub() -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder{
                    builderResult.hasRemoteNodePub = false
                    builderResult.remoteNodePub = nil
                    return self
                }
                public var channelPoint:String {
                    get {
                        return builderResult.channelPoint
                    }
                    set (value) {
                        builderResult.hasChannelPoint = true
                        builderResult.channelPoint = value
                    }
                }
                public var hasChannelPoint:Bool {
                    get {
                        return builderResult.hasChannelPoint
                    }
                }
                @discardableResult
                public func setChannelPoint(_ value:String) -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder {
                    self.channelPoint = value
                    return self
                }
                @discardableResult
                public func clearChannelPoint() -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder{
                    builderResult.hasChannelPoint = false
                    builderResult.channelPoint = nil
                    return self
                }
                public var capacity:Int64 {
                    get {
                        return builderResult.capacity
                    }
                    set (value) {
                        builderResult.hasCapacity = true
                        builderResult.capacity = value
                    }
                }
                public var hasCapacity:Bool {
                    get {
                        return builderResult.hasCapacity
                    }
                }
                @discardableResult
                public func setCapacity(_ value:Int64) -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder {
                    self.capacity = value
                    return self
                }
                @discardableResult
                public func clearCapacity() -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder{
                    builderResult.hasCapacity = false
                    builderResult.capacity = nil
                    return self
                }
                public var localBalance:Int64 {
                    get {
                        return builderResult.localBalance
                    }
                    set (value) {
                        builderResult.hasLocalBalance = true
                        builderResult.localBalance = value
                    }
                }
                public var hasLocalBalance:Bool {
                    get {
                        return builderResult.hasLocalBalance
                    }
                }
                @discardableResult
                public func setLocalBalance(_ value:Int64) -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder {
                    self.localBalance = value
                    return self
                }
                @discardableResult
                public func clearLocalBalance() -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder{
                    builderResult.hasLocalBalance = false
                    builderResult.localBalance = nil
                    return self
                }
                public var remoteBalance:Int64 {
                    get {
                        return builderResult.remoteBalance
                    }
                    set (value) {
                        builderResult.hasRemoteBalance = true
                        builderResult.remoteBalance = value
                    }
                }
                public var hasRemoteBalance:Bool {
                    get {
                        return builderResult.hasRemoteBalance
                    }
                }
                @discardableResult
                public func setRemoteBalance(_ value:Int64) -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder {
                    self.remoteBalance = value
                    return self
                }
                @discardableResult
                public func clearRemoteBalance() -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder{
                    builderResult.hasRemoteBalance = false
                    builderResult.remoteBalance = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder {
                    builderResult = Lnrpc.PendingChannelsResponse.PendingChannel()
                    return self
                }
                override public func clone() throws -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder {
                    return try Lnrpc.PendingChannelsResponse.PendingChannel.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Lnrpc.PendingChannelsResponse.PendingChannel {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Lnrpc.PendingChannelsResponse.PendingChannel {
                    let returnMe:Lnrpc.PendingChannelsResponse.PendingChannel = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Lnrpc.PendingChannelsResponse.PendingChannel) throws -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder {
                    if other == Lnrpc.PendingChannelsResponse.PendingChannel() {
                        return self
                    }
                    if other.hasRemoteNodePub {
                        remoteNodePub = other.remoteNodePub
                    }
                    if other.hasChannelPoint {
                        channelPoint = other.channelPoint
                    }
                    if other.hasCapacity {
                        capacity = other.capacity
                    }
                    if other.hasLocalBalance {
                        localBalance = other.localBalance
                    }
                    if other.hasRemoteBalance {
                        remoteBalance = other.remoteBalance
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            remoteNodePub = try codedInputStream.readString()

                        case 18:
                            channelPoint = try codedInputStream.readString()

                        case 24:
                            capacity = try codedInputStream.readInt64()

                        case 32:
                            localBalance = try codedInputStream.readInt64()

                        case 40:
                            remoteBalance = try codedInputStream.readInt64()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder {
                    let resultDecodedBuilder = Lnrpc.PendingChannelsResponse.PendingChannel.Builder()
                    if let jsonValueRemoteNodePub = jsonMap["remote_node_pub"] as? String {
                        resultDecodedBuilder.remoteNodePub = jsonValueRemoteNodePub
                    }
                    if let jsonValueChannelPoint = jsonMap["channel_point"] as? String {
                        resultDecodedBuilder.channelPoint = jsonValueChannelPoint
                    }
                    if let jsonValueCapacity = jsonMap["capacity"] as? String {
                        resultDecodedBuilder.capacity = Int64(jsonValueCapacity)!
                    } else if let jsonValueCapacity = jsonMap["capacity"] as? Int {
                        resultDecodedBuilder.capacity = Int64(jsonValueCapacity)
                    }
                    if let jsonValueLocalBalance = jsonMap["local_balance"] as? String {
                        resultDecodedBuilder.localBalance = Int64(jsonValueLocalBalance)!
                    } else if let jsonValueLocalBalance = jsonMap["local_balance"] as? Int {
                        resultDecodedBuilder.localBalance = Int64(jsonValueLocalBalance)
                    }
                    if let jsonValueRemoteBalance = jsonMap["remote_balance"] as? String {
                        resultDecodedBuilder.remoteBalance = Int64(jsonValueRemoteBalance)!
                    } else if let jsonValueRemoteBalance = jsonMap["remote_balance"] as? Int {
                        resultDecodedBuilder.remoteBalance = Int64(jsonValueRemoteBalance)
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Lnrpc.PendingChannelsResponse.PendingChannel.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class PendingOpenChannel : GeneratedMessage {
            public typealias BuilderType = Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder

            public static func == (lhs: Lnrpc.PendingChannelsResponse.PendingOpenChannel, rhs: Lnrpc.PendingChannelsResponse.PendingOpenChannel) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasChannel == rhs.hasChannel) && (!lhs.hasChannel || lhs.channel == rhs.channel)
                fieldCheck = fieldCheck && (lhs.hasConfirmationHeight == rhs.hasConfirmationHeight) && (!lhs.hasConfirmationHeight || lhs.confirmationHeight == rhs.confirmationHeight)
                fieldCheck = fieldCheck && (lhs.hasCommitFee == rhs.hasCommitFee) && (!lhs.hasCommitFee || lhs.commitFee == rhs.commitFee)
                fieldCheck = fieldCheck && (lhs.hasCommitWeight == rhs.hasCommitWeight) && (!lhs.hasCommitWeight || lhs.commitWeight == rhs.commitWeight)
                fieldCheck = fieldCheck && (lhs.hasFeePerKw == rhs.hasFeePerKw) && (!lhs.hasFeePerKw || lhs.feePerKw == rhs.feePerKw)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var channel:Lnrpc.PendingChannelsResponse.PendingChannel!
            public fileprivate(set) var hasChannel:Bool = false
            //// The height at which this channel will be confirmed
            public fileprivate(set) var confirmationHeight:UInt32! = nil
            public fileprivate(set) var hasConfirmationHeight:Bool = false

            ///*
            ///The amount calculated to be paid in fees for the current set of
            ///commitment transactions. The fee amount is persisted with the channel
            ///in order to allow the fee amount to be removed and recalculated with
            ///each channel state update, including updates that happen after a system
            ///restart.
            public fileprivate(set) var commitFee:Int64! = nil
            public fileprivate(set) var hasCommitFee:Bool = false

            //// The weight of the commitment transaction
            public fileprivate(set) var commitWeight:Int64! = nil
            public fileprivate(set) var hasCommitWeight:Bool = false

            ///*
            ///The required number of satoshis per kilo-weight that the requester will
            ///pay at all times, for both the funding transaction and commitment
            ///transaction. This value can later be updated once the channel is open.
            public fileprivate(set) var feePerKw:Int64! = nil
            public fileprivate(set) var hasFeePerKw:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() throws {
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasChannel {
                    try codedOutputStream.writeMessage(fieldNumber: 1, value:channel)
                }
                if hasConfirmationHeight {
                    try codedOutputStream.writeUInt32(fieldNumber: 2, value:confirmationHeight)
                }
                if hasCommitFee {
                    try codedOutputStream.writeInt64(fieldNumber: 4, value:commitFee)
                }
                if hasCommitWeight {
                    try codedOutputStream.writeInt64(fieldNumber: 5, value:commitWeight)
                }
                if hasFeePerKw {
                    try codedOutputStream.writeInt64(fieldNumber: 6, value:feePerKw)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasChannel {
                    if let varSizechannel = channel?.computeMessageSize(fieldNumber: 1) {
                        serialize_size += varSizechannel
                    }
                }
                if hasConfirmationHeight {
                    serialize_size += confirmationHeight.computeUInt32Size(fieldNumber: 2)
                }
                if hasCommitFee {
                    serialize_size += commitFee.computeInt64Size(fieldNumber: 4)
                }
                if hasCommitWeight {
                    serialize_size += commitWeight.computeInt64Size(fieldNumber: 5)
                }
                if hasFeePerKw {
                    serialize_size += feePerKw.computeInt64Size(fieldNumber: 6)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder {
                return Lnrpc.PendingChannelsResponse.PendingOpenChannel.classBuilder() as! Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder
            }
            public func getBuilder() -> Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder {
                return classBuilder() as! Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder()
            }
            public func toBuilder() throws -> Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder {
                return try Lnrpc.PendingChannelsResponse.PendingOpenChannel.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Lnrpc.PendingChannelsResponse.PendingOpenChannel) throws -> Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder {
                return try Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                try isInitialized()
                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasChannel {
                    jsonMap["channel"] = try channel.encode()
                }
                if hasConfirmationHeight {
                    jsonMap["confirmation_height"] = UInt(confirmationHeight)
                }
                if hasCommitFee {
                    jsonMap["commit_fee"] = "\(commitFee!)"
                }
                if hasCommitWeight {
                    jsonMap["commit_weight"] = "\(commitWeight!)"
                }
                if hasFeePerKw {
                    jsonMap["fee_per_kw"] = "\(feePerKw!)"
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PendingChannelsResponse.PendingOpenChannel {
                return try Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PendingChannelsResponse.PendingOpenChannel {
                return try Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder.fromJSONToBuilder(data:data, options:options).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasChannel {
                    output += "\(indent) channel {\n"
                    if let outDescChannel = channel {
                        output += try outDescChannel.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                if hasConfirmationHeight {
                    output += "\(indent) confirmationHeight: \(confirmationHeight) \n"
                }
                if hasCommitFee {
                    output += "\(indent) commitFee: \(commitFee) \n"
                }
                if hasCommitWeight {
                    output += "\(indent) commitWeight: \(commitWeight) \n"
                }
                if hasFeePerKw {
                    output += "\(indent) feePerKw: \(feePerKw) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasChannel {
                        if let hashValuechannel = channel?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuechannel
                        }
                    }
                    if hasConfirmationHeight {
                        hashCode = (hashCode &* 31) &+ confirmationHeight.hashValue
                    }
                    if hasCommitFee {
                        hashCode = (hashCode &* 31) &+ commitFee.hashValue
                    }
                    if hasCommitWeight {
                        hashCode = (hashCode &* 31) &+ commitWeight.hashValue
                    }
                    if hasFeePerKw {
                        hashCode = (hashCode &* 31) &+ feePerKw.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Lnrpc.PendingChannelsResponse.PendingOpenChannel"
            }
            override public func className() -> String {
                return "Lnrpc.PendingChannelsResponse.PendingOpenChannel"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Lnrpc.PendingChannelsResponse.PendingOpenChannel = Lnrpc.PendingChannelsResponse.PendingOpenChannel()
                public func getMessage() -> Lnrpc.PendingChannelsResponse.PendingOpenChannel {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                //// The pending channel
                public var channel:Lnrpc.PendingChannelsResponse.PendingChannel! {
                    get {
                        if channelBuilder_ != nil {
                            builderResult.channel = channelBuilder_.getMessage()
                        }
                        return builderResult.channel
                    }
                    set (value) {
                        builderResult.hasChannel = value != nil
                        builderResult.channel = value
                    }
                }
                public var hasChannel:Bool {
                    get {
                        return builderResult.hasChannel
                    }
                }
                fileprivate var channelBuilder_:Lnrpc.PendingChannelsResponse.PendingChannel.Builder! {
                    didSet {
                        builderResult.hasChannel = true
                    }
                }
                public func getChannelBuilder() -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder {
                    if channelBuilder_ == nil {
                        channelBuilder_ = Lnrpc.PendingChannelsResponse.PendingChannel.Builder()
                        builderResult.channel = channelBuilder_.getMessage()
                        if channel != nil {
                            try! channelBuilder_.mergeFrom(other: channel)
                        }
                    }
                    return channelBuilder_
                }
                @discardableResult
                public func setChannel(_ value:Lnrpc.PendingChannelsResponse.PendingChannel!) -> Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder {
                    self.channel = value
                    return self
                }
                @discardableResult
                public func mergeChannel(value:Lnrpc.PendingChannelsResponse.PendingChannel) throws -> Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder {
                    if builderResult.hasChannel {
                        builderResult.channel = try Lnrpc.PendingChannelsResponse.PendingChannel.builderWithPrototype(prototype:builderResult.channel).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.channel = value
                    }
                    builderResult.hasChannel = true
                    return self
                }
                @discardableResult
                public func clearChannel() -> Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder {
                    channelBuilder_ = nil
                    builderResult.hasChannel = false
                    builderResult.channel = nil
                    return self
                }
                //// The height at which this channel will be confirmed
                public var confirmationHeight:UInt32 {
                    get {
                        return builderResult.confirmationHeight
                    }
                    set (value) {
                        builderResult.hasConfirmationHeight = true
                        builderResult.confirmationHeight = value
                    }
                }
                public var hasConfirmationHeight:Bool {
                    get {
                        return builderResult.hasConfirmationHeight
                    }
                }
                @discardableResult
                public func setConfirmationHeight(_ value:UInt32) -> Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder {
                    self.confirmationHeight = value
                    return self
                }
                @discardableResult
                public func clearConfirmationHeight() -> Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder{
                    builderResult.hasConfirmationHeight = false
                    builderResult.confirmationHeight = nil
                    return self
                }
                ///*
                ///The amount calculated to be paid in fees for the current set of
                ///commitment transactions. The fee amount is persisted with the channel
                ///in order to allow the fee amount to be removed and recalculated with
                ///each channel state update, including updates that happen after a system
                ///restart.
                public var commitFee:Int64 {
                    get {
                        return builderResult.commitFee
                    }
                    set (value) {
                        builderResult.hasCommitFee = true
                        builderResult.commitFee = value
                    }
                }
                public var hasCommitFee:Bool {
                    get {
                        return builderResult.hasCommitFee
                    }
                }
                @discardableResult
                public func setCommitFee(_ value:Int64) -> Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder {
                    self.commitFee = value
                    return self
                }
                @discardableResult
                public func clearCommitFee() -> Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder{
                    builderResult.hasCommitFee = false
                    builderResult.commitFee = nil
                    return self
                }
                //// The weight of the commitment transaction
                public var commitWeight:Int64 {
                    get {
                        return builderResult.commitWeight
                    }
                    set (value) {
                        builderResult.hasCommitWeight = true
                        builderResult.commitWeight = value
                    }
                }
                public var hasCommitWeight:Bool {
                    get {
                        return builderResult.hasCommitWeight
                    }
                }
                @discardableResult
                public func setCommitWeight(_ value:Int64) -> Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder {
                    self.commitWeight = value
                    return self
                }
                @discardableResult
                public func clearCommitWeight() -> Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder{
                    builderResult.hasCommitWeight = false
                    builderResult.commitWeight = nil
                    return self
                }
                ///*
                ///The required number of satoshis per kilo-weight that the requester will
                ///pay at all times, for both the funding transaction and commitment
                ///transaction. This value can later be updated once the channel is open.
                public var feePerKw:Int64 {
                    get {
                        return builderResult.feePerKw
                    }
                    set (value) {
                        builderResult.hasFeePerKw = true
                        builderResult.feePerKw = value
                    }
                }
                public var hasFeePerKw:Bool {
                    get {
                        return builderResult.hasFeePerKw
                    }
                }
                @discardableResult
                public func setFeePerKw(_ value:Int64) -> Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder {
                    self.feePerKw = value
                    return self
                }
                @discardableResult
                public func clearFeePerKw() -> Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder{
                    builderResult.hasFeePerKw = false
                    builderResult.feePerKw = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder {
                    builderResult = Lnrpc.PendingChannelsResponse.PendingOpenChannel()
                    return self
                }
                override public func clone() throws -> Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder {
                    return try Lnrpc.PendingChannelsResponse.PendingOpenChannel.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Lnrpc.PendingChannelsResponse.PendingOpenChannel {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Lnrpc.PendingChannelsResponse.PendingOpenChannel {
                    let returnMe:Lnrpc.PendingChannelsResponse.PendingOpenChannel = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Lnrpc.PendingChannelsResponse.PendingOpenChannel) throws -> Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder {
                    if other == Lnrpc.PendingChannelsResponse.PendingOpenChannel() {
                        return self
                    }
                    if (other.hasChannel) {
                        try mergeChannel(value: other.channel)
                    }
                    if other.hasConfirmationHeight {
                        confirmationHeight = other.confirmationHeight
                    }
                    if other.hasCommitFee {
                        commitFee = other.commitFee
                    }
                    if other.hasCommitWeight {
                        commitWeight = other.commitWeight
                    }
                    if other.hasFeePerKw {
                        feePerKw = other.feePerKw
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            let subBuilder:Lnrpc.PendingChannelsResponse.PendingChannel.Builder = Lnrpc.PendingChannelsResponse.PendingChannel.Builder()
                            if hasChannel {
                                try subBuilder.mergeFrom(other: channel)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            channel = subBuilder.buildPartial()

                        case 16:
                            confirmationHeight = try codedInputStream.readUInt32()

                        case 32:
                            commitFee = try codedInputStream.readInt64()

                        case 40:
                            commitWeight = try codedInputStream.readInt64()

                        case 48:
                            feePerKw = try codedInputStream.readInt64()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder {
                    let resultDecodedBuilder = Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder()
                    if let jsonValueChannel = jsonMap["channel"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.channel = try Lnrpc.PendingChannelsResponse.PendingChannel.Builder.decodeToBuilder(jsonMap:jsonValueChannel).build()

                    }
                    if let jsonValueConfirmationHeight = jsonMap["confirmation_height"] as? UInt {
                        resultDecodedBuilder.confirmationHeight = UInt32(jsonValueConfirmationHeight)
                    } else if let jsonValueConfirmationHeight = jsonMap["confirmation_height"] as? String {
                        resultDecodedBuilder.confirmationHeight = UInt32(jsonValueConfirmationHeight)!
                    }
                    if let jsonValueCommitFee = jsonMap["commit_fee"] as? String {
                        resultDecodedBuilder.commitFee = Int64(jsonValueCommitFee)!
                    } else if let jsonValueCommitFee = jsonMap["commit_fee"] as? Int {
                        resultDecodedBuilder.commitFee = Int64(jsonValueCommitFee)
                    }
                    if let jsonValueCommitWeight = jsonMap["commit_weight"] as? String {
                        resultDecodedBuilder.commitWeight = Int64(jsonValueCommitWeight)!
                    } else if let jsonValueCommitWeight = jsonMap["commit_weight"] as? Int {
                        resultDecodedBuilder.commitWeight = Int64(jsonValueCommitWeight)
                    }
                    if let jsonValueFeePerKw = jsonMap["fee_per_kw"] as? String {
                        resultDecodedBuilder.feePerKw = Int64(jsonValueFeePerKw)!
                    } else if let jsonValueFeePerKw = jsonMap["fee_per_kw"] as? Int {
                        resultDecodedBuilder.feePerKw = Int64(jsonValueFeePerKw)
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class WaitingCloseChannel : GeneratedMessage {
            public typealias BuilderType = Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder

            public static func == (lhs: Lnrpc.PendingChannelsResponse.WaitingCloseChannel, rhs: Lnrpc.PendingChannelsResponse.WaitingCloseChannel) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasChannel == rhs.hasChannel) && (!lhs.hasChannel || lhs.channel == rhs.channel)
                fieldCheck = fieldCheck && (lhs.hasLimboBalance == rhs.hasLimboBalance) && (!lhs.hasLimboBalance || lhs.limboBalance == rhs.limboBalance)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var channel:Lnrpc.PendingChannelsResponse.PendingChannel!
            public fileprivate(set) var hasChannel:Bool = false
            //// The balance in satoshis encumbered in this channel
            public fileprivate(set) var limboBalance:Int64! = nil
            public fileprivate(set) var hasLimboBalance:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() throws {
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasChannel {
                    try codedOutputStream.writeMessage(fieldNumber: 1, value:channel)
                }
                if hasLimboBalance {
                    try codedOutputStream.writeInt64(fieldNumber: 2, value:limboBalance)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasChannel {
                    if let varSizechannel = channel?.computeMessageSize(fieldNumber: 1) {
                        serialize_size += varSizechannel
                    }
                }
                if hasLimboBalance {
                    serialize_size += limboBalance.computeInt64Size(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder {
                return Lnrpc.PendingChannelsResponse.WaitingCloseChannel.classBuilder() as! Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder
            }
            public func getBuilder() -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder {
                return classBuilder() as! Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder()
            }
            public func toBuilder() throws -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder {
                return try Lnrpc.PendingChannelsResponse.WaitingCloseChannel.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Lnrpc.PendingChannelsResponse.WaitingCloseChannel) throws -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder {
                return try Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                try isInitialized()
                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasChannel {
                    jsonMap["channel"] = try channel.encode()
                }
                if hasLimboBalance {
                    jsonMap["limbo_balance"] = "\(limboBalance!)"
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel {
                return try Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel {
                return try Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder.fromJSONToBuilder(data:data, options:options).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasChannel {
                    output += "\(indent) channel {\n"
                    if let outDescChannel = channel {
                        output += try outDescChannel.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                if hasLimboBalance {
                    output += "\(indent) limboBalance: \(limboBalance) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasChannel {
                        if let hashValuechannel = channel?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuechannel
                        }
                    }
                    if hasLimboBalance {
                        hashCode = (hashCode &* 31) &+ limboBalance.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Lnrpc.PendingChannelsResponse.WaitingCloseChannel"
            }
            override public func className() -> String {
                return "Lnrpc.PendingChannelsResponse.WaitingCloseChannel"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Lnrpc.PendingChannelsResponse.WaitingCloseChannel = Lnrpc.PendingChannelsResponse.WaitingCloseChannel()
                public func getMessage() -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                //// The pending channel waiting for closing tx to confirm
                public var channel:Lnrpc.PendingChannelsResponse.PendingChannel! {
                    get {
                        if channelBuilder_ != nil {
                            builderResult.channel = channelBuilder_.getMessage()
                        }
                        return builderResult.channel
                    }
                    set (value) {
                        builderResult.hasChannel = value != nil
                        builderResult.channel = value
                    }
                }
                public var hasChannel:Bool {
                    get {
                        return builderResult.hasChannel
                    }
                }
                fileprivate var channelBuilder_:Lnrpc.PendingChannelsResponse.PendingChannel.Builder! {
                    didSet {
                        builderResult.hasChannel = true
                    }
                }
                public func getChannelBuilder() -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder {
                    if channelBuilder_ == nil {
                        channelBuilder_ = Lnrpc.PendingChannelsResponse.PendingChannel.Builder()
                        builderResult.channel = channelBuilder_.getMessage()
                        if channel != nil {
                            try! channelBuilder_.mergeFrom(other: channel)
                        }
                    }
                    return channelBuilder_
                }
                @discardableResult
                public func setChannel(_ value:Lnrpc.PendingChannelsResponse.PendingChannel!) -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder {
                    self.channel = value
                    return self
                }
                @discardableResult
                public func mergeChannel(value:Lnrpc.PendingChannelsResponse.PendingChannel) throws -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder {
                    if builderResult.hasChannel {
                        builderResult.channel = try Lnrpc.PendingChannelsResponse.PendingChannel.builderWithPrototype(prototype:builderResult.channel).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.channel = value
                    }
                    builderResult.hasChannel = true
                    return self
                }
                @discardableResult
                public func clearChannel() -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder {
                    channelBuilder_ = nil
                    builderResult.hasChannel = false
                    builderResult.channel = nil
                    return self
                }
                //// The balance in satoshis encumbered in this channel
                public var limboBalance:Int64 {
                    get {
                        return builderResult.limboBalance
                    }
                    set (value) {
                        builderResult.hasLimboBalance = true
                        builderResult.limboBalance = value
                    }
                }
                public var hasLimboBalance:Bool {
                    get {
                        return builderResult.hasLimboBalance
                    }
                }
                @discardableResult
                public func setLimboBalance(_ value:Int64) -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder {
                    self.limboBalance = value
                    return self
                }
                @discardableResult
                public func clearLimboBalance() -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder{
                    builderResult.hasLimboBalance = false
                    builderResult.limboBalance = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder {
                    builderResult = Lnrpc.PendingChannelsResponse.WaitingCloseChannel()
                    return self
                }
                override public func clone() throws -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder {
                    return try Lnrpc.PendingChannelsResponse.WaitingCloseChannel.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel {
                    let returnMe:Lnrpc.PendingChannelsResponse.WaitingCloseChannel = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Lnrpc.PendingChannelsResponse.WaitingCloseChannel) throws -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder {
                    if other == Lnrpc.PendingChannelsResponse.WaitingCloseChannel() {
                        return self
                    }
                    if (other.hasChannel) {
                        try mergeChannel(value: other.channel)
                    }
                    if other.hasLimboBalance {
                        limboBalance = other.limboBalance
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            let subBuilder:Lnrpc.PendingChannelsResponse.PendingChannel.Builder = Lnrpc.PendingChannelsResponse.PendingChannel.Builder()
                            if hasChannel {
                                try subBuilder.mergeFrom(other: channel)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            channel = subBuilder.buildPartial()

                        case 16:
                            limboBalance = try codedInputStream.readInt64()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder {
                    let resultDecodedBuilder = Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder()
                    if let jsonValueChannel = jsonMap["channel"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.channel = try Lnrpc.PendingChannelsResponse.PendingChannel.Builder.decodeToBuilder(jsonMap:jsonValueChannel).build()

                    }
                    if let jsonValueLimboBalance = jsonMap["limbo_balance"] as? String {
                        resultDecodedBuilder.limboBalance = Int64(jsonValueLimboBalance)!
                    } else if let jsonValueLimboBalance = jsonMap["limbo_balance"] as? Int {
                        resultDecodedBuilder.limboBalance = Int64(jsonValueLimboBalance)
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class ClosedChannel : GeneratedMessage {
            public typealias BuilderType = Lnrpc.PendingChannelsResponse.ClosedChannel.Builder

            public static func == (lhs: Lnrpc.PendingChannelsResponse.ClosedChannel, rhs: Lnrpc.PendingChannelsResponse.ClosedChannel) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasChannel == rhs.hasChannel) && (!lhs.hasChannel || lhs.channel == rhs.channel)
                fieldCheck = fieldCheck && (lhs.hasClosingTxid == rhs.hasClosingTxid) && (!lhs.hasClosingTxid || lhs.closingTxid == rhs.closingTxid)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var channel:Lnrpc.PendingChannelsResponse.PendingChannel!
            public fileprivate(set) var hasChannel:Bool = false
            //// The transaction id of the closing transaction
            public fileprivate(set) var closingTxid:String! = nil
            public fileprivate(set) var hasClosingTxid:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() throws {
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasChannel {
                    try codedOutputStream.writeMessage(fieldNumber: 1, value:channel)
                }
                if hasClosingTxid {
                    try codedOutputStream.writeString(fieldNumber: 2, value:closingTxid)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasChannel {
                    if let varSizechannel = channel?.computeMessageSize(fieldNumber: 1) {
                        serialize_size += varSizechannel
                    }
                }
                if hasClosingTxid {
                    serialize_size += closingTxid.computeStringSize(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Lnrpc.PendingChannelsResponse.ClosedChannel.Builder {
                return Lnrpc.PendingChannelsResponse.ClosedChannel.classBuilder() as! Lnrpc.PendingChannelsResponse.ClosedChannel.Builder
            }
            public func getBuilder() -> Lnrpc.PendingChannelsResponse.ClosedChannel.Builder {
                return classBuilder() as! Lnrpc.PendingChannelsResponse.ClosedChannel.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Lnrpc.PendingChannelsResponse.ClosedChannel.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Lnrpc.PendingChannelsResponse.ClosedChannel.Builder()
            }
            public func toBuilder() throws -> Lnrpc.PendingChannelsResponse.ClosedChannel.Builder {
                return try Lnrpc.PendingChannelsResponse.ClosedChannel.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Lnrpc.PendingChannelsResponse.ClosedChannel) throws -> Lnrpc.PendingChannelsResponse.ClosedChannel.Builder {
                return try Lnrpc.PendingChannelsResponse.ClosedChannel.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                try isInitialized()
                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasChannel {
                    jsonMap["channel"] = try channel.encode()
                }
                if hasClosingTxid {
                    jsonMap["closing_txid"] = closingTxid
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PendingChannelsResponse.ClosedChannel {
                return try Lnrpc.PendingChannelsResponse.ClosedChannel.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PendingChannelsResponse.ClosedChannel {
                return try Lnrpc.PendingChannelsResponse.ClosedChannel.Builder.fromJSONToBuilder(data:data, options:options).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasChannel {
                    output += "\(indent) channel {\n"
                    if let outDescChannel = channel {
                        output += try outDescChannel.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                if hasClosingTxid {
                    output += "\(indent) closingTxid: \(closingTxid) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasChannel {
                        if let hashValuechannel = channel?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuechannel
                        }
                    }
                    if hasClosingTxid {
                        hashCode = (hashCode &* 31) &+ closingTxid.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Lnrpc.PendingChannelsResponse.ClosedChannel"
            }
            override public func className() -> String {
                return "Lnrpc.PendingChannelsResponse.ClosedChannel"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Lnrpc.PendingChannelsResponse.ClosedChannel = Lnrpc.PendingChannelsResponse.ClosedChannel()
                public func getMessage() -> Lnrpc.PendingChannelsResponse.ClosedChannel {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                //// The pending channel to be closed
                public var channel:Lnrpc.PendingChannelsResponse.PendingChannel! {
                    get {
                        if channelBuilder_ != nil {
                            builderResult.channel = channelBuilder_.getMessage()
                        }
                        return builderResult.channel
                    }
                    set (value) {
                        builderResult.hasChannel = value != nil
                        builderResult.channel = value
                    }
                }
                public var hasChannel:Bool {
                    get {
                        return builderResult.hasChannel
                    }
                }
                fileprivate var channelBuilder_:Lnrpc.PendingChannelsResponse.PendingChannel.Builder! {
                    didSet {
                        builderResult.hasChannel = true
                    }
                }
                public func getChannelBuilder() -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder {
                    if channelBuilder_ == nil {
                        channelBuilder_ = Lnrpc.PendingChannelsResponse.PendingChannel.Builder()
                        builderResult.channel = channelBuilder_.getMessage()
                        if channel != nil {
                            try! channelBuilder_.mergeFrom(other: channel)
                        }
                    }
                    return channelBuilder_
                }
                @discardableResult
                public func setChannel(_ value:Lnrpc.PendingChannelsResponse.PendingChannel!) -> Lnrpc.PendingChannelsResponse.ClosedChannel.Builder {
                    self.channel = value
                    return self
                }
                @discardableResult
                public func mergeChannel(value:Lnrpc.PendingChannelsResponse.PendingChannel) throws -> Lnrpc.PendingChannelsResponse.ClosedChannel.Builder {
                    if builderResult.hasChannel {
                        builderResult.channel = try Lnrpc.PendingChannelsResponse.PendingChannel.builderWithPrototype(prototype:builderResult.channel).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.channel = value
                    }
                    builderResult.hasChannel = true
                    return self
                }
                @discardableResult
                public func clearChannel() -> Lnrpc.PendingChannelsResponse.ClosedChannel.Builder {
                    channelBuilder_ = nil
                    builderResult.hasChannel = false
                    builderResult.channel = nil
                    return self
                }
                //// The transaction id of the closing transaction
                public var closingTxid:String {
                    get {
                        return builderResult.closingTxid
                    }
                    set (value) {
                        builderResult.hasClosingTxid = true
                        builderResult.closingTxid = value
                    }
                }
                public var hasClosingTxid:Bool {
                    get {
                        return builderResult.hasClosingTxid
                    }
                }
                @discardableResult
                public func setClosingTxid(_ value:String) -> Lnrpc.PendingChannelsResponse.ClosedChannel.Builder {
                    self.closingTxid = value
                    return self
                }
                @discardableResult
                public func clearClosingTxid() -> Lnrpc.PendingChannelsResponse.ClosedChannel.Builder{
                    builderResult.hasClosingTxid = false
                    builderResult.closingTxid = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Lnrpc.PendingChannelsResponse.ClosedChannel.Builder {
                    builderResult = Lnrpc.PendingChannelsResponse.ClosedChannel()
                    return self
                }
                override public func clone() throws -> Lnrpc.PendingChannelsResponse.ClosedChannel.Builder {
                    return try Lnrpc.PendingChannelsResponse.ClosedChannel.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Lnrpc.PendingChannelsResponse.ClosedChannel {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Lnrpc.PendingChannelsResponse.ClosedChannel {
                    let returnMe:Lnrpc.PendingChannelsResponse.ClosedChannel = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Lnrpc.PendingChannelsResponse.ClosedChannel) throws -> Lnrpc.PendingChannelsResponse.ClosedChannel.Builder {
                    if other == Lnrpc.PendingChannelsResponse.ClosedChannel() {
                        return self
                    }
                    if (other.hasChannel) {
                        try mergeChannel(value: other.channel)
                    }
                    if other.hasClosingTxid {
                        closingTxid = other.closingTxid
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PendingChannelsResponse.ClosedChannel.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsResponse.ClosedChannel.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            let subBuilder:Lnrpc.PendingChannelsResponse.PendingChannel.Builder = Lnrpc.PendingChannelsResponse.PendingChannel.Builder()
                            if hasChannel {
                                try subBuilder.mergeFrom(other: channel)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            channel = subBuilder.buildPartial()

                        case 18:
                            closingTxid = try codedInputStream.readString()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PendingChannelsResponse.ClosedChannel.Builder {
                    let resultDecodedBuilder = Lnrpc.PendingChannelsResponse.ClosedChannel.Builder()
                    if let jsonValueChannel = jsonMap["channel"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.channel = try Lnrpc.PendingChannelsResponse.PendingChannel.Builder.decodeToBuilder(jsonMap:jsonValueChannel).build()

                    }
                    if let jsonValueClosingTxid = jsonMap["closing_txid"] as? String {
                        resultDecodedBuilder.closingTxid = jsonValueClosingTxid
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PendingChannelsResponse.ClosedChannel.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Lnrpc.PendingChannelsResponse.ClosedChannel.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        final public class ForceClosedChannel : GeneratedMessage {
            public typealias BuilderType = Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder

            public static func == (lhs: Lnrpc.PendingChannelsResponse.ForceClosedChannel, rhs: Lnrpc.PendingChannelsResponse.ForceClosedChannel) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasChannel == rhs.hasChannel) && (!lhs.hasChannel || lhs.channel == rhs.channel)
                fieldCheck = fieldCheck && (lhs.hasClosingTxid == rhs.hasClosingTxid) && (!lhs.hasClosingTxid || lhs.closingTxid == rhs.closingTxid)
                fieldCheck = fieldCheck && (lhs.hasLimboBalance == rhs.hasLimboBalance) && (!lhs.hasLimboBalance || lhs.limboBalance == rhs.limboBalance)
                fieldCheck = fieldCheck && (lhs.hasMaturityHeight == rhs.hasMaturityHeight) && (!lhs.hasMaturityHeight || lhs.maturityHeight == rhs.maturityHeight)
                fieldCheck = fieldCheck && (lhs.hasBlocksTilMaturity == rhs.hasBlocksTilMaturity) && (!lhs.hasBlocksTilMaturity || lhs.blocksTilMaturity == rhs.blocksTilMaturity)
                fieldCheck = fieldCheck && (lhs.hasRecoveredBalance == rhs.hasRecoveredBalance) && (!lhs.hasRecoveredBalance || lhs.recoveredBalance == rhs.recoveredBalance)
                fieldCheck = fieldCheck && (lhs.pendingHtlcs == rhs.pendingHtlcs)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var channel:Lnrpc.PendingChannelsResponse.PendingChannel!
            public fileprivate(set) var hasChannel:Bool = false
            //// The transaction id of the closing transaction
            public fileprivate(set) var closingTxid:String! = nil
            public fileprivate(set) var hasClosingTxid:Bool = false

            //// The balance in satoshis encumbered in this pending channel
            public fileprivate(set) var limboBalance:Int64! = nil
            public fileprivate(set) var hasLimboBalance:Bool = false

            //// The height at which funds can be sweeped into the wallet
            public fileprivate(set) var maturityHeight:UInt32! = nil
            public fileprivate(set) var hasMaturityHeight:Bool = false

            ///Remaining # of blocks until the commitment output can be swept.
            ///Negative values indicate how many blocks have passed since becoming
            ///mature.
            public fileprivate(set) var blocksTilMaturity:Int32! = nil
            public fileprivate(set) var hasBlocksTilMaturity:Bool = false

            //// The total value of funds successfully recovered from this channel
            public fileprivate(set) var recoveredBalance:Int64! = nil
            public fileprivate(set) var hasRecoveredBalance:Bool = false

            public fileprivate(set) var pendingHtlcs:Array<Lnrpc.PendingHtlc>  = Array<Lnrpc.PendingHtlc>()
            required public init() {
                super.init()
            }
            override public func isInitialized() throws {
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasChannel {
                    try codedOutputStream.writeMessage(fieldNumber: 1, value:channel)
                }
                if hasClosingTxid {
                    try codedOutputStream.writeString(fieldNumber: 2, value:closingTxid)
                }
                if hasLimboBalance {
                    try codedOutputStream.writeInt64(fieldNumber: 3, value:limboBalance)
                }
                if hasMaturityHeight {
                    try codedOutputStream.writeUInt32(fieldNumber: 4, value:maturityHeight)
                }
                if hasBlocksTilMaturity {
                    try codedOutputStream.writeInt32(fieldNumber: 5, value:blocksTilMaturity)
                }
                if hasRecoveredBalance {
                    try codedOutputStream.writeInt64(fieldNumber: 6, value:recoveredBalance)
                }
                for oneElementPendingHtlcs in pendingHtlcs {
                      try codedOutputStream.writeMessage(fieldNumber: 8, value:oneElementPendingHtlcs)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasChannel {
                    if let varSizechannel = channel?.computeMessageSize(fieldNumber: 1) {
                        serialize_size += varSizechannel
                    }
                }
                if hasClosingTxid {
                    serialize_size += closingTxid.computeStringSize(fieldNumber: 2)
                }
                if hasLimboBalance {
                    serialize_size += limboBalance.computeInt64Size(fieldNumber: 3)
                }
                if hasMaturityHeight {
                    serialize_size += maturityHeight.computeUInt32Size(fieldNumber: 4)
                }
                if hasBlocksTilMaturity {
                    serialize_size += blocksTilMaturity.computeInt32Size(fieldNumber: 5)
                }
                if hasRecoveredBalance {
                    serialize_size += recoveredBalance.computeInt64Size(fieldNumber: 6)
                }
                for oneElementPendingHtlcs in pendingHtlcs {
                    serialize_size += oneElementPendingHtlcs.computeMessageSize(fieldNumber: 8)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder {
                return Lnrpc.PendingChannelsResponse.ForceClosedChannel.classBuilder() as! Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder
            }
            public func getBuilder() -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder {
                return classBuilder() as! Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder()
            }
            public func toBuilder() throws -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder {
                return try Lnrpc.PendingChannelsResponse.ForceClosedChannel.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Lnrpc.PendingChannelsResponse.ForceClosedChannel) throws -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder {
                return try Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                try isInitialized()
                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasChannel {
                    jsonMap["channel"] = try channel.encode()
                }
                if hasClosingTxid {
                    jsonMap["closing_txid"] = closingTxid
                }
                if hasLimboBalance {
                    jsonMap["limbo_balance"] = "\(limboBalance!)"
                }
                if hasMaturityHeight {
                    jsonMap["maturity_height"] = UInt(maturityHeight)
                }
                if hasBlocksTilMaturity {
                    jsonMap["blocks_til_maturity"] = Int(blocksTilMaturity)
                }
                if hasRecoveredBalance {
                    jsonMap["recovered_balance"] = "\(recoveredBalance!)"
                }
                if !pendingHtlcs.isEmpty {
                    var jsonArrayPendingHtlcs:Array<Dictionary<String,Any>> = []
                    for oneValuePendingHtlcs in pendingHtlcs {
                        let ecodedMessagePendingHtlcs = try oneValuePendingHtlcs.encode()
                        jsonArrayPendingHtlcs.append(ecodedMessagePendingHtlcs)
                    }
                    jsonMap["pending_htlcs"] = jsonArrayPendingHtlcs
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PendingChannelsResponse.ForceClosedChannel {
                return try Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PendingChannelsResponse.ForceClosedChannel {
                return try Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder.fromJSONToBuilder(data:data, options:options).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasChannel {
                    output += "\(indent) channel {\n"
                    if let outDescChannel = channel {
                        output += try outDescChannel.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                if hasClosingTxid {
                    output += "\(indent) closingTxid: \(closingTxid) \n"
                }
                if hasLimboBalance {
                    output += "\(indent) limboBalance: \(limboBalance) \n"
                }
                if hasMaturityHeight {
                    output += "\(indent) maturityHeight: \(maturityHeight) \n"
                }
                if hasBlocksTilMaturity {
                    output += "\(indent) blocksTilMaturity: \(blocksTilMaturity) \n"
                }
                if hasRecoveredBalance {
                    output += "\(indent) recoveredBalance: \(recoveredBalance) \n"
                }
                var pendingHtlcsElementIndex:Int = 0
                for oneElementPendingHtlcs in pendingHtlcs {
                    output += "\(indent) pendingHtlcs[\(pendingHtlcsElementIndex)] {\n"
                    output += try oneElementPendingHtlcs.getDescription(indent: "\(indent)  ")
                    output += "\(indent)}\n"
                    pendingHtlcsElementIndex += 1
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasChannel {
                        if let hashValuechannel = channel?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuechannel
                        }
                    }
                    if hasClosingTxid {
                        hashCode = (hashCode &* 31) &+ closingTxid.hashValue
                    }
                    if hasLimboBalance {
                        hashCode = (hashCode &* 31) &+ limboBalance.hashValue
                    }
                    if hasMaturityHeight {
                        hashCode = (hashCode &* 31) &+ maturityHeight.hashValue
                    }
                    if hasBlocksTilMaturity {
                        hashCode = (hashCode &* 31) &+ blocksTilMaturity.hashValue
                    }
                    if hasRecoveredBalance {
                        hashCode = (hashCode &* 31) &+ recoveredBalance.hashValue
                    }
                    for oneElementPendingHtlcs in pendingHtlcs {
                        hashCode = (hashCode &* 31) &+ oneElementPendingHtlcs.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Lnrpc.PendingChannelsResponse.ForceClosedChannel"
            }
            override public func className() -> String {
                return "Lnrpc.PendingChannelsResponse.ForceClosedChannel"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Lnrpc.PendingChannelsResponse.ForceClosedChannel = Lnrpc.PendingChannelsResponse.ForceClosedChannel()
                public func getMessage() -> Lnrpc.PendingChannelsResponse.ForceClosedChannel {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                //// The pending channel to be force closed
                public var channel:Lnrpc.PendingChannelsResponse.PendingChannel! {
                    get {
                        if channelBuilder_ != nil {
                            builderResult.channel = channelBuilder_.getMessage()
                        }
                        return builderResult.channel
                    }
                    set (value) {
                        builderResult.hasChannel = value != nil
                        builderResult.channel = value
                    }
                }
                public var hasChannel:Bool {
                    get {
                        return builderResult.hasChannel
                    }
                }
                fileprivate var channelBuilder_:Lnrpc.PendingChannelsResponse.PendingChannel.Builder! {
                    didSet {
                        builderResult.hasChannel = true
                    }
                }
                public func getChannelBuilder() -> Lnrpc.PendingChannelsResponse.PendingChannel.Builder {
                    if channelBuilder_ == nil {
                        channelBuilder_ = Lnrpc.PendingChannelsResponse.PendingChannel.Builder()
                        builderResult.channel = channelBuilder_.getMessage()
                        if channel != nil {
                            try! channelBuilder_.mergeFrom(other: channel)
                        }
                    }
                    return channelBuilder_
                }
                @discardableResult
                public func setChannel(_ value:Lnrpc.PendingChannelsResponse.PendingChannel!) -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder {
                    self.channel = value
                    return self
                }
                @discardableResult
                public func mergeChannel(value:Lnrpc.PendingChannelsResponse.PendingChannel) throws -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder {
                    if builderResult.hasChannel {
                        builderResult.channel = try Lnrpc.PendingChannelsResponse.PendingChannel.builderWithPrototype(prototype:builderResult.channel).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.channel = value
                    }
                    builderResult.hasChannel = true
                    return self
                }
                @discardableResult
                public func clearChannel() -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder {
                    channelBuilder_ = nil
                    builderResult.hasChannel = false
                    builderResult.channel = nil
                    return self
                }
                //// The transaction id of the closing transaction
                public var closingTxid:String {
                    get {
                        return builderResult.closingTxid
                    }
                    set (value) {
                        builderResult.hasClosingTxid = true
                        builderResult.closingTxid = value
                    }
                }
                public var hasClosingTxid:Bool {
                    get {
                        return builderResult.hasClosingTxid
                    }
                }
                @discardableResult
                public func setClosingTxid(_ value:String) -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder {
                    self.closingTxid = value
                    return self
                }
                @discardableResult
                public func clearClosingTxid() -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder{
                    builderResult.hasClosingTxid = false
                    builderResult.closingTxid = nil
                    return self
                }
                //// The balance in satoshis encumbered in this pending channel
                public var limboBalance:Int64 {
                    get {
                        return builderResult.limboBalance
                    }
                    set (value) {
                        builderResult.hasLimboBalance = true
                        builderResult.limboBalance = value
                    }
                }
                public var hasLimboBalance:Bool {
                    get {
                        return builderResult.hasLimboBalance
                    }
                }
                @discardableResult
                public func setLimboBalance(_ value:Int64) -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder {
                    self.limboBalance = value
                    return self
                }
                @discardableResult
                public func clearLimboBalance() -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder{
                    builderResult.hasLimboBalance = false
                    builderResult.limboBalance = nil
                    return self
                }
                //// The height at which funds can be sweeped into the wallet
                public var maturityHeight:UInt32 {
                    get {
                        return builderResult.maturityHeight
                    }
                    set (value) {
                        builderResult.hasMaturityHeight = true
                        builderResult.maturityHeight = value
                    }
                }
                public var hasMaturityHeight:Bool {
                    get {
                        return builderResult.hasMaturityHeight
                    }
                }
                @discardableResult
                public func setMaturityHeight(_ value:UInt32) -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder {
                    self.maturityHeight = value
                    return self
                }
                @discardableResult
                public func clearMaturityHeight() -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder{
                    builderResult.hasMaturityHeight = false
                    builderResult.maturityHeight = nil
                    return self
                }
                ///Remaining # of blocks until the commitment output can be swept.
                ///Negative values indicate how many blocks have passed since becoming
                ///mature.
                public var blocksTilMaturity:Int32 {
                    get {
                        return builderResult.blocksTilMaturity
                    }
                    set (value) {
                        builderResult.hasBlocksTilMaturity = true
                        builderResult.blocksTilMaturity = value
                    }
                }
                public var hasBlocksTilMaturity:Bool {
                    get {
                        return builderResult.hasBlocksTilMaturity
                    }
                }
                @discardableResult
                public func setBlocksTilMaturity(_ value:Int32) -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder {
                    self.blocksTilMaturity = value
                    return self
                }
                @discardableResult
                public func clearBlocksTilMaturity() -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder{
                    builderResult.hasBlocksTilMaturity = false
                    builderResult.blocksTilMaturity = nil
                    return self
                }
                //// The total value of funds successfully recovered from this channel
                public var recoveredBalance:Int64 {
                    get {
                        return builderResult.recoveredBalance
                    }
                    set (value) {
                        builderResult.hasRecoveredBalance = true
                        builderResult.recoveredBalance = value
                    }
                }
                public var hasRecoveredBalance:Bool {
                    get {
                        return builderResult.hasRecoveredBalance
                    }
                }
                @discardableResult
                public func setRecoveredBalance(_ value:Int64) -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder {
                    self.recoveredBalance = value
                    return self
                }
                @discardableResult
                public func clearRecoveredBalance() -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder{
                    builderResult.hasRecoveredBalance = false
                    builderResult.recoveredBalance = nil
                    return self
                }
                public var pendingHtlcs:Array<Lnrpc.PendingHtlc> {
                    get {
                        return builderResult.pendingHtlcs
                    }
                    set (value) {
                        builderResult.pendingHtlcs = value
                    }
                }
                @discardableResult
                public func setPendingHtlcs(_ value:Array<Lnrpc.PendingHtlc>) -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder {
                    self.pendingHtlcs = value
                    return self
                }
                @discardableResult
                public func clearPendingHtlcs() -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder {
                    builderResult.pendingHtlcs.removeAll(keepingCapacity: false)
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder {
                    builderResult = Lnrpc.PendingChannelsResponse.ForceClosedChannel()
                    return self
                }
                override public func clone() throws -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder {
                    return try Lnrpc.PendingChannelsResponse.ForceClosedChannel.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Lnrpc.PendingChannelsResponse.ForceClosedChannel {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Lnrpc.PendingChannelsResponse.ForceClosedChannel {
                    let returnMe:Lnrpc.PendingChannelsResponse.ForceClosedChannel = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Lnrpc.PendingChannelsResponse.ForceClosedChannel) throws -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder {
                    if other == Lnrpc.PendingChannelsResponse.ForceClosedChannel() {
                        return self
                    }
                    if (other.hasChannel) {
                        try mergeChannel(value: other.channel)
                    }
                    if other.hasClosingTxid {
                        closingTxid = other.closingTxid
                    }
                    if other.hasLimboBalance {
                        limboBalance = other.limboBalance
                    }
                    if other.hasMaturityHeight {
                        maturityHeight = other.maturityHeight
                    }
                    if other.hasBlocksTilMaturity {
                        blocksTilMaturity = other.blocksTilMaturity
                    }
                    if other.hasRecoveredBalance {
                        recoveredBalance = other.recoveredBalance
                    }
                    if !other.pendingHtlcs.isEmpty  {
                         builderResult.pendingHtlcs += other.pendingHtlcs
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            let subBuilder:Lnrpc.PendingChannelsResponse.PendingChannel.Builder = Lnrpc.PendingChannelsResponse.PendingChannel.Builder()
                            if hasChannel {
                                try subBuilder.mergeFrom(other: channel)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            channel = subBuilder.buildPartial()

                        case 18:
                            closingTxid = try codedInputStream.readString()

                        case 24:
                            limboBalance = try codedInputStream.readInt64()

                        case 32:
                            maturityHeight = try codedInputStream.readUInt32()

                        case 40:
                            blocksTilMaturity = try codedInputStream.readInt32()

                        case 48:
                            recoveredBalance = try codedInputStream.readInt64()

                        case 66:
                            let subBuilder = Lnrpc.PendingHtlc.Builder()
                            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                            pendingHtlcs.append(subBuilder.buildPartial())

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder {
                    let resultDecodedBuilder = Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder()
                    if let jsonValueChannel = jsonMap["channel"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.channel = try Lnrpc.PendingChannelsResponse.PendingChannel.Builder.decodeToBuilder(jsonMap:jsonValueChannel).build()

                    }
                    if let jsonValueClosingTxid = jsonMap["closing_txid"] as? String {
                        resultDecodedBuilder.closingTxid = jsonValueClosingTxid
                    }
                    if let jsonValueLimboBalance = jsonMap["limbo_balance"] as? String {
                        resultDecodedBuilder.limboBalance = Int64(jsonValueLimboBalance)!
                    } else if let jsonValueLimboBalance = jsonMap["limbo_balance"] as? Int {
                        resultDecodedBuilder.limboBalance = Int64(jsonValueLimboBalance)
                    }
                    if let jsonValueMaturityHeight = jsonMap["maturity_height"] as? UInt {
                        resultDecodedBuilder.maturityHeight = UInt32(jsonValueMaturityHeight)
                    } else if let jsonValueMaturityHeight = jsonMap["maturity_height"] as? String {
                        resultDecodedBuilder.maturityHeight = UInt32(jsonValueMaturityHeight)!
                    }
                    if let jsonValueBlocksTilMaturity = jsonMap["blocks_til_maturity"] as? Int {
                        resultDecodedBuilder.blocksTilMaturity = Int32(jsonValueBlocksTilMaturity)
                    } else if let jsonValueBlocksTilMaturity = jsonMap["blocks_til_maturity"] as? String {
                        resultDecodedBuilder.blocksTilMaturity = Int32(jsonValueBlocksTilMaturity)!
                    }
                    if let jsonValueRecoveredBalance = jsonMap["recovered_balance"] as? String {
                        resultDecodedBuilder.recoveredBalance = Int64(jsonValueRecoveredBalance)!
                    } else if let jsonValueRecoveredBalance = jsonMap["recovered_balance"] as? Int {
                        resultDecodedBuilder.recoveredBalance = Int64(jsonValueRecoveredBalance)
                    }
                    if let jsonValuePendingHtlcs = jsonMap["pending_htlcs"] as? Array<Dictionary<String,Any>> {
                        var jsonArrayPendingHtlcs:Array<Lnrpc.PendingHtlc> = []
                        for oneValuePendingHtlcs in jsonValuePendingHtlcs {
                            let messageFromStringPendingHtlcs = try Lnrpc.PendingHtlc.Builder.decodeToBuilder(jsonMap:oneValuePendingHtlcs).build()

                            jsonArrayPendingHtlcs.append(messageFromStringPendingHtlcs)
                        }
                        resultDecodedBuilder.pendingHtlcs = jsonArrayPendingHtlcs
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        //// The balance in satoshis encumbered in pending channels
        public fileprivate(set) var totalLimboBalance:Int64! = nil
        public fileprivate(set) var hasTotalLimboBalance:Bool = false

        public fileprivate(set) var pendingOpenChannels:Array<Lnrpc.PendingChannelsResponse.PendingOpenChannel>  = Array<Lnrpc.PendingChannelsResponse.PendingOpenChannel>()
        public fileprivate(set) var pendingClosingChannels:Array<Lnrpc.PendingChannelsResponse.ClosedChannel>  = Array<Lnrpc.PendingChannelsResponse.ClosedChannel>()
        public fileprivate(set) var pendingForceClosingChannels:Array<Lnrpc.PendingChannelsResponse.ForceClosedChannel>  = Array<Lnrpc.PendingChannelsResponse.ForceClosedChannel>()
        public fileprivate(set) var waitingCloseChannels:Array<Lnrpc.PendingChannelsResponse.WaitingCloseChannel>  = Array<Lnrpc.PendingChannelsResponse.WaitingCloseChannel>()
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTotalLimboBalance {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:totalLimboBalance)
            }
            for oneElementPendingOpenChannels in pendingOpenChannels {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementPendingOpenChannels)
            }
            for oneElementPendingClosingChannels in pendingClosingChannels {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementPendingClosingChannels)
            }
            for oneElementPendingForceClosingChannels in pendingForceClosingChannels {
                  try codedOutputStream.writeMessage(fieldNumber: 4, value:oneElementPendingForceClosingChannels)
            }
            for oneElementWaitingCloseChannels in waitingCloseChannels {
                  try codedOutputStream.writeMessage(fieldNumber: 5, value:oneElementWaitingCloseChannels)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTotalLimboBalance {
                serialize_size += totalLimboBalance.computeInt64Size(fieldNumber: 1)
            }
            for oneElementPendingOpenChannels in pendingOpenChannels {
                serialize_size += oneElementPendingOpenChannels.computeMessageSize(fieldNumber: 2)
            }
            for oneElementPendingClosingChannels in pendingClosingChannels {
                serialize_size += oneElementPendingClosingChannels.computeMessageSize(fieldNumber: 3)
            }
            for oneElementPendingForceClosingChannels in pendingForceClosingChannels {
                serialize_size += oneElementPendingForceClosingChannels.computeMessageSize(fieldNumber: 4)
            }
            for oneElementWaitingCloseChannels in waitingCloseChannels {
                serialize_size += oneElementWaitingCloseChannels.computeMessageSize(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.PendingChannelsResponse.Builder {
            return Lnrpc.PendingChannelsResponse.classBuilder() as! Lnrpc.PendingChannelsResponse.Builder
        }
        public func getBuilder() -> Lnrpc.PendingChannelsResponse.Builder {
            return classBuilder() as! Lnrpc.PendingChannelsResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.PendingChannelsResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.PendingChannelsResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.PendingChannelsResponse.Builder {
            return try Lnrpc.PendingChannelsResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.PendingChannelsResponse) throws -> Lnrpc.PendingChannelsResponse.Builder {
            return try Lnrpc.PendingChannelsResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTotalLimboBalance {
                jsonMap["total_limbo_balance"] = "\(totalLimboBalance!)"
            }
            if !pendingOpenChannels.isEmpty {
                var jsonArrayPendingOpenChannels:Array<Dictionary<String,Any>> = []
                for oneValuePendingOpenChannels in pendingOpenChannels {
                    let ecodedMessagePendingOpenChannels = try oneValuePendingOpenChannels.encode()
                    jsonArrayPendingOpenChannels.append(ecodedMessagePendingOpenChannels)
                }
                jsonMap["pending_open_channels"] = jsonArrayPendingOpenChannels
            }
            if !pendingClosingChannels.isEmpty {
                var jsonArrayPendingClosingChannels:Array<Dictionary<String,Any>> = []
                for oneValuePendingClosingChannels in pendingClosingChannels {
                    let ecodedMessagePendingClosingChannels = try oneValuePendingClosingChannels.encode()
                    jsonArrayPendingClosingChannels.append(ecodedMessagePendingClosingChannels)
                }
                jsonMap["pending_closing_channels"] = jsonArrayPendingClosingChannels
            }
            if !pendingForceClosingChannels.isEmpty {
                var jsonArrayPendingForceClosingChannels:Array<Dictionary<String,Any>> = []
                for oneValuePendingForceClosingChannels in pendingForceClosingChannels {
                    let ecodedMessagePendingForceClosingChannels = try oneValuePendingForceClosingChannels.encode()
                    jsonArrayPendingForceClosingChannels.append(ecodedMessagePendingForceClosingChannels)
                }
                jsonMap["pending_force_closing_channels"] = jsonArrayPendingForceClosingChannels
            }
            if !waitingCloseChannels.isEmpty {
                var jsonArrayWaitingCloseChannels:Array<Dictionary<String,Any>> = []
                for oneValueWaitingCloseChannels in waitingCloseChannels {
                    let ecodedMessageWaitingCloseChannels = try oneValueWaitingCloseChannels.encode()
                    jsonArrayWaitingCloseChannels.append(ecodedMessageWaitingCloseChannels)
                }
                jsonMap["waiting_close_channels"] = jsonArrayWaitingCloseChannels
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PendingChannelsResponse {
            return try Lnrpc.PendingChannelsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PendingChannelsResponse {
            return try Lnrpc.PendingChannelsResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTotalLimboBalance {
                output += "\(indent) totalLimboBalance: \(totalLimboBalance) \n"
            }
            var pendingOpenChannelsElementIndex:Int = 0
            for oneElementPendingOpenChannels in pendingOpenChannels {
                output += "\(indent) pendingOpenChannels[\(pendingOpenChannelsElementIndex)] {\n"
                output += try oneElementPendingOpenChannels.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                pendingOpenChannelsElementIndex += 1
            }
            var pendingClosingChannelsElementIndex:Int = 0
            for oneElementPendingClosingChannels in pendingClosingChannels {
                output += "\(indent) pendingClosingChannels[\(pendingClosingChannelsElementIndex)] {\n"
                output += try oneElementPendingClosingChannels.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                pendingClosingChannelsElementIndex += 1
            }
            var pendingForceClosingChannelsElementIndex:Int = 0
            for oneElementPendingForceClosingChannels in pendingForceClosingChannels {
                output += "\(indent) pendingForceClosingChannels[\(pendingForceClosingChannelsElementIndex)] {\n"
                output += try oneElementPendingForceClosingChannels.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                pendingForceClosingChannelsElementIndex += 1
            }
            var waitingCloseChannelsElementIndex:Int = 0
            for oneElementWaitingCloseChannels in waitingCloseChannels {
                output += "\(indent) waitingCloseChannels[\(waitingCloseChannelsElementIndex)] {\n"
                output += try oneElementWaitingCloseChannels.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                waitingCloseChannelsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTotalLimboBalance {
                    hashCode = (hashCode &* 31) &+ totalLimboBalance.hashValue
                }
                for oneElementPendingOpenChannels in pendingOpenChannels {
                    hashCode = (hashCode &* 31) &+ oneElementPendingOpenChannels.hashValue
                }
                for oneElementPendingClosingChannels in pendingClosingChannels {
                    hashCode = (hashCode &* 31) &+ oneElementPendingClosingChannels.hashValue
                }
                for oneElementPendingForceClosingChannels in pendingForceClosingChannels {
                    hashCode = (hashCode &* 31) &+ oneElementPendingForceClosingChannels.hashValue
                }
                for oneElementWaitingCloseChannels in waitingCloseChannels {
                    hashCode = (hashCode &* 31) &+ oneElementWaitingCloseChannels.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.PendingChannelsResponse"
        }
        override public func className() -> String {
            return "Lnrpc.PendingChannelsResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.PendingChannelsResponse = Lnrpc.PendingChannelsResponse()
            public func getMessage() -> Lnrpc.PendingChannelsResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The balance in satoshis encumbered in pending channels
            public var totalLimboBalance:Int64 {
                get {
                    return builderResult.totalLimboBalance
                }
                set (value) {
                    builderResult.hasTotalLimboBalance = true
                    builderResult.totalLimboBalance = value
                }
            }
            public var hasTotalLimboBalance:Bool {
                get {
                    return builderResult.hasTotalLimboBalance
                }
            }
            @discardableResult
            public func setTotalLimboBalance(_ value:Int64) -> Lnrpc.PendingChannelsResponse.Builder {
                self.totalLimboBalance = value
                return self
            }
            @discardableResult
            public func clearTotalLimboBalance() -> Lnrpc.PendingChannelsResponse.Builder{
                builderResult.hasTotalLimboBalance = false
                builderResult.totalLimboBalance = nil
                return self
            }
            //// Channels pending opening
            public var pendingOpenChannels:Array<Lnrpc.PendingChannelsResponse.PendingOpenChannel> {
                get {
                    return builderResult.pendingOpenChannels
                }
                set (value) {
                    builderResult.pendingOpenChannels = value
                }
            }
            @discardableResult
            public func setPendingOpenChannels(_ value:Array<Lnrpc.PendingChannelsResponse.PendingOpenChannel>) -> Lnrpc.PendingChannelsResponse.Builder {
                self.pendingOpenChannels = value
                return self
            }
            @discardableResult
            public func clearPendingOpenChannels() -> Lnrpc.PendingChannelsResponse.Builder {
                builderResult.pendingOpenChannels.removeAll(keepingCapacity: false)
                return self
            }
            //// Channels pending closing
            public var pendingClosingChannels:Array<Lnrpc.PendingChannelsResponse.ClosedChannel> {
                get {
                    return builderResult.pendingClosingChannels
                }
                set (value) {
                    builderResult.pendingClosingChannels = value
                }
            }
            @discardableResult
            public func setPendingClosingChannels(_ value:Array<Lnrpc.PendingChannelsResponse.ClosedChannel>) -> Lnrpc.PendingChannelsResponse.Builder {
                self.pendingClosingChannels = value
                return self
            }
            @discardableResult
            public func clearPendingClosingChannels() -> Lnrpc.PendingChannelsResponse.Builder {
                builderResult.pendingClosingChannels.removeAll(keepingCapacity: false)
                return self
            }
            //// Channels pending force closing
            public var pendingForceClosingChannels:Array<Lnrpc.PendingChannelsResponse.ForceClosedChannel> {
                get {
                    return builderResult.pendingForceClosingChannels
                }
                set (value) {
                    builderResult.pendingForceClosingChannels = value
                }
            }
            @discardableResult
            public func setPendingForceClosingChannels(_ value:Array<Lnrpc.PendingChannelsResponse.ForceClosedChannel>) -> Lnrpc.PendingChannelsResponse.Builder {
                self.pendingForceClosingChannels = value
                return self
            }
            @discardableResult
            public func clearPendingForceClosingChannels() -> Lnrpc.PendingChannelsResponse.Builder {
                builderResult.pendingForceClosingChannels.removeAll(keepingCapacity: false)
                return self
            }
            //// Channels waiting for closing tx to confirm
            public var waitingCloseChannels:Array<Lnrpc.PendingChannelsResponse.WaitingCloseChannel> {
                get {
                    return builderResult.waitingCloseChannels
                }
                set (value) {
                    builderResult.waitingCloseChannels = value
                }
            }
            @discardableResult
            public func setWaitingCloseChannels(_ value:Array<Lnrpc.PendingChannelsResponse.WaitingCloseChannel>) -> Lnrpc.PendingChannelsResponse.Builder {
                self.waitingCloseChannels = value
                return self
            }
            @discardableResult
            public func clearWaitingCloseChannels() -> Lnrpc.PendingChannelsResponse.Builder {
                builderResult.waitingCloseChannels.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.PendingChannelsResponse.Builder {
                builderResult = Lnrpc.PendingChannelsResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.PendingChannelsResponse.Builder {
                return try Lnrpc.PendingChannelsResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.PendingChannelsResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.PendingChannelsResponse {
                let returnMe:Lnrpc.PendingChannelsResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.PendingChannelsResponse) throws -> Lnrpc.PendingChannelsResponse.Builder {
                if other == Lnrpc.PendingChannelsResponse() {
                    return self
                }
                if other.hasTotalLimboBalance {
                    totalLimboBalance = other.totalLimboBalance
                }
                if !other.pendingOpenChannels.isEmpty  {
                     builderResult.pendingOpenChannels += other.pendingOpenChannels
                }
                if !other.pendingClosingChannels.isEmpty  {
                     builderResult.pendingClosingChannels += other.pendingClosingChannels
                }
                if !other.pendingForceClosingChannels.isEmpty  {
                     builderResult.pendingForceClosingChannels += other.pendingForceClosingChannels
                }
                if !other.waitingCloseChannels.isEmpty  {
                     builderResult.waitingCloseChannels += other.waitingCloseChannels
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PendingChannelsResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        totalLimboBalance = try codedInputStream.readInt64()

                    case 18:
                        let subBuilder = Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        pendingOpenChannels.append(subBuilder.buildPartial())

                    case 26:
                        let subBuilder = Lnrpc.PendingChannelsResponse.ClosedChannel.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        pendingClosingChannels.append(subBuilder.buildPartial())

                    case 34:
                        let subBuilder = Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        pendingForceClosingChannels.append(subBuilder.buildPartial())

                    case 42:
                        let subBuilder = Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        waitingCloseChannels.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PendingChannelsResponse.Builder {
                let resultDecodedBuilder = Lnrpc.PendingChannelsResponse.Builder()
                if let jsonValueTotalLimboBalance = jsonMap["total_limbo_balance"] as? String {
                    resultDecodedBuilder.totalLimboBalance = Int64(jsonValueTotalLimboBalance)!
                } else if let jsonValueTotalLimboBalance = jsonMap["total_limbo_balance"] as? Int {
                    resultDecodedBuilder.totalLimboBalance = Int64(jsonValueTotalLimboBalance)
                }
                if let jsonValuePendingOpenChannels = jsonMap["pending_open_channels"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayPendingOpenChannels:Array<Lnrpc.PendingChannelsResponse.PendingOpenChannel> = []
                    for oneValuePendingOpenChannels in jsonValuePendingOpenChannels {
                        let messageFromStringPendingOpenChannels = try Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder.decodeToBuilder(jsonMap:oneValuePendingOpenChannels).build()

                        jsonArrayPendingOpenChannels.append(messageFromStringPendingOpenChannels)
                    }
                    resultDecodedBuilder.pendingOpenChannels = jsonArrayPendingOpenChannels
                }
                if let jsonValuePendingClosingChannels = jsonMap["pending_closing_channels"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayPendingClosingChannels:Array<Lnrpc.PendingChannelsResponse.ClosedChannel> = []
                    for oneValuePendingClosingChannels in jsonValuePendingClosingChannels {
                        let messageFromStringPendingClosingChannels = try Lnrpc.PendingChannelsResponse.ClosedChannel.Builder.decodeToBuilder(jsonMap:oneValuePendingClosingChannels).build()

                        jsonArrayPendingClosingChannels.append(messageFromStringPendingClosingChannels)
                    }
                    resultDecodedBuilder.pendingClosingChannels = jsonArrayPendingClosingChannels
                }
                if let jsonValuePendingForceClosingChannels = jsonMap["pending_force_closing_channels"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayPendingForceClosingChannels:Array<Lnrpc.PendingChannelsResponse.ForceClosedChannel> = []
                    for oneValuePendingForceClosingChannels in jsonValuePendingForceClosingChannels {
                        let messageFromStringPendingForceClosingChannels = try Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder.decodeToBuilder(jsonMap:oneValuePendingForceClosingChannels).build()

                        jsonArrayPendingForceClosingChannels.append(messageFromStringPendingForceClosingChannels)
                    }
                    resultDecodedBuilder.pendingForceClosingChannels = jsonArrayPendingForceClosingChannels
                }
                if let jsonValueWaitingCloseChannels = jsonMap["waiting_close_channels"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayWaitingCloseChannels:Array<Lnrpc.PendingChannelsResponse.WaitingCloseChannel> = []
                    for oneValueWaitingCloseChannels in jsonValueWaitingCloseChannels {
                        let messageFromStringWaitingCloseChannels = try Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder.decodeToBuilder(jsonMap:oneValueWaitingCloseChannels).build()

                        jsonArrayWaitingCloseChannels.append(messageFromStringWaitingCloseChannels)
                    }
                    resultDecodedBuilder.waitingCloseChannels = jsonArrayWaitingCloseChannels
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PendingChannelsResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.PendingChannelsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class WalletBalanceRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.WalletBalanceRequest.Builder

        public static func == (lhs: Lnrpc.WalletBalanceRequest, rhs: Lnrpc.WalletBalanceRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.WalletBalanceRequest.Builder {
            return Lnrpc.WalletBalanceRequest.classBuilder() as! Lnrpc.WalletBalanceRequest.Builder
        }
        public func getBuilder() -> Lnrpc.WalletBalanceRequest.Builder {
            return classBuilder() as! Lnrpc.WalletBalanceRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.WalletBalanceRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.WalletBalanceRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.WalletBalanceRequest.Builder {
            return try Lnrpc.WalletBalanceRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.WalletBalanceRequest) throws -> Lnrpc.WalletBalanceRequest.Builder {
            return try Lnrpc.WalletBalanceRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.WalletBalanceRequest {
            return try Lnrpc.WalletBalanceRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.WalletBalanceRequest {
            return try Lnrpc.WalletBalanceRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.WalletBalanceRequest"
        }
        override public func className() -> String {
            return "Lnrpc.WalletBalanceRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.WalletBalanceRequest = Lnrpc.WalletBalanceRequest()
            public func getMessage() -> Lnrpc.WalletBalanceRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.WalletBalanceRequest.Builder {
                builderResult = Lnrpc.WalletBalanceRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.WalletBalanceRequest.Builder {
                return try Lnrpc.WalletBalanceRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.WalletBalanceRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.WalletBalanceRequest {
                let returnMe:Lnrpc.WalletBalanceRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.WalletBalanceRequest) throws -> Lnrpc.WalletBalanceRequest.Builder {
                if other == Lnrpc.WalletBalanceRequest() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.WalletBalanceRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.WalletBalanceRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.WalletBalanceRequest.Builder {
                let resultDecodedBuilder = Lnrpc.WalletBalanceRequest.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.WalletBalanceRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.WalletBalanceRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class WalletBalanceResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.WalletBalanceResponse.Builder

        public static func == (lhs: Lnrpc.WalletBalanceResponse, rhs: Lnrpc.WalletBalanceResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTotalBalance == rhs.hasTotalBalance) && (!lhs.hasTotalBalance || lhs.totalBalance == rhs.totalBalance)
            fieldCheck = fieldCheck && (lhs.hasConfirmedBalance == rhs.hasConfirmedBalance) && (!lhs.hasConfirmedBalance || lhs.confirmedBalance == rhs.confirmedBalance)
            fieldCheck = fieldCheck && (lhs.hasUnconfirmedBalance == rhs.hasUnconfirmedBalance) && (!lhs.hasUnconfirmedBalance || lhs.unconfirmedBalance == rhs.unconfirmedBalance)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// The balance of the wallet
        public fileprivate(set) var totalBalance:Int64! = nil
        public fileprivate(set) var hasTotalBalance:Bool = false

        //// The confirmed balance of a wallet(with >= 1 confirmations)
        public fileprivate(set) var confirmedBalance:Int64! = nil
        public fileprivate(set) var hasConfirmedBalance:Bool = false

        //// The unconfirmed balance of a wallet(with 0 confirmations)
        public fileprivate(set) var unconfirmedBalance:Int64! = nil
        public fileprivate(set) var hasUnconfirmedBalance:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTotalBalance {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:totalBalance)
            }
            if hasConfirmedBalance {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:confirmedBalance)
            }
            if hasUnconfirmedBalance {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:unconfirmedBalance)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTotalBalance {
                serialize_size += totalBalance.computeInt64Size(fieldNumber: 1)
            }
            if hasConfirmedBalance {
                serialize_size += confirmedBalance.computeInt64Size(fieldNumber: 2)
            }
            if hasUnconfirmedBalance {
                serialize_size += unconfirmedBalance.computeInt64Size(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.WalletBalanceResponse.Builder {
            return Lnrpc.WalletBalanceResponse.classBuilder() as! Lnrpc.WalletBalanceResponse.Builder
        }
        public func getBuilder() -> Lnrpc.WalletBalanceResponse.Builder {
            return classBuilder() as! Lnrpc.WalletBalanceResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.WalletBalanceResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.WalletBalanceResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.WalletBalanceResponse.Builder {
            return try Lnrpc.WalletBalanceResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.WalletBalanceResponse) throws -> Lnrpc.WalletBalanceResponse.Builder {
            return try Lnrpc.WalletBalanceResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTotalBalance {
                jsonMap["total_balance"] = "\(totalBalance!)"
            }
            if hasConfirmedBalance {
                jsonMap["confirmed_balance"] = "\(confirmedBalance!)"
            }
            if hasUnconfirmedBalance {
                jsonMap["unconfirmed_balance"] = "\(unconfirmedBalance!)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.WalletBalanceResponse {
            return try Lnrpc.WalletBalanceResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.WalletBalanceResponse {
            return try Lnrpc.WalletBalanceResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTotalBalance {
                output += "\(indent) totalBalance: \(totalBalance) \n"
            }
            if hasConfirmedBalance {
                output += "\(indent) confirmedBalance: \(confirmedBalance) \n"
            }
            if hasUnconfirmedBalance {
                output += "\(indent) unconfirmedBalance: \(unconfirmedBalance) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTotalBalance {
                    hashCode = (hashCode &* 31) &+ totalBalance.hashValue
                }
                if hasConfirmedBalance {
                    hashCode = (hashCode &* 31) &+ confirmedBalance.hashValue
                }
                if hasUnconfirmedBalance {
                    hashCode = (hashCode &* 31) &+ unconfirmedBalance.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.WalletBalanceResponse"
        }
        override public func className() -> String {
            return "Lnrpc.WalletBalanceResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.WalletBalanceResponse = Lnrpc.WalletBalanceResponse()
            public func getMessage() -> Lnrpc.WalletBalanceResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The balance of the wallet
            public var totalBalance:Int64 {
                get {
                    return builderResult.totalBalance
                }
                set (value) {
                    builderResult.hasTotalBalance = true
                    builderResult.totalBalance = value
                }
            }
            public var hasTotalBalance:Bool {
                get {
                    return builderResult.hasTotalBalance
                }
            }
            @discardableResult
            public func setTotalBalance(_ value:Int64) -> Lnrpc.WalletBalanceResponse.Builder {
                self.totalBalance = value
                return self
            }
            @discardableResult
            public func clearTotalBalance() -> Lnrpc.WalletBalanceResponse.Builder{
                builderResult.hasTotalBalance = false
                builderResult.totalBalance = nil
                return self
            }
            //// The confirmed balance of a wallet(with >= 1 confirmations)
            public var confirmedBalance:Int64 {
                get {
                    return builderResult.confirmedBalance
                }
                set (value) {
                    builderResult.hasConfirmedBalance = true
                    builderResult.confirmedBalance = value
                }
            }
            public var hasConfirmedBalance:Bool {
                get {
                    return builderResult.hasConfirmedBalance
                }
            }
            @discardableResult
            public func setConfirmedBalance(_ value:Int64) -> Lnrpc.WalletBalanceResponse.Builder {
                self.confirmedBalance = value
                return self
            }
            @discardableResult
            public func clearConfirmedBalance() -> Lnrpc.WalletBalanceResponse.Builder{
                builderResult.hasConfirmedBalance = false
                builderResult.confirmedBalance = nil
                return self
            }
            //// The unconfirmed balance of a wallet(with 0 confirmations)
            public var unconfirmedBalance:Int64 {
                get {
                    return builderResult.unconfirmedBalance
                }
                set (value) {
                    builderResult.hasUnconfirmedBalance = true
                    builderResult.unconfirmedBalance = value
                }
            }
            public var hasUnconfirmedBalance:Bool {
                get {
                    return builderResult.hasUnconfirmedBalance
                }
            }
            @discardableResult
            public func setUnconfirmedBalance(_ value:Int64) -> Lnrpc.WalletBalanceResponse.Builder {
                self.unconfirmedBalance = value
                return self
            }
            @discardableResult
            public func clearUnconfirmedBalance() -> Lnrpc.WalletBalanceResponse.Builder{
                builderResult.hasUnconfirmedBalance = false
                builderResult.unconfirmedBalance = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.WalletBalanceResponse.Builder {
                builderResult = Lnrpc.WalletBalanceResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.WalletBalanceResponse.Builder {
                return try Lnrpc.WalletBalanceResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.WalletBalanceResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.WalletBalanceResponse {
                let returnMe:Lnrpc.WalletBalanceResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.WalletBalanceResponse) throws -> Lnrpc.WalletBalanceResponse.Builder {
                if other == Lnrpc.WalletBalanceResponse() {
                    return self
                }
                if other.hasTotalBalance {
                    totalBalance = other.totalBalance
                }
                if other.hasConfirmedBalance {
                    confirmedBalance = other.confirmedBalance
                }
                if other.hasUnconfirmedBalance {
                    unconfirmedBalance = other.unconfirmedBalance
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.WalletBalanceResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.WalletBalanceResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        totalBalance = try codedInputStream.readInt64()

                    case 16:
                        confirmedBalance = try codedInputStream.readInt64()

                    case 24:
                        unconfirmedBalance = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.WalletBalanceResponse.Builder {
                let resultDecodedBuilder = Lnrpc.WalletBalanceResponse.Builder()
                if let jsonValueTotalBalance = jsonMap["total_balance"] as? String {
                    resultDecodedBuilder.totalBalance = Int64(jsonValueTotalBalance)!
                } else if let jsonValueTotalBalance = jsonMap["total_balance"] as? Int {
                    resultDecodedBuilder.totalBalance = Int64(jsonValueTotalBalance)
                }
                if let jsonValueConfirmedBalance = jsonMap["confirmed_balance"] as? String {
                    resultDecodedBuilder.confirmedBalance = Int64(jsonValueConfirmedBalance)!
                } else if let jsonValueConfirmedBalance = jsonMap["confirmed_balance"] as? Int {
                    resultDecodedBuilder.confirmedBalance = Int64(jsonValueConfirmedBalance)
                }
                if let jsonValueUnconfirmedBalance = jsonMap["unconfirmed_balance"] as? String {
                    resultDecodedBuilder.unconfirmedBalance = Int64(jsonValueUnconfirmedBalance)!
                } else if let jsonValueUnconfirmedBalance = jsonMap["unconfirmed_balance"] as? Int {
                    resultDecodedBuilder.unconfirmedBalance = Int64(jsonValueUnconfirmedBalance)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.WalletBalanceResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.WalletBalanceResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ChannelBalanceRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ChannelBalanceRequest.Builder

        public static func == (lhs: Lnrpc.ChannelBalanceRequest, rhs: Lnrpc.ChannelBalanceRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ChannelBalanceRequest.Builder {
            return Lnrpc.ChannelBalanceRequest.classBuilder() as! Lnrpc.ChannelBalanceRequest.Builder
        }
        public func getBuilder() -> Lnrpc.ChannelBalanceRequest.Builder {
            return classBuilder() as! Lnrpc.ChannelBalanceRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChannelBalanceRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChannelBalanceRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ChannelBalanceRequest.Builder {
            return try Lnrpc.ChannelBalanceRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ChannelBalanceRequest) throws -> Lnrpc.ChannelBalanceRequest.Builder {
            return try Lnrpc.ChannelBalanceRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChannelBalanceRequest {
            return try Lnrpc.ChannelBalanceRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChannelBalanceRequest {
            return try Lnrpc.ChannelBalanceRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ChannelBalanceRequest"
        }
        override public func className() -> String {
            return "Lnrpc.ChannelBalanceRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ChannelBalanceRequest = Lnrpc.ChannelBalanceRequest()
            public func getMessage() -> Lnrpc.ChannelBalanceRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ChannelBalanceRequest.Builder {
                builderResult = Lnrpc.ChannelBalanceRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.ChannelBalanceRequest.Builder {
                return try Lnrpc.ChannelBalanceRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ChannelBalanceRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ChannelBalanceRequest {
                let returnMe:Lnrpc.ChannelBalanceRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ChannelBalanceRequest) throws -> Lnrpc.ChannelBalanceRequest.Builder {
                if other == Lnrpc.ChannelBalanceRequest() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChannelBalanceRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelBalanceRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChannelBalanceRequest.Builder {
                let resultDecodedBuilder = Lnrpc.ChannelBalanceRequest.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChannelBalanceRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ChannelBalanceRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ChannelBalanceResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ChannelBalanceResponse.Builder

        public static func == (lhs: Lnrpc.ChannelBalanceResponse, rhs: Lnrpc.ChannelBalanceResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasBalance == rhs.hasBalance) && (!lhs.hasBalance || lhs.balance == rhs.balance)
            fieldCheck = fieldCheck && (lhs.hasPendingOpenBalance == rhs.hasPendingOpenBalance) && (!lhs.hasPendingOpenBalance || lhs.pendingOpenBalance == rhs.pendingOpenBalance)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// Sum of channels balances denominated in satoshis
        public fileprivate(set) var balance:Int64! = nil
        public fileprivate(set) var hasBalance:Bool = false

        //// Sum of channels pending balances denominated in satoshis
        public fileprivate(set) var pendingOpenBalance:Int64! = nil
        public fileprivate(set) var hasPendingOpenBalance:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasBalance {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:balance)
            }
            if hasPendingOpenBalance {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:pendingOpenBalance)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasBalance {
                serialize_size += balance.computeInt64Size(fieldNumber: 1)
            }
            if hasPendingOpenBalance {
                serialize_size += pendingOpenBalance.computeInt64Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ChannelBalanceResponse.Builder {
            return Lnrpc.ChannelBalanceResponse.classBuilder() as! Lnrpc.ChannelBalanceResponse.Builder
        }
        public func getBuilder() -> Lnrpc.ChannelBalanceResponse.Builder {
            return classBuilder() as! Lnrpc.ChannelBalanceResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChannelBalanceResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChannelBalanceResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ChannelBalanceResponse.Builder {
            return try Lnrpc.ChannelBalanceResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ChannelBalanceResponse) throws -> Lnrpc.ChannelBalanceResponse.Builder {
            return try Lnrpc.ChannelBalanceResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasBalance {
                jsonMap["balance"] = "\(balance!)"
            }
            if hasPendingOpenBalance {
                jsonMap["pending_open_balance"] = "\(pendingOpenBalance!)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChannelBalanceResponse {
            return try Lnrpc.ChannelBalanceResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChannelBalanceResponse {
            return try Lnrpc.ChannelBalanceResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasBalance {
                output += "\(indent) balance: \(balance) \n"
            }
            if hasPendingOpenBalance {
                output += "\(indent) pendingOpenBalance: \(pendingOpenBalance) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasBalance {
                    hashCode = (hashCode &* 31) &+ balance.hashValue
                }
                if hasPendingOpenBalance {
                    hashCode = (hashCode &* 31) &+ pendingOpenBalance.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ChannelBalanceResponse"
        }
        override public func className() -> String {
            return "Lnrpc.ChannelBalanceResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ChannelBalanceResponse = Lnrpc.ChannelBalanceResponse()
            public func getMessage() -> Lnrpc.ChannelBalanceResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// Sum of channels balances denominated in satoshis
            public var balance:Int64 {
                get {
                    return builderResult.balance
                }
                set (value) {
                    builderResult.hasBalance = true
                    builderResult.balance = value
                }
            }
            public var hasBalance:Bool {
                get {
                    return builderResult.hasBalance
                }
            }
            @discardableResult
            public func setBalance(_ value:Int64) -> Lnrpc.ChannelBalanceResponse.Builder {
                self.balance = value
                return self
            }
            @discardableResult
            public func clearBalance() -> Lnrpc.ChannelBalanceResponse.Builder{
                builderResult.hasBalance = false
                builderResult.balance = nil
                return self
            }
            //// Sum of channels pending balances denominated in satoshis
            public var pendingOpenBalance:Int64 {
                get {
                    return builderResult.pendingOpenBalance
                }
                set (value) {
                    builderResult.hasPendingOpenBalance = true
                    builderResult.pendingOpenBalance = value
                }
            }
            public var hasPendingOpenBalance:Bool {
                get {
                    return builderResult.hasPendingOpenBalance
                }
            }
            @discardableResult
            public func setPendingOpenBalance(_ value:Int64) -> Lnrpc.ChannelBalanceResponse.Builder {
                self.pendingOpenBalance = value
                return self
            }
            @discardableResult
            public func clearPendingOpenBalance() -> Lnrpc.ChannelBalanceResponse.Builder{
                builderResult.hasPendingOpenBalance = false
                builderResult.pendingOpenBalance = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ChannelBalanceResponse.Builder {
                builderResult = Lnrpc.ChannelBalanceResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.ChannelBalanceResponse.Builder {
                return try Lnrpc.ChannelBalanceResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ChannelBalanceResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ChannelBalanceResponse {
                let returnMe:Lnrpc.ChannelBalanceResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ChannelBalanceResponse) throws -> Lnrpc.ChannelBalanceResponse.Builder {
                if other == Lnrpc.ChannelBalanceResponse() {
                    return self
                }
                if other.hasBalance {
                    balance = other.balance
                }
                if other.hasPendingOpenBalance {
                    pendingOpenBalance = other.pendingOpenBalance
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChannelBalanceResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelBalanceResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        balance = try codedInputStream.readInt64()

                    case 16:
                        pendingOpenBalance = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChannelBalanceResponse.Builder {
                let resultDecodedBuilder = Lnrpc.ChannelBalanceResponse.Builder()
                if let jsonValueBalance = jsonMap["balance"] as? String {
                    resultDecodedBuilder.balance = Int64(jsonValueBalance)!
                } else if let jsonValueBalance = jsonMap["balance"] as? Int {
                    resultDecodedBuilder.balance = Int64(jsonValueBalance)
                }
                if let jsonValuePendingOpenBalance = jsonMap["pending_open_balance"] as? String {
                    resultDecodedBuilder.pendingOpenBalance = Int64(jsonValuePendingOpenBalance)!
                } else if let jsonValuePendingOpenBalance = jsonMap["pending_open_balance"] as? Int {
                    resultDecodedBuilder.pendingOpenBalance = Int64(jsonValuePendingOpenBalance)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChannelBalanceResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ChannelBalanceResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class QueryRoutesRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.QueryRoutesRequest.Builder

        public static func == (lhs: Lnrpc.QueryRoutesRequest, rhs: Lnrpc.QueryRoutesRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasPubKey == rhs.hasPubKey) && (!lhs.hasPubKey || lhs.pubKey == rhs.pubKey)
            fieldCheck = fieldCheck && (lhs.hasAmt == rhs.hasAmt) && (!lhs.hasAmt || lhs.amt == rhs.amt)
            fieldCheck = fieldCheck && (lhs.hasNumRoutes == rhs.hasNumRoutes) && (!lhs.hasNumRoutes || lhs.numRoutes == rhs.numRoutes)
            fieldCheck = fieldCheck && (lhs.hasFinalCltvDelta == rhs.hasFinalCltvDelta) && (!lhs.hasFinalCltvDelta || lhs.finalCltvDelta == rhs.finalCltvDelta)
            fieldCheck = fieldCheck && (lhs.hasFeeLimit == rhs.hasFeeLimit) && (!lhs.hasFeeLimit || lhs.feeLimit == rhs.feeLimit)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// The 33-byte hex-encoded public key for the payment destination
        public fileprivate(set) var pubKey:String! = nil
        public fileprivate(set) var hasPubKey:Bool = false

        //// The amount to send expressed in satoshis
        public fileprivate(set) var amt:Int64! = nil
        public fileprivate(set) var hasAmt:Bool = false

        //// The max number of routes to return.
        public fileprivate(set) var numRoutes:Int32! = nil
        public fileprivate(set) var hasNumRoutes:Bool = false

        //// An optional CLTV delta from the current height that should be used for the timelock of the final hop
        public fileprivate(set) var finalCltvDelta:Int32! = nil
        public fileprivate(set) var hasFinalCltvDelta:Bool = false

        public fileprivate(set) var feeLimit:Lnrpc.FeeLimit!
        public fileprivate(set) var hasFeeLimit:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasPubKey {
                try codedOutputStream.writeString(fieldNumber: 1, value:pubKey)
            }
            if hasAmt {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:amt)
            }
            if hasNumRoutes {
                try codedOutputStream.writeInt32(fieldNumber: 3, value:numRoutes)
            }
            if hasFinalCltvDelta {
                try codedOutputStream.writeInt32(fieldNumber: 4, value:finalCltvDelta)
            }
            if hasFeeLimit {
                try codedOutputStream.writeMessage(fieldNumber: 5, value:feeLimit)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasPubKey {
                serialize_size += pubKey.computeStringSize(fieldNumber: 1)
            }
            if hasAmt {
                serialize_size += amt.computeInt64Size(fieldNumber: 2)
            }
            if hasNumRoutes {
                serialize_size += numRoutes.computeInt32Size(fieldNumber: 3)
            }
            if hasFinalCltvDelta {
                serialize_size += finalCltvDelta.computeInt32Size(fieldNumber: 4)
            }
            if hasFeeLimit {
                if let varSizefeeLimit = feeLimit?.computeMessageSize(fieldNumber: 5) {
                    serialize_size += varSizefeeLimit
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.QueryRoutesRequest.Builder {
            return Lnrpc.QueryRoutesRequest.classBuilder() as! Lnrpc.QueryRoutesRequest.Builder
        }
        public func getBuilder() -> Lnrpc.QueryRoutesRequest.Builder {
            return classBuilder() as! Lnrpc.QueryRoutesRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.QueryRoutesRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.QueryRoutesRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.QueryRoutesRequest.Builder {
            return try Lnrpc.QueryRoutesRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.QueryRoutesRequest) throws -> Lnrpc.QueryRoutesRequest.Builder {
            return try Lnrpc.QueryRoutesRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasPubKey {
                jsonMap["pubKey"] = pubKey
            }
            if hasAmt {
                jsonMap["amt"] = "\(amt!)"
            }
            if hasNumRoutes {
                jsonMap["numRoutes"] = Int(numRoutes)
            }
            if hasFinalCltvDelta {
                jsonMap["finalCltvDelta"] = Int(finalCltvDelta)
            }
            if hasFeeLimit {
                jsonMap["feeLimit"] = try feeLimit.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.QueryRoutesRequest {
            return try Lnrpc.QueryRoutesRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.QueryRoutesRequest {
            return try Lnrpc.QueryRoutesRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasPubKey {
                output += "\(indent) pubKey: \(pubKey) \n"
            }
            if hasAmt {
                output += "\(indent) amt: \(amt) \n"
            }
            if hasNumRoutes {
                output += "\(indent) numRoutes: \(numRoutes) \n"
            }
            if hasFinalCltvDelta {
                output += "\(indent) finalCltvDelta: \(finalCltvDelta) \n"
            }
            if hasFeeLimit {
                output += "\(indent) feeLimit {\n"
                if let outDescFeeLimit = feeLimit {
                    output += try outDescFeeLimit.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasPubKey {
                    hashCode = (hashCode &* 31) &+ pubKey.hashValue
                }
                if hasAmt {
                    hashCode = (hashCode &* 31) &+ amt.hashValue
                }
                if hasNumRoutes {
                    hashCode = (hashCode &* 31) &+ numRoutes.hashValue
                }
                if hasFinalCltvDelta {
                    hashCode = (hashCode &* 31) &+ finalCltvDelta.hashValue
                }
                if hasFeeLimit {
                    if let hashValuefeeLimit = feeLimit?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuefeeLimit
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.QueryRoutesRequest"
        }
        override public func className() -> String {
            return "Lnrpc.QueryRoutesRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.QueryRoutesRequest = Lnrpc.QueryRoutesRequest()
            public func getMessage() -> Lnrpc.QueryRoutesRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The 33-byte hex-encoded public key for the payment destination
            public var pubKey:String {
                get {
                    return builderResult.pubKey
                }
                set (value) {
                    builderResult.hasPubKey = true
                    builderResult.pubKey = value
                }
            }
            public var hasPubKey:Bool {
                get {
                    return builderResult.hasPubKey
                }
            }
            @discardableResult
            public func setPubKey(_ value:String) -> Lnrpc.QueryRoutesRequest.Builder {
                self.pubKey = value
                return self
            }
            @discardableResult
            public func clearPubKey() -> Lnrpc.QueryRoutesRequest.Builder{
                builderResult.hasPubKey = false
                builderResult.pubKey = nil
                return self
            }
            //// The amount to send expressed in satoshis
            public var amt:Int64 {
                get {
                    return builderResult.amt
                }
                set (value) {
                    builderResult.hasAmt = true
                    builderResult.amt = value
                }
            }
            public var hasAmt:Bool {
                get {
                    return builderResult.hasAmt
                }
            }
            @discardableResult
            public func setAmt(_ value:Int64) -> Lnrpc.QueryRoutesRequest.Builder {
                self.amt = value
                return self
            }
            @discardableResult
            public func clearAmt() -> Lnrpc.QueryRoutesRequest.Builder{
                builderResult.hasAmt = false
                builderResult.amt = nil
                return self
            }
            //// The max number of routes to return.
            public var numRoutes:Int32 {
                get {
                    return builderResult.numRoutes
                }
                set (value) {
                    builderResult.hasNumRoutes = true
                    builderResult.numRoutes = value
                }
            }
            public var hasNumRoutes:Bool {
                get {
                    return builderResult.hasNumRoutes
                }
            }
            @discardableResult
            public func setNumRoutes(_ value:Int32) -> Lnrpc.QueryRoutesRequest.Builder {
                self.numRoutes = value
                return self
            }
            @discardableResult
            public func clearNumRoutes() -> Lnrpc.QueryRoutesRequest.Builder{
                builderResult.hasNumRoutes = false
                builderResult.numRoutes = nil
                return self
            }
            //// An optional CLTV delta from the current height that should be used for the timelock of the final hop
            public var finalCltvDelta:Int32 {
                get {
                    return builderResult.finalCltvDelta
                }
                set (value) {
                    builderResult.hasFinalCltvDelta = true
                    builderResult.finalCltvDelta = value
                }
            }
            public var hasFinalCltvDelta:Bool {
                get {
                    return builderResult.hasFinalCltvDelta
                }
            }
            @discardableResult
            public func setFinalCltvDelta(_ value:Int32) -> Lnrpc.QueryRoutesRequest.Builder {
                self.finalCltvDelta = value
                return self
            }
            @discardableResult
            public func clearFinalCltvDelta() -> Lnrpc.QueryRoutesRequest.Builder{
                builderResult.hasFinalCltvDelta = false
                builderResult.finalCltvDelta = nil
                return self
            }
            ///*
            ///The maximum number of satoshis that will be paid as a fee of the payment.
            ///This value can be represented either as a percentage of the amount being
            ///sent, or as a fixed amount of the maximum fee the user is willing the pay to
            ///send the payment.
            public var feeLimit:Lnrpc.FeeLimit! {
                get {
                    if feeLimitBuilder_ != nil {
                        builderResult.feeLimit = feeLimitBuilder_.getMessage()
                    }
                    return builderResult.feeLimit
                }
                set (value) {
                    builderResult.hasFeeLimit = value != nil
                    builderResult.feeLimit = value
                }
            }
            public var hasFeeLimit:Bool {
                get {
                    return builderResult.hasFeeLimit
                }
            }
            fileprivate var feeLimitBuilder_:Lnrpc.FeeLimit.Builder! {
                didSet {
                    builderResult.hasFeeLimit = true
                }
            }
            public func getFeeLimitBuilder() -> Lnrpc.FeeLimit.Builder {
                if feeLimitBuilder_ == nil {
                    feeLimitBuilder_ = Lnrpc.FeeLimit.Builder()
                    builderResult.feeLimit = feeLimitBuilder_.getMessage()
                    if feeLimit != nil {
                        try! feeLimitBuilder_.mergeFrom(other: feeLimit)
                    }
                }
                return feeLimitBuilder_
            }
            @discardableResult
            public func setFeeLimit(_ value:Lnrpc.FeeLimit!) -> Lnrpc.QueryRoutesRequest.Builder {
                self.feeLimit = value
                return self
            }
            @discardableResult
            public func mergeFeeLimit(value:Lnrpc.FeeLimit) throws -> Lnrpc.QueryRoutesRequest.Builder {
                if builderResult.hasFeeLimit {
                    builderResult.feeLimit = try Lnrpc.FeeLimit.builderWithPrototype(prototype:builderResult.feeLimit).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.feeLimit = value
                }
                builderResult.hasFeeLimit = true
                return self
            }
            @discardableResult
            public func clearFeeLimit() -> Lnrpc.QueryRoutesRequest.Builder {
                feeLimitBuilder_ = nil
                builderResult.hasFeeLimit = false
                builderResult.feeLimit = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.QueryRoutesRequest.Builder {
                builderResult = Lnrpc.QueryRoutesRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.QueryRoutesRequest.Builder {
                return try Lnrpc.QueryRoutesRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.QueryRoutesRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.QueryRoutesRequest {
                let returnMe:Lnrpc.QueryRoutesRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.QueryRoutesRequest) throws -> Lnrpc.QueryRoutesRequest.Builder {
                if other == Lnrpc.QueryRoutesRequest() {
                    return self
                }
                if other.hasPubKey {
                    pubKey = other.pubKey
                }
                if other.hasAmt {
                    amt = other.amt
                }
                if other.hasNumRoutes {
                    numRoutes = other.numRoutes
                }
                if other.hasFinalCltvDelta {
                    finalCltvDelta = other.finalCltvDelta
                }
                if (other.hasFeeLimit) {
                    try mergeFeeLimit(value: other.feeLimit)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.QueryRoutesRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.QueryRoutesRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        pubKey = try codedInputStream.readString()

                    case 16:
                        amt = try codedInputStream.readInt64()

                    case 24:
                        numRoutes = try codedInputStream.readInt32()

                    case 32:
                        finalCltvDelta = try codedInputStream.readInt32()

                    case 42:
                        let subBuilder:Lnrpc.FeeLimit.Builder = Lnrpc.FeeLimit.Builder()
                        if hasFeeLimit {
                            try subBuilder.mergeFrom(other: feeLimit)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        feeLimit = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.QueryRoutesRequest.Builder {
                let resultDecodedBuilder = Lnrpc.QueryRoutesRequest.Builder()
                if let jsonValuePubKey = jsonMap["pubKey"] as? String {
                    resultDecodedBuilder.pubKey = jsonValuePubKey
                }
                if let jsonValueAmt = jsonMap["amt"] as? String {
                    resultDecodedBuilder.amt = Int64(jsonValueAmt)!
                } else if let jsonValueAmt = jsonMap["amt"] as? Int {
                    resultDecodedBuilder.amt = Int64(jsonValueAmt)
                }
                if let jsonValueNumRoutes = jsonMap["numRoutes"] as? Int {
                    resultDecodedBuilder.numRoutes = Int32(jsonValueNumRoutes)
                } else if let jsonValueNumRoutes = jsonMap["numRoutes"] as? String {
                    resultDecodedBuilder.numRoutes = Int32(jsonValueNumRoutes)!
                }
                if let jsonValueFinalCltvDelta = jsonMap["finalCltvDelta"] as? Int {
                    resultDecodedBuilder.finalCltvDelta = Int32(jsonValueFinalCltvDelta)
                } else if let jsonValueFinalCltvDelta = jsonMap["finalCltvDelta"] as? String {
                    resultDecodedBuilder.finalCltvDelta = Int32(jsonValueFinalCltvDelta)!
                }
                if let jsonValueFeeLimit = jsonMap["feeLimit"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.feeLimit = try Lnrpc.FeeLimit.Builder.decodeToBuilder(jsonMap:jsonValueFeeLimit).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.QueryRoutesRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.QueryRoutesRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class QueryRoutesResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.QueryRoutesResponse.Builder

        public static func == (lhs: Lnrpc.QueryRoutesResponse, rhs: Lnrpc.QueryRoutesResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.routes == rhs.routes)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var routes:Array<Lnrpc.Route>  = Array<Lnrpc.Route>()
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementRoutes in routes {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementRoutes)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementRoutes in routes {
                serialize_size += oneElementRoutes.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.QueryRoutesResponse.Builder {
            return Lnrpc.QueryRoutesResponse.classBuilder() as! Lnrpc.QueryRoutesResponse.Builder
        }
        public func getBuilder() -> Lnrpc.QueryRoutesResponse.Builder {
            return classBuilder() as! Lnrpc.QueryRoutesResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.QueryRoutesResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.QueryRoutesResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.QueryRoutesResponse.Builder {
            return try Lnrpc.QueryRoutesResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.QueryRoutesResponse) throws -> Lnrpc.QueryRoutesResponse.Builder {
            return try Lnrpc.QueryRoutesResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !routes.isEmpty {
                var jsonArrayRoutes:Array<Dictionary<String,Any>> = []
                for oneValueRoutes in routes {
                    let ecodedMessageRoutes = try oneValueRoutes.encode()
                    jsonArrayRoutes.append(ecodedMessageRoutes)
                }
                jsonMap["routes"] = jsonArrayRoutes
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.QueryRoutesResponse {
            return try Lnrpc.QueryRoutesResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.QueryRoutesResponse {
            return try Lnrpc.QueryRoutesResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var routesElementIndex:Int = 0
            for oneElementRoutes in routes {
                output += "\(indent) routes[\(routesElementIndex)] {\n"
                output += try oneElementRoutes.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                routesElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementRoutes in routes {
                    hashCode = (hashCode &* 31) &+ oneElementRoutes.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.QueryRoutesResponse"
        }
        override public func className() -> String {
            return "Lnrpc.QueryRoutesResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.QueryRoutesResponse = Lnrpc.QueryRoutesResponse()
            public func getMessage() -> Lnrpc.QueryRoutesResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var routes:Array<Lnrpc.Route> {
                get {
                    return builderResult.routes
                }
                set (value) {
                    builderResult.routes = value
                }
            }
            @discardableResult
            public func setRoutes(_ value:Array<Lnrpc.Route>) -> Lnrpc.QueryRoutesResponse.Builder {
                self.routes = value
                return self
            }
            @discardableResult
            public func clearRoutes() -> Lnrpc.QueryRoutesResponse.Builder {
                builderResult.routes.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.QueryRoutesResponse.Builder {
                builderResult = Lnrpc.QueryRoutesResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.QueryRoutesResponse.Builder {
                return try Lnrpc.QueryRoutesResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.QueryRoutesResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.QueryRoutesResponse {
                let returnMe:Lnrpc.QueryRoutesResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.QueryRoutesResponse) throws -> Lnrpc.QueryRoutesResponse.Builder {
                if other == Lnrpc.QueryRoutesResponse() {
                    return self
                }
                if !other.routes.isEmpty  {
                     builderResult.routes += other.routes
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.QueryRoutesResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.QueryRoutesResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Lnrpc.Route.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        routes.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.QueryRoutesResponse.Builder {
                let resultDecodedBuilder = Lnrpc.QueryRoutesResponse.Builder()
                if let jsonValueRoutes = jsonMap["routes"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayRoutes:Array<Lnrpc.Route> = []
                    for oneValueRoutes in jsonValueRoutes {
                        let messageFromStringRoutes = try Lnrpc.Route.Builder.decodeToBuilder(jsonMap:oneValueRoutes).build()

                        jsonArrayRoutes.append(messageFromStringRoutes)
                    }
                    resultDecodedBuilder.routes = jsonArrayRoutes
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.QueryRoutesResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.QueryRoutesResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class Hop : GeneratedMessage {
        public typealias BuilderType = Lnrpc.Hop.Builder

        public static func == (lhs: Lnrpc.Hop, rhs: Lnrpc.Hop) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasChanId == rhs.hasChanId) && (!lhs.hasChanId || lhs.chanId == rhs.chanId)
            fieldCheck = fieldCheck && (lhs.hasChanCapacity == rhs.hasChanCapacity) && (!lhs.hasChanCapacity || lhs.chanCapacity == rhs.chanCapacity)
            fieldCheck = fieldCheck && (lhs.hasAmtToForward == rhs.hasAmtToForward) && (!lhs.hasAmtToForward || lhs.amtToForward == rhs.amtToForward)
            fieldCheck = fieldCheck && (lhs.hasFee == rhs.hasFee) && (!lhs.hasFee || lhs.fee == rhs.fee)
            fieldCheck = fieldCheck && (lhs.hasExpiry == rhs.hasExpiry) && (!lhs.hasExpiry || lhs.expiry == rhs.expiry)
            fieldCheck = fieldCheck && (lhs.hasAmtToForwardMsat == rhs.hasAmtToForwardMsat) && (!lhs.hasAmtToForwardMsat || lhs.amtToForwardMsat == rhs.amtToForwardMsat)
            fieldCheck = fieldCheck && (lhs.hasFeeMsat == rhs.hasFeeMsat) && (!lhs.hasFeeMsat || lhs.feeMsat == rhs.feeMsat)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///*
        ///The unique channel ID for the channel. The first 3 bytes are the block
        ///height, the next 3 the index within the block, and the last 2 bytes are the
        ///output index for the channel.
        public fileprivate(set) var chanId:UInt64! = nil
        public fileprivate(set) var hasChanId:Bool = false

        public fileprivate(set) var chanCapacity:Int64! = nil
        public fileprivate(set) var hasChanCapacity:Bool = false

        @available(*, deprecated:0.1, message:"amtToForward is marked as \"Deprecated\"")
        public fileprivate(set) var amtToForward:Int64! = nil
        public fileprivate(set) var hasAmtToForward:Bool = false

        @available(*, deprecated:0.1, message:"fee is marked as \"Deprecated\"")
        public fileprivate(set) var fee:Int64! = nil
        public fileprivate(set) var hasFee:Bool = false

        public fileprivate(set) var expiry:UInt32! = nil
        public fileprivate(set) var hasExpiry:Bool = false

        public fileprivate(set) var amtToForwardMsat:Int64! = nil
        public fileprivate(set) var hasAmtToForwardMsat:Bool = false

        public fileprivate(set) var feeMsat:Int64! = nil
        public fileprivate(set) var hasFeeMsat:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasChanId {
                try codedOutputStream.writeUInt64(fieldNumber: 1, value:chanId)
            }
            if hasChanCapacity {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:chanCapacity)
            }
            if hasAmtToForward {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:amtToForward)
            }
            if hasFee {
                try codedOutputStream.writeInt64(fieldNumber: 4, value:fee)
            }
            if hasExpiry {
                try codedOutputStream.writeUInt32(fieldNumber: 5, value:expiry)
            }
            if hasAmtToForwardMsat {
                try codedOutputStream.writeInt64(fieldNumber: 6, value:amtToForwardMsat)
            }
            if hasFeeMsat {
                try codedOutputStream.writeInt64(fieldNumber: 7, value:feeMsat)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasChanId {
                serialize_size += chanId.computeUInt64Size(fieldNumber: 1)
            }
            if hasChanCapacity {
                serialize_size += chanCapacity.computeInt64Size(fieldNumber: 2)
            }
            if hasAmtToForward {
                serialize_size += amtToForward.computeInt64Size(fieldNumber: 3)
            }
            if hasFee {
                serialize_size += fee.computeInt64Size(fieldNumber: 4)
            }
            if hasExpiry {
                serialize_size += expiry.computeUInt32Size(fieldNumber: 5)
            }
            if hasAmtToForwardMsat {
                serialize_size += amtToForwardMsat.computeInt64Size(fieldNumber: 6)
            }
            if hasFeeMsat {
                serialize_size += feeMsat.computeInt64Size(fieldNumber: 7)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.Hop.Builder {
            return Lnrpc.Hop.classBuilder() as! Lnrpc.Hop.Builder
        }
        public func getBuilder() -> Lnrpc.Hop.Builder {
            return classBuilder() as! Lnrpc.Hop.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.Hop.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.Hop.Builder()
        }
        public func toBuilder() throws -> Lnrpc.Hop.Builder {
            return try Lnrpc.Hop.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.Hop) throws -> Lnrpc.Hop.Builder {
            return try Lnrpc.Hop.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasChanId {
                jsonMap["chan_id"] = "\(chanId!)"
            }
            if hasChanCapacity {
                jsonMap["chan_capacity"] = "\(chanCapacity!)"
            }
            if hasAmtToForward {
                jsonMap["amt_to_forward"] = "\(amtToForward!)"
            }
            if hasFee {
                jsonMap["fee"] = "\(fee!)"
            }
            if hasExpiry {
                jsonMap["expiry"] = UInt(expiry)
            }
            if hasAmtToForwardMsat {
                jsonMap["amt_to_forward_msat"] = "\(amtToForwardMsat!)"
            }
            if hasFeeMsat {
                jsonMap["fee_msat"] = "\(feeMsat!)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.Hop {
            return try Lnrpc.Hop.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.Hop {
            return try Lnrpc.Hop.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasChanId {
                output += "\(indent) chanId: \(chanId) \n"
            }
            if hasChanCapacity {
                output += "\(indent) chanCapacity: \(chanCapacity) \n"
            }
            if hasAmtToForward {
                output += "\(indent) amtToForward: \(amtToForward) \n"
            }
            if hasFee {
                output += "\(indent) fee: \(fee) \n"
            }
            if hasExpiry {
                output += "\(indent) expiry: \(expiry) \n"
            }
            if hasAmtToForwardMsat {
                output += "\(indent) amtToForwardMsat: \(amtToForwardMsat) \n"
            }
            if hasFeeMsat {
                output += "\(indent) feeMsat: \(feeMsat) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasChanId {
                    hashCode = (hashCode &* 31) &+ chanId.hashValue
                }
                if hasChanCapacity {
                    hashCode = (hashCode &* 31) &+ chanCapacity.hashValue
                }
                if hasAmtToForward {
                    hashCode = (hashCode &* 31) &+ amtToForward.hashValue
                }
                if hasFee {
                    hashCode = (hashCode &* 31) &+ fee.hashValue
                }
                if hasExpiry {
                    hashCode = (hashCode &* 31) &+ expiry.hashValue
                }
                if hasAmtToForwardMsat {
                    hashCode = (hashCode &* 31) &+ amtToForwardMsat.hashValue
                }
                if hasFeeMsat {
                    hashCode = (hashCode &* 31) &+ feeMsat.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.Hop"
        }
        override public func className() -> String {
            return "Lnrpc.Hop"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.Hop = Lnrpc.Hop()
            public func getMessage() -> Lnrpc.Hop {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///*
            ///The unique channel ID for the channel. The first 3 bytes are the block
            ///height, the next 3 the index within the block, and the last 2 bytes are the
            ///output index for the channel.
            public var chanId:UInt64 {
                get {
                    return builderResult.chanId
                }
                set (value) {
                    builderResult.hasChanId = true
                    builderResult.chanId = value
                }
            }
            public var hasChanId:Bool {
                get {
                    return builderResult.hasChanId
                }
            }
            @discardableResult
            public func setChanId(_ value:UInt64) -> Lnrpc.Hop.Builder {
                self.chanId = value
                return self
            }
            @discardableResult
            public func clearChanId() -> Lnrpc.Hop.Builder{
                builderResult.hasChanId = false
                builderResult.chanId = nil
                return self
            }
            public var chanCapacity:Int64 {
                get {
                    return builderResult.chanCapacity
                }
                set (value) {
                    builderResult.hasChanCapacity = true
                    builderResult.chanCapacity = value
                }
            }
            public var hasChanCapacity:Bool {
                get {
                    return builderResult.hasChanCapacity
                }
            }
            @discardableResult
            public func setChanCapacity(_ value:Int64) -> Lnrpc.Hop.Builder {
                self.chanCapacity = value
                return self
            }
            @discardableResult
            public func clearChanCapacity() -> Lnrpc.Hop.Builder{
                builderResult.hasChanCapacity = false
                builderResult.chanCapacity = nil
                return self
            }
            public var amtToForward:Int64 {
                get {
                    return builderResult.amtToForward
                }
                set (value) {
                    builderResult.hasAmtToForward = true
                    builderResult.amtToForward = value
                }
            }
            public var hasAmtToForward:Bool {
                get {
                    return builderResult.hasAmtToForward
                }
            }
            @discardableResult
            public func setAmtToForward(_ value:Int64) -> Lnrpc.Hop.Builder {
                self.amtToForward = value
                return self
            }
            @discardableResult
            public func clearAmtToForward() -> Lnrpc.Hop.Builder{
                builderResult.hasAmtToForward = false
                builderResult.amtToForward = nil
                return self
            }
            public var fee:Int64 {
                get {
                    return builderResult.fee
                }
                set (value) {
                    builderResult.hasFee = true
                    builderResult.fee = value
                }
            }
            public var hasFee:Bool {
                get {
                    return builderResult.hasFee
                }
            }
            @discardableResult
            public func setFee(_ value:Int64) -> Lnrpc.Hop.Builder {
                self.fee = value
                return self
            }
            @discardableResult
            public func clearFee() -> Lnrpc.Hop.Builder{
                builderResult.hasFee = false
                builderResult.fee = nil
                return self
            }
            public var expiry:UInt32 {
                get {
                    return builderResult.expiry
                }
                set (value) {
                    builderResult.hasExpiry = true
                    builderResult.expiry = value
                }
            }
            public var hasExpiry:Bool {
                get {
                    return builderResult.hasExpiry
                }
            }
            @discardableResult
            public func setExpiry(_ value:UInt32) -> Lnrpc.Hop.Builder {
                self.expiry = value
                return self
            }
            @discardableResult
            public func clearExpiry() -> Lnrpc.Hop.Builder{
                builderResult.hasExpiry = false
                builderResult.expiry = nil
                return self
            }
            public var amtToForwardMsat:Int64 {
                get {
                    return builderResult.amtToForwardMsat
                }
                set (value) {
                    builderResult.hasAmtToForwardMsat = true
                    builderResult.amtToForwardMsat = value
                }
            }
            public var hasAmtToForwardMsat:Bool {
                get {
                    return builderResult.hasAmtToForwardMsat
                }
            }
            @discardableResult
            public func setAmtToForwardMsat(_ value:Int64) -> Lnrpc.Hop.Builder {
                self.amtToForwardMsat = value
                return self
            }
            @discardableResult
            public func clearAmtToForwardMsat() -> Lnrpc.Hop.Builder{
                builderResult.hasAmtToForwardMsat = false
                builderResult.amtToForwardMsat = nil
                return self
            }
            public var feeMsat:Int64 {
                get {
                    return builderResult.feeMsat
                }
                set (value) {
                    builderResult.hasFeeMsat = true
                    builderResult.feeMsat = value
                }
            }
            public var hasFeeMsat:Bool {
                get {
                    return builderResult.hasFeeMsat
                }
            }
            @discardableResult
            public func setFeeMsat(_ value:Int64) -> Lnrpc.Hop.Builder {
                self.feeMsat = value
                return self
            }
            @discardableResult
            public func clearFeeMsat() -> Lnrpc.Hop.Builder{
                builderResult.hasFeeMsat = false
                builderResult.feeMsat = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.Hop.Builder {
                builderResult = Lnrpc.Hop()
                return self
            }
            override public func clone() throws -> Lnrpc.Hop.Builder {
                return try Lnrpc.Hop.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.Hop {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.Hop {
                let returnMe:Lnrpc.Hop = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.Hop) throws -> Lnrpc.Hop.Builder {
                if other == Lnrpc.Hop() {
                    return self
                }
                if other.hasChanId {
                    chanId = other.chanId
                }
                if other.hasChanCapacity {
                    chanCapacity = other.chanCapacity
                }
                if other.hasAmtToForward {
                    amtToForward = other.amtToForward
                }
                if other.hasFee {
                    fee = other.fee
                }
                if other.hasExpiry {
                    expiry = other.expiry
                }
                if other.hasAmtToForwardMsat {
                    amtToForwardMsat = other.amtToForwardMsat
                }
                if other.hasFeeMsat {
                    feeMsat = other.feeMsat
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.Hop.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Hop.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        chanId = try codedInputStream.readUInt64()

                    case 16:
                        chanCapacity = try codedInputStream.readInt64()

                    case 24:
                        amtToForward = try codedInputStream.readInt64()

                    case 32:
                        fee = try codedInputStream.readInt64()

                    case 40:
                        expiry = try codedInputStream.readUInt32()

                    case 48:
                        amtToForwardMsat = try codedInputStream.readInt64()

                    case 56:
                        feeMsat = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.Hop.Builder {
                let resultDecodedBuilder = Lnrpc.Hop.Builder()
                if let jsonValueChanId = jsonMap["chan_id"] as? String {
                    resultDecodedBuilder.chanId = UInt64(jsonValueChanId)!
                } else if let jsonValueChanId = jsonMap["chan_id"] as? UInt {
                    resultDecodedBuilder.chanId = UInt64(jsonValueChanId)
                }
                if let jsonValueChanCapacity = jsonMap["chan_capacity"] as? String {
                    resultDecodedBuilder.chanCapacity = Int64(jsonValueChanCapacity)!
                } else if let jsonValueChanCapacity = jsonMap["chan_capacity"] as? Int {
                    resultDecodedBuilder.chanCapacity = Int64(jsonValueChanCapacity)
                }
                if let jsonValueAmtToForward = jsonMap["amt_to_forward"] as? String {
                    resultDecodedBuilder.amtToForward = Int64(jsonValueAmtToForward)!
                } else if let jsonValueAmtToForward = jsonMap["amt_to_forward"] as? Int {
                    resultDecodedBuilder.amtToForward = Int64(jsonValueAmtToForward)
                }
                if let jsonValueFee = jsonMap["fee"] as? String {
                    resultDecodedBuilder.fee = Int64(jsonValueFee)!
                } else if let jsonValueFee = jsonMap["fee"] as? Int {
                    resultDecodedBuilder.fee = Int64(jsonValueFee)
                }
                if let jsonValueExpiry = jsonMap["expiry"] as? UInt {
                    resultDecodedBuilder.expiry = UInt32(jsonValueExpiry)
                } else if let jsonValueExpiry = jsonMap["expiry"] as? String {
                    resultDecodedBuilder.expiry = UInt32(jsonValueExpiry)!
                }
                if let jsonValueAmtToForwardMsat = jsonMap["amt_to_forward_msat"] as? String {
                    resultDecodedBuilder.amtToForwardMsat = Int64(jsonValueAmtToForwardMsat)!
                } else if let jsonValueAmtToForwardMsat = jsonMap["amt_to_forward_msat"] as? Int {
                    resultDecodedBuilder.amtToForwardMsat = Int64(jsonValueAmtToForwardMsat)
                }
                if let jsonValueFeeMsat = jsonMap["fee_msat"] as? String {
                    resultDecodedBuilder.feeMsat = Int64(jsonValueFeeMsat)!
                } else if let jsonValueFeeMsat = jsonMap["fee_msat"] as? Int {
                    resultDecodedBuilder.feeMsat = Int64(jsonValueFeeMsat)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.Hop.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.Hop.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    ///*
    ///A path through the channel graph which runs over one or more channels in
    ///succession. This struct carries all the information required to craft the
    ///Sphinx onion packet, and send the payment along the first hop in the path. A
    ///route is only selected as valid if all the channels have sufficient capacity to
    ///carry the initial payment amount after fees are accounted for.
    final public class Route : GeneratedMessage {
        public typealias BuilderType = Lnrpc.Route.Builder

        public static func == (lhs: Lnrpc.Route, rhs: Lnrpc.Route) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTotalTimeLock == rhs.hasTotalTimeLock) && (!lhs.hasTotalTimeLock || lhs.totalTimeLock == rhs.totalTimeLock)
            fieldCheck = fieldCheck && (lhs.hasTotalFees == rhs.hasTotalFees) && (!lhs.hasTotalFees || lhs.totalFees == rhs.totalFees)
            fieldCheck = fieldCheck && (lhs.hasTotalAmt == rhs.hasTotalAmt) && (!lhs.hasTotalAmt || lhs.totalAmt == rhs.totalAmt)
            fieldCheck = fieldCheck && (lhs.hops == rhs.hops)
            fieldCheck = fieldCheck && (lhs.hasTotalFeesMsat == rhs.hasTotalFeesMsat) && (!lhs.hasTotalFeesMsat || lhs.totalFeesMsat == rhs.totalFeesMsat)
            fieldCheck = fieldCheck && (lhs.hasTotalAmtMsat == rhs.hasTotalAmtMsat) && (!lhs.hasTotalAmtMsat || lhs.totalAmtMsat == rhs.totalAmtMsat)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///*
        ///The cumulative (final) time lock across the entire route.  This is the CLTV
        ///value that should be extended to the first hop in the route. All other hops
        ///will decrement the time-lock as advertised, leaving enough time for all
        ///hops to wait for or present the payment preimage to complete the payment.
        public fileprivate(set) var totalTimeLock:UInt32! = nil
        public fileprivate(set) var hasTotalTimeLock:Bool = false

        ///*
        ///The sum of the fees paid at each hop within the final route.  In the case
        ///of a one-hop payment, this value will be zero as we don't need to pay a fee
        ///it ourself.
        @available(*, deprecated:0.1, message:"totalFees is marked as \"Deprecated\"")
        public fileprivate(set) var totalFees:Int64! = nil
        public fileprivate(set) var hasTotalFees:Bool = false

        ///*
        ///The total amount of funds required to complete a payment over this route.
        ///This value includes the cumulative fees at each hop. As a result, the HTLC
        ///extended to the first-hop in the route will need to have at least this many
        ///satoshis, otherwise the route will fail at an intermediate node due to an
        ///insufficient amount of fees.
        @available(*, deprecated:0.1, message:"totalAmt is marked as \"Deprecated\"")
        public fileprivate(set) var totalAmt:Int64! = nil
        public fileprivate(set) var hasTotalAmt:Bool = false

        public fileprivate(set) var hops:Array<Lnrpc.Hop>  = Array<Lnrpc.Hop>()
        ///*
        ///The total fees in millisatoshis.
        public fileprivate(set) var totalFeesMsat:Int64! = nil
        public fileprivate(set) var hasTotalFeesMsat:Bool = false

        ///*
        ///The total amount in millisatoshis.
        public fileprivate(set) var totalAmtMsat:Int64! = nil
        public fileprivate(set) var hasTotalAmtMsat:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTotalTimeLock {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:totalTimeLock)
            }
            if hasTotalFees {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:totalFees)
            }
            if hasTotalAmt {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:totalAmt)
            }
            for oneElementHops in hops {
                  try codedOutputStream.writeMessage(fieldNumber: 4, value:oneElementHops)
            }
            if hasTotalFeesMsat {
                try codedOutputStream.writeInt64(fieldNumber: 5, value:totalFeesMsat)
            }
            if hasTotalAmtMsat {
                try codedOutputStream.writeInt64(fieldNumber: 6, value:totalAmtMsat)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTotalTimeLock {
                serialize_size += totalTimeLock.computeUInt32Size(fieldNumber: 1)
            }
            if hasTotalFees {
                serialize_size += totalFees.computeInt64Size(fieldNumber: 2)
            }
            if hasTotalAmt {
                serialize_size += totalAmt.computeInt64Size(fieldNumber: 3)
            }
            for oneElementHops in hops {
                serialize_size += oneElementHops.computeMessageSize(fieldNumber: 4)
            }
            if hasTotalFeesMsat {
                serialize_size += totalFeesMsat.computeInt64Size(fieldNumber: 5)
            }
            if hasTotalAmtMsat {
                serialize_size += totalAmtMsat.computeInt64Size(fieldNumber: 6)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.Route.Builder {
            return Lnrpc.Route.classBuilder() as! Lnrpc.Route.Builder
        }
        public func getBuilder() -> Lnrpc.Route.Builder {
            return classBuilder() as! Lnrpc.Route.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.Route.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.Route.Builder()
        }
        public func toBuilder() throws -> Lnrpc.Route.Builder {
            return try Lnrpc.Route.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.Route) throws -> Lnrpc.Route.Builder {
            return try Lnrpc.Route.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTotalTimeLock {
                jsonMap["total_time_lock"] = UInt(totalTimeLock)
            }
            if hasTotalFees {
                jsonMap["total_fees"] = "\(totalFees!)"
            }
            if hasTotalAmt {
                jsonMap["total_amt"] = "\(totalAmt!)"
            }
            if !hops.isEmpty {
                var jsonArrayHops:Array<Dictionary<String,Any>> = []
                for oneValueHops in hops {
                    let ecodedMessageHops = try oneValueHops.encode()
                    jsonArrayHops.append(ecodedMessageHops)
                }
                jsonMap["hops"] = jsonArrayHops
            }
            if hasTotalFeesMsat {
                jsonMap["total_fees_msat"] = "\(totalFeesMsat!)"
            }
            if hasTotalAmtMsat {
                jsonMap["total_amt_msat"] = "\(totalAmtMsat!)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.Route {
            return try Lnrpc.Route.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.Route {
            return try Lnrpc.Route.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTotalTimeLock {
                output += "\(indent) totalTimeLock: \(totalTimeLock) \n"
            }
            if hasTotalFees {
                output += "\(indent) totalFees: \(totalFees) \n"
            }
            if hasTotalAmt {
                output += "\(indent) totalAmt: \(totalAmt) \n"
            }
            var hopsElementIndex:Int = 0
            for oneElementHops in hops {
                output += "\(indent) hops[\(hopsElementIndex)] {\n"
                output += try oneElementHops.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                hopsElementIndex += 1
            }
            if hasTotalFeesMsat {
                output += "\(indent) totalFeesMsat: \(totalFeesMsat) \n"
            }
            if hasTotalAmtMsat {
                output += "\(indent) totalAmtMsat: \(totalAmtMsat) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTotalTimeLock {
                    hashCode = (hashCode &* 31) &+ totalTimeLock.hashValue
                }
                if hasTotalFees {
                    hashCode = (hashCode &* 31) &+ totalFees.hashValue
                }
                if hasTotalAmt {
                    hashCode = (hashCode &* 31) &+ totalAmt.hashValue
                }
                for oneElementHops in hops {
                    hashCode = (hashCode &* 31) &+ oneElementHops.hashValue
                }
                if hasTotalFeesMsat {
                    hashCode = (hashCode &* 31) &+ totalFeesMsat.hashValue
                }
                if hasTotalAmtMsat {
                    hashCode = (hashCode &* 31) &+ totalAmtMsat.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.Route"
        }
        override public func className() -> String {
            return "Lnrpc.Route"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.Route = Lnrpc.Route()
            public func getMessage() -> Lnrpc.Route {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///*
            ///The cumulative (final) time lock across the entire route.  This is the CLTV
            ///value that should be extended to the first hop in the route. All other hops
            ///will decrement the time-lock as advertised, leaving enough time for all
            ///hops to wait for or present the payment preimage to complete the payment.
            public var totalTimeLock:UInt32 {
                get {
                    return builderResult.totalTimeLock
                }
                set (value) {
                    builderResult.hasTotalTimeLock = true
                    builderResult.totalTimeLock = value
                }
            }
            public var hasTotalTimeLock:Bool {
                get {
                    return builderResult.hasTotalTimeLock
                }
            }
            @discardableResult
            public func setTotalTimeLock(_ value:UInt32) -> Lnrpc.Route.Builder {
                self.totalTimeLock = value
                return self
            }
            @discardableResult
            public func clearTotalTimeLock() -> Lnrpc.Route.Builder{
                builderResult.hasTotalTimeLock = false
                builderResult.totalTimeLock = nil
                return self
            }
            ///*
            ///The sum of the fees paid at each hop within the final route.  In the case
            ///of a one-hop payment, this value will be zero as we don't need to pay a fee
            ///it ourself.
            public var totalFees:Int64 {
                get {
                    return builderResult.totalFees
                }
                set (value) {
                    builderResult.hasTotalFees = true
                    builderResult.totalFees = value
                }
            }
            public var hasTotalFees:Bool {
                get {
                    return builderResult.hasTotalFees
                }
            }
            @discardableResult
            public func setTotalFees(_ value:Int64) -> Lnrpc.Route.Builder {
                self.totalFees = value
                return self
            }
            @discardableResult
            public func clearTotalFees() -> Lnrpc.Route.Builder{
                builderResult.hasTotalFees = false
                builderResult.totalFees = nil
                return self
            }
            ///*
            ///The total amount of funds required to complete a payment over this route.
            ///This value includes the cumulative fees at each hop. As a result, the HTLC
            ///extended to the first-hop in the route will need to have at least this many
            ///satoshis, otherwise the route will fail at an intermediate node due to an
            ///insufficient amount of fees.
            public var totalAmt:Int64 {
                get {
                    return builderResult.totalAmt
                }
                set (value) {
                    builderResult.hasTotalAmt = true
                    builderResult.totalAmt = value
                }
            }
            public var hasTotalAmt:Bool {
                get {
                    return builderResult.hasTotalAmt
                }
            }
            @discardableResult
            public func setTotalAmt(_ value:Int64) -> Lnrpc.Route.Builder {
                self.totalAmt = value
                return self
            }
            @discardableResult
            public func clearTotalAmt() -> Lnrpc.Route.Builder{
                builderResult.hasTotalAmt = false
                builderResult.totalAmt = nil
                return self
            }
            ///*
            ///Contains details concerning the specific forwarding details at each hop.
            public var hops:Array<Lnrpc.Hop> {
                get {
                    return builderResult.hops
                }
                set (value) {
                    builderResult.hops = value
                }
            }
            @discardableResult
            public func setHops(_ value:Array<Lnrpc.Hop>) -> Lnrpc.Route.Builder {
                self.hops = value
                return self
            }
            @discardableResult
            public func clearHops() -> Lnrpc.Route.Builder {
                builderResult.hops.removeAll(keepingCapacity: false)
                return self
            }
            ///*
            ///The total fees in millisatoshis.
            public var totalFeesMsat:Int64 {
                get {
                    return builderResult.totalFeesMsat
                }
                set (value) {
                    builderResult.hasTotalFeesMsat = true
                    builderResult.totalFeesMsat = value
                }
            }
            public var hasTotalFeesMsat:Bool {
                get {
                    return builderResult.hasTotalFeesMsat
                }
            }
            @discardableResult
            public func setTotalFeesMsat(_ value:Int64) -> Lnrpc.Route.Builder {
                self.totalFeesMsat = value
                return self
            }
            @discardableResult
            public func clearTotalFeesMsat() -> Lnrpc.Route.Builder{
                builderResult.hasTotalFeesMsat = false
                builderResult.totalFeesMsat = nil
                return self
            }
            ///*
            ///The total amount in millisatoshis.
            public var totalAmtMsat:Int64 {
                get {
                    return builderResult.totalAmtMsat
                }
                set (value) {
                    builderResult.hasTotalAmtMsat = true
                    builderResult.totalAmtMsat = value
                }
            }
            public var hasTotalAmtMsat:Bool {
                get {
                    return builderResult.hasTotalAmtMsat
                }
            }
            @discardableResult
            public func setTotalAmtMsat(_ value:Int64) -> Lnrpc.Route.Builder {
                self.totalAmtMsat = value
                return self
            }
            @discardableResult
            public func clearTotalAmtMsat() -> Lnrpc.Route.Builder{
                builderResult.hasTotalAmtMsat = false
                builderResult.totalAmtMsat = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.Route.Builder {
                builderResult = Lnrpc.Route()
                return self
            }
            override public func clone() throws -> Lnrpc.Route.Builder {
                return try Lnrpc.Route.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.Route {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.Route {
                let returnMe:Lnrpc.Route = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.Route) throws -> Lnrpc.Route.Builder {
                if other == Lnrpc.Route() {
                    return self
                }
                if other.hasTotalTimeLock {
                    totalTimeLock = other.totalTimeLock
                }
                if other.hasTotalFees {
                    totalFees = other.totalFees
                }
                if other.hasTotalAmt {
                    totalAmt = other.totalAmt
                }
                if !other.hops.isEmpty  {
                     builderResult.hops += other.hops
                }
                if other.hasTotalFeesMsat {
                    totalFeesMsat = other.totalFeesMsat
                }
                if other.hasTotalAmtMsat {
                    totalAmtMsat = other.totalAmtMsat
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.Route.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Route.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        totalTimeLock = try codedInputStream.readUInt32()

                    case 16:
                        totalFees = try codedInputStream.readInt64()

                    case 24:
                        totalAmt = try codedInputStream.readInt64()

                    case 34:
                        let subBuilder = Lnrpc.Hop.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        hops.append(subBuilder.buildPartial())

                    case 40:
                        totalFeesMsat = try codedInputStream.readInt64()

                    case 48:
                        totalAmtMsat = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.Route.Builder {
                let resultDecodedBuilder = Lnrpc.Route.Builder()
                if let jsonValueTotalTimeLock = jsonMap["total_time_lock"] as? UInt {
                    resultDecodedBuilder.totalTimeLock = UInt32(jsonValueTotalTimeLock)
                } else if let jsonValueTotalTimeLock = jsonMap["total_time_lock"] as? String {
                    resultDecodedBuilder.totalTimeLock = UInt32(jsonValueTotalTimeLock)!
                }
                if let jsonValueTotalFees = jsonMap["total_fees"] as? String {
                    resultDecodedBuilder.totalFees = Int64(jsonValueTotalFees)!
                } else if let jsonValueTotalFees = jsonMap["total_fees"] as? Int {
                    resultDecodedBuilder.totalFees = Int64(jsonValueTotalFees)
                }
                if let jsonValueTotalAmt = jsonMap["total_amt"] as? String {
                    resultDecodedBuilder.totalAmt = Int64(jsonValueTotalAmt)!
                } else if let jsonValueTotalAmt = jsonMap["total_amt"] as? Int {
                    resultDecodedBuilder.totalAmt = Int64(jsonValueTotalAmt)
                }
                if let jsonValueHops = jsonMap["hops"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayHops:Array<Lnrpc.Hop> = []
                    for oneValueHops in jsonValueHops {
                        let messageFromStringHops = try Lnrpc.Hop.Builder.decodeToBuilder(jsonMap:oneValueHops).build()

                        jsonArrayHops.append(messageFromStringHops)
                    }
                    resultDecodedBuilder.hops = jsonArrayHops
                }
                if let jsonValueTotalFeesMsat = jsonMap["total_fees_msat"] as? String {
                    resultDecodedBuilder.totalFeesMsat = Int64(jsonValueTotalFeesMsat)!
                } else if let jsonValueTotalFeesMsat = jsonMap["total_fees_msat"] as? Int {
                    resultDecodedBuilder.totalFeesMsat = Int64(jsonValueTotalFeesMsat)
                }
                if let jsonValueTotalAmtMsat = jsonMap["total_amt_msat"] as? String {
                    resultDecodedBuilder.totalAmtMsat = Int64(jsonValueTotalAmtMsat)!
                } else if let jsonValueTotalAmtMsat = jsonMap["total_amt_msat"] as? Int {
                    resultDecodedBuilder.totalAmtMsat = Int64(jsonValueTotalAmtMsat)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.Route.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.Route.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class NodeInfoRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.NodeInfoRequest.Builder

        public static func == (lhs: Lnrpc.NodeInfoRequest, rhs: Lnrpc.NodeInfoRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasPubKey == rhs.hasPubKey) && (!lhs.hasPubKey || lhs.pubKey == rhs.pubKey)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// The 33-byte hex-encoded compressed public of the target node 
        public fileprivate(set) var pubKey:String! = nil
        public fileprivate(set) var hasPubKey:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasPubKey {
                try codedOutputStream.writeString(fieldNumber: 1, value:pubKey)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasPubKey {
                serialize_size += pubKey.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.NodeInfoRequest.Builder {
            return Lnrpc.NodeInfoRequest.classBuilder() as! Lnrpc.NodeInfoRequest.Builder
        }
        public func getBuilder() -> Lnrpc.NodeInfoRequest.Builder {
            return classBuilder() as! Lnrpc.NodeInfoRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.NodeInfoRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.NodeInfoRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.NodeInfoRequest.Builder {
            return try Lnrpc.NodeInfoRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.NodeInfoRequest) throws -> Lnrpc.NodeInfoRequest.Builder {
            return try Lnrpc.NodeInfoRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasPubKey {
                jsonMap["pubKey"] = pubKey
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.NodeInfoRequest {
            return try Lnrpc.NodeInfoRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.NodeInfoRequest {
            return try Lnrpc.NodeInfoRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasPubKey {
                output += "\(indent) pubKey: \(pubKey) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasPubKey {
                    hashCode = (hashCode &* 31) &+ pubKey.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.NodeInfoRequest"
        }
        override public func className() -> String {
            return "Lnrpc.NodeInfoRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.NodeInfoRequest = Lnrpc.NodeInfoRequest()
            public func getMessage() -> Lnrpc.NodeInfoRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The 33-byte hex-encoded compressed public of the target node 
            public var pubKey:String {
                get {
                    return builderResult.pubKey
                }
                set (value) {
                    builderResult.hasPubKey = true
                    builderResult.pubKey = value
                }
            }
            public var hasPubKey:Bool {
                get {
                    return builderResult.hasPubKey
                }
            }
            @discardableResult
            public func setPubKey(_ value:String) -> Lnrpc.NodeInfoRequest.Builder {
                self.pubKey = value
                return self
            }
            @discardableResult
            public func clearPubKey() -> Lnrpc.NodeInfoRequest.Builder{
                builderResult.hasPubKey = false
                builderResult.pubKey = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.NodeInfoRequest.Builder {
                builderResult = Lnrpc.NodeInfoRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.NodeInfoRequest.Builder {
                return try Lnrpc.NodeInfoRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.NodeInfoRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.NodeInfoRequest {
                let returnMe:Lnrpc.NodeInfoRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.NodeInfoRequest) throws -> Lnrpc.NodeInfoRequest.Builder {
                if other == Lnrpc.NodeInfoRequest() {
                    return self
                }
                if other.hasPubKey {
                    pubKey = other.pubKey
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.NodeInfoRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NodeInfoRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        pubKey = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.NodeInfoRequest.Builder {
                let resultDecodedBuilder = Lnrpc.NodeInfoRequest.Builder()
                if let jsonValuePubKey = jsonMap["pubKey"] as? String {
                    resultDecodedBuilder.pubKey = jsonValuePubKey
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.NodeInfoRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.NodeInfoRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class NodeInfo : GeneratedMessage {
        public typealias BuilderType = Lnrpc.NodeInfo.Builder

        public static func == (lhs: Lnrpc.NodeInfo, rhs: Lnrpc.NodeInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasNode == rhs.hasNode) && (!lhs.hasNode || lhs.node == rhs.node)
            fieldCheck = fieldCheck && (lhs.hasNumChannels == rhs.hasNumChannels) && (!lhs.hasNumChannels || lhs.numChannels == rhs.numChannels)
            fieldCheck = fieldCheck && (lhs.hasTotalCapacity == rhs.hasTotalCapacity) && (!lhs.hasTotalCapacity || lhs.totalCapacity == rhs.totalCapacity)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var node:Lnrpc.LightningNode!
        public fileprivate(set) var hasNode:Bool = false
        public fileprivate(set) var numChannels:UInt32! = nil
        public fileprivate(set) var hasNumChannels:Bool = false

        public fileprivate(set) var totalCapacity:Int64! = nil
        public fileprivate(set) var hasTotalCapacity:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasNode {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:node)
            }
            if hasNumChannels {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:numChannels)
            }
            if hasTotalCapacity {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:totalCapacity)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasNode {
                if let varSizenode = node?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizenode
                }
            }
            if hasNumChannels {
                serialize_size += numChannels.computeUInt32Size(fieldNumber: 2)
            }
            if hasTotalCapacity {
                serialize_size += totalCapacity.computeInt64Size(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.NodeInfo.Builder {
            return Lnrpc.NodeInfo.classBuilder() as! Lnrpc.NodeInfo.Builder
        }
        public func getBuilder() -> Lnrpc.NodeInfo.Builder {
            return classBuilder() as! Lnrpc.NodeInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.NodeInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.NodeInfo.Builder()
        }
        public func toBuilder() throws -> Lnrpc.NodeInfo.Builder {
            return try Lnrpc.NodeInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.NodeInfo) throws -> Lnrpc.NodeInfo.Builder {
            return try Lnrpc.NodeInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasNode {
                jsonMap["node"] = try node.encode()
            }
            if hasNumChannels {
                jsonMap["num_channels"] = UInt(numChannels)
            }
            if hasTotalCapacity {
                jsonMap["total_capacity"] = "\(totalCapacity!)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.NodeInfo {
            return try Lnrpc.NodeInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.NodeInfo {
            return try Lnrpc.NodeInfo.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasNode {
                output += "\(indent) node {\n"
                if let outDescNode = node {
                    output += try outDescNode.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasNumChannels {
                output += "\(indent) numChannels: \(numChannels) \n"
            }
            if hasTotalCapacity {
                output += "\(indent) totalCapacity: \(totalCapacity) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasNode {
                    if let hashValuenode = node?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuenode
                    }
                }
                if hasNumChannels {
                    hashCode = (hashCode &* 31) &+ numChannels.hashValue
                }
                if hasTotalCapacity {
                    hashCode = (hashCode &* 31) &+ totalCapacity.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.NodeInfo"
        }
        override public func className() -> String {
            return "Lnrpc.NodeInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.NodeInfo = Lnrpc.NodeInfo()
            public func getMessage() -> Lnrpc.NodeInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///*
            ///An individual vertex/node within the channel graph. A node is
            ///connected to other nodes by one or more channel edges emanating from it. As
            ///the graph is directed, a node will also have an incoming edge attached to
            ///it for each outgoing edge.
            public var node:Lnrpc.LightningNode! {
                get {
                    if nodeBuilder_ != nil {
                        builderResult.node = nodeBuilder_.getMessage()
                    }
                    return builderResult.node
                }
                set (value) {
                    builderResult.hasNode = value != nil
                    builderResult.node = value
                }
            }
            public var hasNode:Bool {
                get {
                    return builderResult.hasNode
                }
            }
            fileprivate var nodeBuilder_:Lnrpc.LightningNode.Builder! {
                didSet {
                    builderResult.hasNode = true
                }
            }
            public func getNodeBuilder() -> Lnrpc.LightningNode.Builder {
                if nodeBuilder_ == nil {
                    nodeBuilder_ = Lnrpc.LightningNode.Builder()
                    builderResult.node = nodeBuilder_.getMessage()
                    if node != nil {
                        try! nodeBuilder_.mergeFrom(other: node)
                    }
                }
                return nodeBuilder_
            }
            @discardableResult
            public func setNode(_ value:Lnrpc.LightningNode!) -> Lnrpc.NodeInfo.Builder {
                self.node = value
                return self
            }
            @discardableResult
            public func mergeNode(value:Lnrpc.LightningNode) throws -> Lnrpc.NodeInfo.Builder {
                if builderResult.hasNode {
                    builderResult.node = try Lnrpc.LightningNode.builderWithPrototype(prototype:builderResult.node).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.node = value
                }
                builderResult.hasNode = true
                return self
            }
            @discardableResult
            public func clearNode() -> Lnrpc.NodeInfo.Builder {
                nodeBuilder_ = nil
                builderResult.hasNode = false
                builderResult.node = nil
                return self
            }
            public var numChannels:UInt32 {
                get {
                    return builderResult.numChannels
                }
                set (value) {
                    builderResult.hasNumChannels = true
                    builderResult.numChannels = value
                }
            }
            public var hasNumChannels:Bool {
                get {
                    return builderResult.hasNumChannels
                }
            }
            @discardableResult
            public func setNumChannels(_ value:UInt32) -> Lnrpc.NodeInfo.Builder {
                self.numChannels = value
                return self
            }
            @discardableResult
            public func clearNumChannels() -> Lnrpc.NodeInfo.Builder{
                builderResult.hasNumChannels = false
                builderResult.numChannels = nil
                return self
            }
            public var totalCapacity:Int64 {
                get {
                    return builderResult.totalCapacity
                }
                set (value) {
                    builderResult.hasTotalCapacity = true
                    builderResult.totalCapacity = value
                }
            }
            public var hasTotalCapacity:Bool {
                get {
                    return builderResult.hasTotalCapacity
                }
            }
            @discardableResult
            public func setTotalCapacity(_ value:Int64) -> Lnrpc.NodeInfo.Builder {
                self.totalCapacity = value
                return self
            }
            @discardableResult
            public func clearTotalCapacity() -> Lnrpc.NodeInfo.Builder{
                builderResult.hasTotalCapacity = false
                builderResult.totalCapacity = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.NodeInfo.Builder {
                builderResult = Lnrpc.NodeInfo()
                return self
            }
            override public func clone() throws -> Lnrpc.NodeInfo.Builder {
                return try Lnrpc.NodeInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.NodeInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.NodeInfo {
                let returnMe:Lnrpc.NodeInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.NodeInfo) throws -> Lnrpc.NodeInfo.Builder {
                if other == Lnrpc.NodeInfo() {
                    return self
                }
                if (other.hasNode) {
                    try mergeNode(value: other.node)
                }
                if other.hasNumChannels {
                    numChannels = other.numChannels
                }
                if other.hasTotalCapacity {
                    totalCapacity = other.totalCapacity
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.NodeInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NodeInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Lnrpc.LightningNode.Builder = Lnrpc.LightningNode.Builder()
                        if hasNode {
                            try subBuilder.mergeFrom(other: node)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        node = subBuilder.buildPartial()

                    case 16:
                        numChannels = try codedInputStream.readUInt32()

                    case 24:
                        totalCapacity = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.NodeInfo.Builder {
                let resultDecodedBuilder = Lnrpc.NodeInfo.Builder()
                if let jsonValueNode = jsonMap["node"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.node = try Lnrpc.LightningNode.Builder.decodeToBuilder(jsonMap:jsonValueNode).build()

                }
                if let jsonValueNumChannels = jsonMap["num_channels"] as? UInt {
                    resultDecodedBuilder.numChannels = UInt32(jsonValueNumChannels)
                } else if let jsonValueNumChannels = jsonMap["num_channels"] as? String {
                    resultDecodedBuilder.numChannels = UInt32(jsonValueNumChannels)!
                }
                if let jsonValueTotalCapacity = jsonMap["total_capacity"] as? String {
                    resultDecodedBuilder.totalCapacity = Int64(jsonValueTotalCapacity)!
                } else if let jsonValueTotalCapacity = jsonMap["total_capacity"] as? Int {
                    resultDecodedBuilder.totalCapacity = Int64(jsonValueTotalCapacity)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.NodeInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.NodeInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    ///*
    ///An individual vertex/node within the channel graph. A node is
    ///connected to other nodes by one or more channel edges emanating from it. As the
    ///graph is directed, a node will also have an incoming edge attached to it for
    ///each outgoing edge.
    final public class LightningNode : GeneratedMessage {
        public typealias BuilderType = Lnrpc.LightningNode.Builder

        public static func == (lhs: Lnrpc.LightningNode, rhs: Lnrpc.LightningNode) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasLastUpdate == rhs.hasLastUpdate) && (!lhs.hasLastUpdate || lhs.lastUpdate == rhs.lastUpdate)
            fieldCheck = fieldCheck && (lhs.hasPubKey == rhs.hasPubKey) && (!lhs.hasPubKey || lhs.pubKey == rhs.pubKey)
            fieldCheck = fieldCheck && (lhs.hasAlias == rhs.hasAlias) && (!lhs.hasAlias || lhs.alias == rhs.alias)
            fieldCheck = fieldCheck && (lhs.addresses == rhs.addresses)
            fieldCheck = fieldCheck && (lhs.hasColor == rhs.hasColor) && (!lhs.hasColor || lhs.color == rhs.color)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var lastUpdate:UInt32! = nil
        public fileprivate(set) var hasLastUpdate:Bool = false

        public fileprivate(set) var pubKey:String! = nil
        public fileprivate(set) var hasPubKey:Bool = false

        public fileprivate(set) var alias:String! = nil
        public fileprivate(set) var hasAlias:Bool = false

        public fileprivate(set) var addresses:Array<Lnrpc.NodeAddress>  = Array<Lnrpc.NodeAddress>()
        public fileprivate(set) var color:String! = nil
        public fileprivate(set) var hasColor:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasLastUpdate {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:lastUpdate)
            }
            if hasPubKey {
                try codedOutputStream.writeString(fieldNumber: 2, value:pubKey)
            }
            if hasAlias {
                try codedOutputStream.writeString(fieldNumber: 3, value:alias)
            }
            for oneElementAddresses in addresses {
                  try codedOutputStream.writeMessage(fieldNumber: 4, value:oneElementAddresses)
            }
            if hasColor {
                try codedOutputStream.writeString(fieldNumber: 5, value:color)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasLastUpdate {
                serialize_size += lastUpdate.computeUInt32Size(fieldNumber: 1)
            }
            if hasPubKey {
                serialize_size += pubKey.computeStringSize(fieldNumber: 2)
            }
            if hasAlias {
                serialize_size += alias.computeStringSize(fieldNumber: 3)
            }
            for oneElementAddresses in addresses {
                serialize_size += oneElementAddresses.computeMessageSize(fieldNumber: 4)
            }
            if hasColor {
                serialize_size += color.computeStringSize(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.LightningNode.Builder {
            return Lnrpc.LightningNode.classBuilder() as! Lnrpc.LightningNode.Builder
        }
        public func getBuilder() -> Lnrpc.LightningNode.Builder {
            return classBuilder() as! Lnrpc.LightningNode.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.LightningNode.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.LightningNode.Builder()
        }
        public func toBuilder() throws -> Lnrpc.LightningNode.Builder {
            return try Lnrpc.LightningNode.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.LightningNode) throws -> Lnrpc.LightningNode.Builder {
            return try Lnrpc.LightningNode.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasLastUpdate {
                jsonMap["last_update"] = UInt(lastUpdate)
            }
            if hasPubKey {
                jsonMap["pub_key"] = pubKey
            }
            if hasAlias {
                jsonMap["alias"] = alias
            }
            if !addresses.isEmpty {
                var jsonArrayAddresses:Array<Dictionary<String,Any>> = []
                for oneValueAddresses in addresses {
                    let ecodedMessageAddresses = try oneValueAddresses.encode()
                    jsonArrayAddresses.append(ecodedMessageAddresses)
                }
                jsonMap["addresses"] = jsonArrayAddresses
            }
            if hasColor {
                jsonMap["color"] = color
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.LightningNode {
            return try Lnrpc.LightningNode.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.LightningNode {
            return try Lnrpc.LightningNode.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasLastUpdate {
                output += "\(indent) lastUpdate: \(lastUpdate) \n"
            }
            if hasPubKey {
                output += "\(indent) pubKey: \(pubKey) \n"
            }
            if hasAlias {
                output += "\(indent) alias: \(alias) \n"
            }
            var addressesElementIndex:Int = 0
            for oneElementAddresses in addresses {
                output += "\(indent) addresses[\(addressesElementIndex)] {\n"
                output += try oneElementAddresses.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                addressesElementIndex += 1
            }
            if hasColor {
                output += "\(indent) color: \(color) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasLastUpdate {
                    hashCode = (hashCode &* 31) &+ lastUpdate.hashValue
                }
                if hasPubKey {
                    hashCode = (hashCode &* 31) &+ pubKey.hashValue
                }
                if hasAlias {
                    hashCode = (hashCode &* 31) &+ alias.hashValue
                }
                for oneElementAddresses in addresses {
                    hashCode = (hashCode &* 31) &+ oneElementAddresses.hashValue
                }
                if hasColor {
                    hashCode = (hashCode &* 31) &+ color.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.LightningNode"
        }
        override public func className() -> String {
            return "Lnrpc.LightningNode"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.LightningNode = Lnrpc.LightningNode()
            public func getMessage() -> Lnrpc.LightningNode {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var lastUpdate:UInt32 {
                get {
                    return builderResult.lastUpdate
                }
                set (value) {
                    builderResult.hasLastUpdate = true
                    builderResult.lastUpdate = value
                }
            }
            public var hasLastUpdate:Bool {
                get {
                    return builderResult.hasLastUpdate
                }
            }
            @discardableResult
            public func setLastUpdate(_ value:UInt32) -> Lnrpc.LightningNode.Builder {
                self.lastUpdate = value
                return self
            }
            @discardableResult
            public func clearLastUpdate() -> Lnrpc.LightningNode.Builder{
                builderResult.hasLastUpdate = false
                builderResult.lastUpdate = nil
                return self
            }
            public var pubKey:String {
                get {
                    return builderResult.pubKey
                }
                set (value) {
                    builderResult.hasPubKey = true
                    builderResult.pubKey = value
                }
            }
            public var hasPubKey:Bool {
                get {
                    return builderResult.hasPubKey
                }
            }
            @discardableResult
            public func setPubKey(_ value:String) -> Lnrpc.LightningNode.Builder {
                self.pubKey = value
                return self
            }
            @discardableResult
            public func clearPubKey() -> Lnrpc.LightningNode.Builder{
                builderResult.hasPubKey = false
                builderResult.pubKey = nil
                return self
            }
            public var alias:String {
                get {
                    return builderResult.alias
                }
                set (value) {
                    builderResult.hasAlias = true
                    builderResult.alias = value
                }
            }
            public var hasAlias:Bool {
                get {
                    return builderResult.hasAlias
                }
            }
            @discardableResult
            public func setAlias(_ value:String) -> Lnrpc.LightningNode.Builder {
                self.alias = value
                return self
            }
            @discardableResult
            public func clearAlias() -> Lnrpc.LightningNode.Builder{
                builderResult.hasAlias = false
                builderResult.alias = nil
                return self
            }
            public var addresses:Array<Lnrpc.NodeAddress> {
                get {
                    return builderResult.addresses
                }
                set (value) {
                    builderResult.addresses = value
                }
            }
            @discardableResult
            public func setAddresses(_ value:Array<Lnrpc.NodeAddress>) -> Lnrpc.LightningNode.Builder {
                self.addresses = value
                return self
            }
            @discardableResult
            public func clearAddresses() -> Lnrpc.LightningNode.Builder {
                builderResult.addresses.removeAll(keepingCapacity: false)
                return self
            }
            public var color:String {
                get {
                    return builderResult.color
                }
                set (value) {
                    builderResult.hasColor = true
                    builderResult.color = value
                }
            }
            public var hasColor:Bool {
                get {
                    return builderResult.hasColor
                }
            }
            @discardableResult
            public func setColor(_ value:String) -> Lnrpc.LightningNode.Builder {
                self.color = value
                return self
            }
            @discardableResult
            public func clearColor() -> Lnrpc.LightningNode.Builder{
                builderResult.hasColor = false
                builderResult.color = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.LightningNode.Builder {
                builderResult = Lnrpc.LightningNode()
                return self
            }
            override public func clone() throws -> Lnrpc.LightningNode.Builder {
                return try Lnrpc.LightningNode.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.LightningNode {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.LightningNode {
                let returnMe:Lnrpc.LightningNode = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.LightningNode) throws -> Lnrpc.LightningNode.Builder {
                if other == Lnrpc.LightningNode() {
                    return self
                }
                if other.hasLastUpdate {
                    lastUpdate = other.lastUpdate
                }
                if other.hasPubKey {
                    pubKey = other.pubKey
                }
                if other.hasAlias {
                    alias = other.alias
                }
                if !other.addresses.isEmpty  {
                     builderResult.addresses += other.addresses
                }
                if other.hasColor {
                    color = other.color
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.LightningNode.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.LightningNode.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        lastUpdate = try codedInputStream.readUInt32()

                    case 18:
                        pubKey = try codedInputStream.readString()

                    case 26:
                        alias = try codedInputStream.readString()

                    case 34:
                        let subBuilder = Lnrpc.NodeAddress.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        addresses.append(subBuilder.buildPartial())

                    case 42:
                        color = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.LightningNode.Builder {
                let resultDecodedBuilder = Lnrpc.LightningNode.Builder()
                if let jsonValueLastUpdate = jsonMap["last_update"] as? UInt {
                    resultDecodedBuilder.lastUpdate = UInt32(jsonValueLastUpdate)
                } else if let jsonValueLastUpdate = jsonMap["last_update"] as? String {
                    resultDecodedBuilder.lastUpdate = UInt32(jsonValueLastUpdate)!
                }
                if let jsonValuePubKey = jsonMap["pub_key"] as? String {
                    resultDecodedBuilder.pubKey = jsonValuePubKey
                }
                if let jsonValueAlias = jsonMap["alias"] as? String {
                    resultDecodedBuilder.alias = jsonValueAlias
                }
                if let jsonValueAddresses = jsonMap["addresses"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayAddresses:Array<Lnrpc.NodeAddress> = []
                    for oneValueAddresses in jsonValueAddresses {
                        let messageFromStringAddresses = try Lnrpc.NodeAddress.Builder.decodeToBuilder(jsonMap:oneValueAddresses).build()

                        jsonArrayAddresses.append(messageFromStringAddresses)
                    }
                    resultDecodedBuilder.addresses = jsonArrayAddresses
                }
                if let jsonValueColor = jsonMap["color"] as? String {
                    resultDecodedBuilder.color = jsonValueColor
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.LightningNode.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.LightningNode.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class NodeAddress : GeneratedMessage {
        public typealias BuilderType = Lnrpc.NodeAddress.Builder

        public static func == (lhs: Lnrpc.NodeAddress, rhs: Lnrpc.NodeAddress) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasNetwork == rhs.hasNetwork) && (!lhs.hasNetwork || lhs.network == rhs.network)
            fieldCheck = fieldCheck && (lhs.hasAddr == rhs.hasAddr) && (!lhs.hasAddr || lhs.addr == rhs.addr)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var network:String! = nil
        public fileprivate(set) var hasNetwork:Bool = false

        public fileprivate(set) var addr:String! = nil
        public fileprivate(set) var hasAddr:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasNetwork {
                try codedOutputStream.writeString(fieldNumber: 1, value:network)
            }
            if hasAddr {
                try codedOutputStream.writeString(fieldNumber: 2, value:addr)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasNetwork {
                serialize_size += network.computeStringSize(fieldNumber: 1)
            }
            if hasAddr {
                serialize_size += addr.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.NodeAddress.Builder {
            return Lnrpc.NodeAddress.classBuilder() as! Lnrpc.NodeAddress.Builder
        }
        public func getBuilder() -> Lnrpc.NodeAddress.Builder {
            return classBuilder() as! Lnrpc.NodeAddress.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.NodeAddress.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.NodeAddress.Builder()
        }
        public func toBuilder() throws -> Lnrpc.NodeAddress.Builder {
            return try Lnrpc.NodeAddress.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.NodeAddress) throws -> Lnrpc.NodeAddress.Builder {
            return try Lnrpc.NodeAddress.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasNetwork {
                jsonMap["network"] = network
            }
            if hasAddr {
                jsonMap["addr"] = addr
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.NodeAddress {
            return try Lnrpc.NodeAddress.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.NodeAddress {
            return try Lnrpc.NodeAddress.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasNetwork {
                output += "\(indent) network: \(network) \n"
            }
            if hasAddr {
                output += "\(indent) addr: \(addr) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasNetwork {
                    hashCode = (hashCode &* 31) &+ network.hashValue
                }
                if hasAddr {
                    hashCode = (hashCode &* 31) &+ addr.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.NodeAddress"
        }
        override public func className() -> String {
            return "Lnrpc.NodeAddress"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.NodeAddress = Lnrpc.NodeAddress()
            public func getMessage() -> Lnrpc.NodeAddress {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var network:String {
                get {
                    return builderResult.network
                }
                set (value) {
                    builderResult.hasNetwork = true
                    builderResult.network = value
                }
            }
            public var hasNetwork:Bool {
                get {
                    return builderResult.hasNetwork
                }
            }
            @discardableResult
            public func setNetwork(_ value:String) -> Lnrpc.NodeAddress.Builder {
                self.network = value
                return self
            }
            @discardableResult
            public func clearNetwork() -> Lnrpc.NodeAddress.Builder{
                builderResult.hasNetwork = false
                builderResult.network = nil
                return self
            }
            public var addr:String {
                get {
                    return builderResult.addr
                }
                set (value) {
                    builderResult.hasAddr = true
                    builderResult.addr = value
                }
            }
            public var hasAddr:Bool {
                get {
                    return builderResult.hasAddr
                }
            }
            @discardableResult
            public func setAddr(_ value:String) -> Lnrpc.NodeAddress.Builder {
                self.addr = value
                return self
            }
            @discardableResult
            public func clearAddr() -> Lnrpc.NodeAddress.Builder{
                builderResult.hasAddr = false
                builderResult.addr = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.NodeAddress.Builder {
                builderResult = Lnrpc.NodeAddress()
                return self
            }
            override public func clone() throws -> Lnrpc.NodeAddress.Builder {
                return try Lnrpc.NodeAddress.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.NodeAddress {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.NodeAddress {
                let returnMe:Lnrpc.NodeAddress = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.NodeAddress) throws -> Lnrpc.NodeAddress.Builder {
                if other == Lnrpc.NodeAddress() {
                    return self
                }
                if other.hasNetwork {
                    network = other.network
                }
                if other.hasAddr {
                    addr = other.addr
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.NodeAddress.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NodeAddress.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        network = try codedInputStream.readString()

                    case 18:
                        addr = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.NodeAddress.Builder {
                let resultDecodedBuilder = Lnrpc.NodeAddress.Builder()
                if let jsonValueNetwork = jsonMap["network"] as? String {
                    resultDecodedBuilder.network = jsonValueNetwork
                }
                if let jsonValueAddr = jsonMap["addr"] as? String {
                    resultDecodedBuilder.addr = jsonValueAddr
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.NodeAddress.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.NodeAddress.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class RoutingPolicy : GeneratedMessage {
        public typealias BuilderType = Lnrpc.RoutingPolicy.Builder

        public static func == (lhs: Lnrpc.RoutingPolicy, rhs: Lnrpc.RoutingPolicy) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTimeLockDelta == rhs.hasTimeLockDelta) && (!lhs.hasTimeLockDelta || lhs.timeLockDelta == rhs.timeLockDelta)
            fieldCheck = fieldCheck && (lhs.hasMinHtlc == rhs.hasMinHtlc) && (!lhs.hasMinHtlc || lhs.minHtlc == rhs.minHtlc)
            fieldCheck = fieldCheck && (lhs.hasFeeBaseMsat == rhs.hasFeeBaseMsat) && (!lhs.hasFeeBaseMsat || lhs.feeBaseMsat == rhs.feeBaseMsat)
            fieldCheck = fieldCheck && (lhs.hasFeeRateMilliMsat == rhs.hasFeeRateMilliMsat) && (!lhs.hasFeeRateMilliMsat || lhs.feeRateMilliMsat == rhs.feeRateMilliMsat)
            fieldCheck = fieldCheck && (lhs.hasDisabled == rhs.hasDisabled) && (!lhs.hasDisabled || lhs.disabled == rhs.disabled)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var timeLockDelta:UInt32! = nil
        public fileprivate(set) var hasTimeLockDelta:Bool = false

        public fileprivate(set) var minHtlc:Int64! = nil
        public fileprivate(set) var hasMinHtlc:Bool = false

        public fileprivate(set) var feeBaseMsat:Int64! = nil
        public fileprivate(set) var hasFeeBaseMsat:Bool = false

        public fileprivate(set) var feeRateMilliMsat:Int64! = nil
        public fileprivate(set) var hasFeeRateMilliMsat:Bool = false

        public fileprivate(set) var disabled:Bool! = nil
        public fileprivate(set) var hasDisabled:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTimeLockDelta {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:timeLockDelta)
            }
            if hasMinHtlc {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:minHtlc)
            }
            if hasFeeBaseMsat {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:feeBaseMsat)
            }
            if hasFeeRateMilliMsat {
                try codedOutputStream.writeInt64(fieldNumber: 4, value:feeRateMilliMsat)
            }
            if hasDisabled {
                try codedOutputStream.writeBool(fieldNumber: 5, value:disabled)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTimeLockDelta {
                serialize_size += timeLockDelta.computeUInt32Size(fieldNumber: 1)
            }
            if hasMinHtlc {
                serialize_size += minHtlc.computeInt64Size(fieldNumber: 2)
            }
            if hasFeeBaseMsat {
                serialize_size += feeBaseMsat.computeInt64Size(fieldNumber: 3)
            }
            if hasFeeRateMilliMsat {
                serialize_size += feeRateMilliMsat.computeInt64Size(fieldNumber: 4)
            }
            if hasDisabled {
                serialize_size += disabled.computeBoolSize(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.RoutingPolicy.Builder {
            return Lnrpc.RoutingPolicy.classBuilder() as! Lnrpc.RoutingPolicy.Builder
        }
        public func getBuilder() -> Lnrpc.RoutingPolicy.Builder {
            return classBuilder() as! Lnrpc.RoutingPolicy.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.RoutingPolicy.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.RoutingPolicy.Builder()
        }
        public func toBuilder() throws -> Lnrpc.RoutingPolicy.Builder {
            return try Lnrpc.RoutingPolicy.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.RoutingPolicy) throws -> Lnrpc.RoutingPolicy.Builder {
            return try Lnrpc.RoutingPolicy.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTimeLockDelta {
                jsonMap["time_lock_delta"] = UInt(timeLockDelta)
            }
            if hasMinHtlc {
                jsonMap["min_htlc"] = "\(minHtlc!)"
            }
            if hasFeeBaseMsat {
                jsonMap["fee_base_msat"] = "\(feeBaseMsat!)"
            }
            if hasFeeRateMilliMsat {
                jsonMap["fee_rate_milli_msat"] = "\(feeRateMilliMsat!)"
            }
            if hasDisabled {
                jsonMap["disabled"] = disabled
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.RoutingPolicy {
            return try Lnrpc.RoutingPolicy.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.RoutingPolicy {
            return try Lnrpc.RoutingPolicy.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTimeLockDelta {
                output += "\(indent) timeLockDelta: \(timeLockDelta) \n"
            }
            if hasMinHtlc {
                output += "\(indent) minHtlc: \(minHtlc) \n"
            }
            if hasFeeBaseMsat {
                output += "\(indent) feeBaseMsat: \(feeBaseMsat) \n"
            }
            if hasFeeRateMilliMsat {
                output += "\(indent) feeRateMilliMsat: \(feeRateMilliMsat) \n"
            }
            if hasDisabled {
                output += "\(indent) disabled: \(disabled) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTimeLockDelta {
                    hashCode = (hashCode &* 31) &+ timeLockDelta.hashValue
                }
                if hasMinHtlc {
                    hashCode = (hashCode &* 31) &+ minHtlc.hashValue
                }
                if hasFeeBaseMsat {
                    hashCode = (hashCode &* 31) &+ feeBaseMsat.hashValue
                }
                if hasFeeRateMilliMsat {
                    hashCode = (hashCode &* 31) &+ feeRateMilliMsat.hashValue
                }
                if hasDisabled {
                    hashCode = (hashCode &* 31) &+ disabled.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.RoutingPolicy"
        }
        override public func className() -> String {
            return "Lnrpc.RoutingPolicy"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.RoutingPolicy = Lnrpc.RoutingPolicy()
            public func getMessage() -> Lnrpc.RoutingPolicy {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var timeLockDelta:UInt32 {
                get {
                    return builderResult.timeLockDelta
                }
                set (value) {
                    builderResult.hasTimeLockDelta = true
                    builderResult.timeLockDelta = value
                }
            }
            public var hasTimeLockDelta:Bool {
                get {
                    return builderResult.hasTimeLockDelta
                }
            }
            @discardableResult
            public func setTimeLockDelta(_ value:UInt32) -> Lnrpc.RoutingPolicy.Builder {
                self.timeLockDelta = value
                return self
            }
            @discardableResult
            public func clearTimeLockDelta() -> Lnrpc.RoutingPolicy.Builder{
                builderResult.hasTimeLockDelta = false
                builderResult.timeLockDelta = nil
                return self
            }
            public var minHtlc:Int64 {
                get {
                    return builderResult.minHtlc
                }
                set (value) {
                    builderResult.hasMinHtlc = true
                    builderResult.minHtlc = value
                }
            }
            public var hasMinHtlc:Bool {
                get {
                    return builderResult.hasMinHtlc
                }
            }
            @discardableResult
            public func setMinHtlc(_ value:Int64) -> Lnrpc.RoutingPolicy.Builder {
                self.minHtlc = value
                return self
            }
            @discardableResult
            public func clearMinHtlc() -> Lnrpc.RoutingPolicy.Builder{
                builderResult.hasMinHtlc = false
                builderResult.minHtlc = nil
                return self
            }
            public var feeBaseMsat:Int64 {
                get {
                    return builderResult.feeBaseMsat
                }
                set (value) {
                    builderResult.hasFeeBaseMsat = true
                    builderResult.feeBaseMsat = value
                }
            }
            public var hasFeeBaseMsat:Bool {
                get {
                    return builderResult.hasFeeBaseMsat
                }
            }
            @discardableResult
            public func setFeeBaseMsat(_ value:Int64) -> Lnrpc.RoutingPolicy.Builder {
                self.feeBaseMsat = value
                return self
            }
            @discardableResult
            public func clearFeeBaseMsat() -> Lnrpc.RoutingPolicy.Builder{
                builderResult.hasFeeBaseMsat = false
                builderResult.feeBaseMsat = nil
                return self
            }
            public var feeRateMilliMsat:Int64 {
                get {
                    return builderResult.feeRateMilliMsat
                }
                set (value) {
                    builderResult.hasFeeRateMilliMsat = true
                    builderResult.feeRateMilliMsat = value
                }
            }
            public var hasFeeRateMilliMsat:Bool {
                get {
                    return builderResult.hasFeeRateMilliMsat
                }
            }
            @discardableResult
            public func setFeeRateMilliMsat(_ value:Int64) -> Lnrpc.RoutingPolicy.Builder {
                self.feeRateMilliMsat = value
                return self
            }
            @discardableResult
            public func clearFeeRateMilliMsat() -> Lnrpc.RoutingPolicy.Builder{
                builderResult.hasFeeRateMilliMsat = false
                builderResult.feeRateMilliMsat = nil
                return self
            }
            public var disabled:Bool {
                get {
                    return builderResult.disabled
                }
                set (value) {
                    builderResult.hasDisabled = true
                    builderResult.disabled = value
                }
            }
            public var hasDisabled:Bool {
                get {
                    return builderResult.hasDisabled
                }
            }
            @discardableResult
            public func setDisabled(_ value:Bool) -> Lnrpc.RoutingPolicy.Builder {
                self.disabled = value
                return self
            }
            @discardableResult
            public func clearDisabled() -> Lnrpc.RoutingPolicy.Builder{
                builderResult.hasDisabled = false
                builderResult.disabled = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.RoutingPolicy.Builder {
                builderResult = Lnrpc.RoutingPolicy()
                return self
            }
            override public func clone() throws -> Lnrpc.RoutingPolicy.Builder {
                return try Lnrpc.RoutingPolicy.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.RoutingPolicy {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.RoutingPolicy {
                let returnMe:Lnrpc.RoutingPolicy = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.RoutingPolicy) throws -> Lnrpc.RoutingPolicy.Builder {
                if other == Lnrpc.RoutingPolicy() {
                    return self
                }
                if other.hasTimeLockDelta {
                    timeLockDelta = other.timeLockDelta
                }
                if other.hasMinHtlc {
                    minHtlc = other.minHtlc
                }
                if other.hasFeeBaseMsat {
                    feeBaseMsat = other.feeBaseMsat
                }
                if other.hasFeeRateMilliMsat {
                    feeRateMilliMsat = other.feeRateMilliMsat
                }
                if other.hasDisabled {
                    disabled = other.disabled
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.RoutingPolicy.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.RoutingPolicy.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        timeLockDelta = try codedInputStream.readUInt32()

                    case 16:
                        minHtlc = try codedInputStream.readInt64()

                    case 24:
                        feeBaseMsat = try codedInputStream.readInt64()

                    case 32:
                        feeRateMilliMsat = try codedInputStream.readInt64()

                    case 40:
                        disabled = try codedInputStream.readBool()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.RoutingPolicy.Builder {
                let resultDecodedBuilder = Lnrpc.RoutingPolicy.Builder()
                if let jsonValueTimeLockDelta = jsonMap["time_lock_delta"] as? UInt {
                    resultDecodedBuilder.timeLockDelta = UInt32(jsonValueTimeLockDelta)
                } else if let jsonValueTimeLockDelta = jsonMap["time_lock_delta"] as? String {
                    resultDecodedBuilder.timeLockDelta = UInt32(jsonValueTimeLockDelta)!
                }
                if let jsonValueMinHtlc = jsonMap["min_htlc"] as? String {
                    resultDecodedBuilder.minHtlc = Int64(jsonValueMinHtlc)!
                } else if let jsonValueMinHtlc = jsonMap["min_htlc"] as? Int {
                    resultDecodedBuilder.minHtlc = Int64(jsonValueMinHtlc)
                }
                if let jsonValueFeeBaseMsat = jsonMap["fee_base_msat"] as? String {
                    resultDecodedBuilder.feeBaseMsat = Int64(jsonValueFeeBaseMsat)!
                } else if let jsonValueFeeBaseMsat = jsonMap["fee_base_msat"] as? Int {
                    resultDecodedBuilder.feeBaseMsat = Int64(jsonValueFeeBaseMsat)
                }
                if let jsonValueFeeRateMilliMsat = jsonMap["fee_rate_milli_msat"] as? String {
                    resultDecodedBuilder.feeRateMilliMsat = Int64(jsonValueFeeRateMilliMsat)!
                } else if let jsonValueFeeRateMilliMsat = jsonMap["fee_rate_milli_msat"] as? Int {
                    resultDecodedBuilder.feeRateMilliMsat = Int64(jsonValueFeeRateMilliMsat)
                }
                if let jsonValueDisabled = jsonMap["disabled"] as? Bool {
                    resultDecodedBuilder.disabled = jsonValueDisabled
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.RoutingPolicy.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.RoutingPolicy.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    ///*
    ///A fully authenticated channel along with all its unique attributes.
    ///Once an authenticated channel announcement has been processed on the network,
    ///then an instance of ChannelEdgeInfo encapsulating the channels attributes is
    ///stored. The other portions relevant to routing policy of a channel are stored
    ///within a ChannelEdgePolicy for each direction of the channel.
    final public class ChannelEdge : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ChannelEdge.Builder

        public static func == (lhs: Lnrpc.ChannelEdge, rhs: Lnrpc.ChannelEdge) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasChannelId == rhs.hasChannelId) && (!lhs.hasChannelId || lhs.channelId == rhs.channelId)
            fieldCheck = fieldCheck && (lhs.hasChanPoint == rhs.hasChanPoint) && (!lhs.hasChanPoint || lhs.chanPoint == rhs.chanPoint)
            fieldCheck = fieldCheck && (lhs.hasLastUpdate == rhs.hasLastUpdate) && (!lhs.hasLastUpdate || lhs.lastUpdate == rhs.lastUpdate)
            fieldCheck = fieldCheck && (lhs.hasNode1Pub == rhs.hasNode1Pub) && (!lhs.hasNode1Pub || lhs.node1Pub == rhs.node1Pub)
            fieldCheck = fieldCheck && (lhs.hasNode2Pub == rhs.hasNode2Pub) && (!lhs.hasNode2Pub || lhs.node2Pub == rhs.node2Pub)
            fieldCheck = fieldCheck && (lhs.hasCapacity == rhs.hasCapacity) && (!lhs.hasCapacity || lhs.capacity == rhs.capacity)
            fieldCheck = fieldCheck && (lhs.hasNode1Policy == rhs.hasNode1Policy) && (!lhs.hasNode1Policy || lhs.node1Policy == rhs.node1Policy)
            fieldCheck = fieldCheck && (lhs.hasNode2Policy == rhs.hasNode2Policy) && (!lhs.hasNode2Policy || lhs.node2Policy == rhs.node2Policy)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///*
        ///The unique channel ID for the channel. The first 3 bytes are the block
        ///height, the next 3 the index within the block, and the last 2 bytes are the
        ///output index for the channel.
        public fileprivate(set) var channelId:UInt64! = nil
        public fileprivate(set) var hasChannelId:Bool = false

        public fileprivate(set) var chanPoint:String! = nil
        public fileprivate(set) var hasChanPoint:Bool = false

        public fileprivate(set) var lastUpdate:UInt32! = nil
        public fileprivate(set) var hasLastUpdate:Bool = false

        public fileprivate(set) var node1Pub:String! = nil
        public fileprivate(set) var hasNode1Pub:Bool = false

        public fileprivate(set) var node2Pub:String! = nil
        public fileprivate(set) var hasNode2Pub:Bool = false

        public fileprivate(set) var capacity:Int64! = nil
        public fileprivate(set) var hasCapacity:Bool = false

        public fileprivate(set) var node1Policy:Lnrpc.RoutingPolicy!
        public fileprivate(set) var hasNode1Policy:Bool = false
        public fileprivate(set) var node2Policy:Lnrpc.RoutingPolicy!
        public fileprivate(set) var hasNode2Policy:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasChannelId {
                try codedOutputStream.writeUInt64(fieldNumber: 1, value:channelId)
            }
            if hasChanPoint {
                try codedOutputStream.writeString(fieldNumber: 2, value:chanPoint)
            }
            if hasLastUpdate {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:lastUpdate)
            }
            if hasNode1Pub {
                try codedOutputStream.writeString(fieldNumber: 4, value:node1Pub)
            }
            if hasNode2Pub {
                try codedOutputStream.writeString(fieldNumber: 5, value:node2Pub)
            }
            if hasCapacity {
                try codedOutputStream.writeInt64(fieldNumber: 6, value:capacity)
            }
            if hasNode1Policy {
                try codedOutputStream.writeMessage(fieldNumber: 7, value:node1Policy)
            }
            if hasNode2Policy {
                try codedOutputStream.writeMessage(fieldNumber: 8, value:node2Policy)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasChannelId {
                serialize_size += channelId.computeUInt64Size(fieldNumber: 1)
            }
            if hasChanPoint {
                serialize_size += chanPoint.computeStringSize(fieldNumber: 2)
            }
            if hasLastUpdate {
                serialize_size += lastUpdate.computeUInt32Size(fieldNumber: 3)
            }
            if hasNode1Pub {
                serialize_size += node1Pub.computeStringSize(fieldNumber: 4)
            }
            if hasNode2Pub {
                serialize_size += node2Pub.computeStringSize(fieldNumber: 5)
            }
            if hasCapacity {
                serialize_size += capacity.computeInt64Size(fieldNumber: 6)
            }
            if hasNode1Policy {
                if let varSizenode1Policy = node1Policy?.computeMessageSize(fieldNumber: 7) {
                    serialize_size += varSizenode1Policy
                }
            }
            if hasNode2Policy {
                if let varSizenode2Policy = node2Policy?.computeMessageSize(fieldNumber: 8) {
                    serialize_size += varSizenode2Policy
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ChannelEdge.Builder {
            return Lnrpc.ChannelEdge.classBuilder() as! Lnrpc.ChannelEdge.Builder
        }
        public func getBuilder() -> Lnrpc.ChannelEdge.Builder {
            return classBuilder() as! Lnrpc.ChannelEdge.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChannelEdge.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChannelEdge.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ChannelEdge.Builder {
            return try Lnrpc.ChannelEdge.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ChannelEdge) throws -> Lnrpc.ChannelEdge.Builder {
            return try Lnrpc.ChannelEdge.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasChannelId {
                jsonMap["channel_id"] = "\(channelId!)"
            }
            if hasChanPoint {
                jsonMap["chan_point"] = chanPoint
            }
            if hasLastUpdate {
                jsonMap["last_update"] = UInt(lastUpdate)
            }
            if hasNode1Pub {
                jsonMap["node1_pub"] = node1Pub
            }
            if hasNode2Pub {
                jsonMap["node2_pub"] = node2Pub
            }
            if hasCapacity {
                jsonMap["capacity"] = "\(capacity!)"
            }
            if hasNode1Policy {
                jsonMap["node1_policy"] = try node1Policy.encode()
            }
            if hasNode2Policy {
                jsonMap["node2_policy"] = try node2Policy.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChannelEdge {
            return try Lnrpc.ChannelEdge.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChannelEdge {
            return try Lnrpc.ChannelEdge.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasChannelId {
                output += "\(indent) channelId: \(channelId) \n"
            }
            if hasChanPoint {
                output += "\(indent) chanPoint: \(chanPoint) \n"
            }
            if hasLastUpdate {
                output += "\(indent) lastUpdate: \(lastUpdate) \n"
            }
            if hasNode1Pub {
                output += "\(indent) node1Pub: \(node1Pub) \n"
            }
            if hasNode2Pub {
                output += "\(indent) node2Pub: \(node2Pub) \n"
            }
            if hasCapacity {
                output += "\(indent) capacity: \(capacity) \n"
            }
            if hasNode1Policy {
                output += "\(indent) node1Policy {\n"
                if let outDescNode1Policy = node1Policy {
                    output += try outDescNode1Policy.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasNode2Policy {
                output += "\(indent) node2Policy {\n"
                if let outDescNode2Policy = node2Policy {
                    output += try outDescNode2Policy.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasChannelId {
                    hashCode = (hashCode &* 31) &+ channelId.hashValue
                }
                if hasChanPoint {
                    hashCode = (hashCode &* 31) &+ chanPoint.hashValue
                }
                if hasLastUpdate {
                    hashCode = (hashCode &* 31) &+ lastUpdate.hashValue
                }
                if hasNode1Pub {
                    hashCode = (hashCode &* 31) &+ node1Pub.hashValue
                }
                if hasNode2Pub {
                    hashCode = (hashCode &* 31) &+ node2Pub.hashValue
                }
                if hasCapacity {
                    hashCode = (hashCode &* 31) &+ capacity.hashValue
                }
                if hasNode1Policy {
                    if let hashValuenode1Policy = node1Policy?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuenode1Policy
                    }
                }
                if hasNode2Policy {
                    if let hashValuenode2Policy = node2Policy?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuenode2Policy
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ChannelEdge"
        }
        override public func className() -> String {
            return "Lnrpc.ChannelEdge"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ChannelEdge = Lnrpc.ChannelEdge()
            public func getMessage() -> Lnrpc.ChannelEdge {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///*
            ///The unique channel ID for the channel. The first 3 bytes are the block
            ///height, the next 3 the index within the block, and the last 2 bytes are the
            ///output index for the channel.
            public var channelId:UInt64 {
                get {
                    return builderResult.channelId
                }
                set (value) {
                    builderResult.hasChannelId = true
                    builderResult.channelId = value
                }
            }
            public var hasChannelId:Bool {
                get {
                    return builderResult.hasChannelId
                }
            }
            @discardableResult
            public func setChannelId(_ value:UInt64) -> Lnrpc.ChannelEdge.Builder {
                self.channelId = value
                return self
            }
            @discardableResult
            public func clearChannelId() -> Lnrpc.ChannelEdge.Builder{
                builderResult.hasChannelId = false
                builderResult.channelId = nil
                return self
            }
            public var chanPoint:String {
                get {
                    return builderResult.chanPoint
                }
                set (value) {
                    builderResult.hasChanPoint = true
                    builderResult.chanPoint = value
                }
            }
            public var hasChanPoint:Bool {
                get {
                    return builderResult.hasChanPoint
                }
            }
            @discardableResult
            public func setChanPoint(_ value:String) -> Lnrpc.ChannelEdge.Builder {
                self.chanPoint = value
                return self
            }
            @discardableResult
            public func clearChanPoint() -> Lnrpc.ChannelEdge.Builder{
                builderResult.hasChanPoint = false
                builderResult.chanPoint = nil
                return self
            }
            public var lastUpdate:UInt32 {
                get {
                    return builderResult.lastUpdate
                }
                set (value) {
                    builderResult.hasLastUpdate = true
                    builderResult.lastUpdate = value
                }
            }
            public var hasLastUpdate:Bool {
                get {
                    return builderResult.hasLastUpdate
                }
            }
            @discardableResult
            public func setLastUpdate(_ value:UInt32) -> Lnrpc.ChannelEdge.Builder {
                self.lastUpdate = value
                return self
            }
            @discardableResult
            public func clearLastUpdate() -> Lnrpc.ChannelEdge.Builder{
                builderResult.hasLastUpdate = false
                builderResult.lastUpdate = nil
                return self
            }
            public var node1Pub:String {
                get {
                    return builderResult.node1Pub
                }
                set (value) {
                    builderResult.hasNode1Pub = true
                    builderResult.node1Pub = value
                }
            }
            public var hasNode1Pub:Bool {
                get {
                    return builderResult.hasNode1Pub
                }
            }
            @discardableResult
            public func setNode1Pub(_ value:String) -> Lnrpc.ChannelEdge.Builder {
                self.node1Pub = value
                return self
            }
            @discardableResult
            public func clearNode1Pub() -> Lnrpc.ChannelEdge.Builder{
                builderResult.hasNode1Pub = false
                builderResult.node1Pub = nil
                return self
            }
            public var node2Pub:String {
                get {
                    return builderResult.node2Pub
                }
                set (value) {
                    builderResult.hasNode2Pub = true
                    builderResult.node2Pub = value
                }
            }
            public var hasNode2Pub:Bool {
                get {
                    return builderResult.hasNode2Pub
                }
            }
            @discardableResult
            public func setNode2Pub(_ value:String) -> Lnrpc.ChannelEdge.Builder {
                self.node2Pub = value
                return self
            }
            @discardableResult
            public func clearNode2Pub() -> Lnrpc.ChannelEdge.Builder{
                builderResult.hasNode2Pub = false
                builderResult.node2Pub = nil
                return self
            }
            public var capacity:Int64 {
                get {
                    return builderResult.capacity
                }
                set (value) {
                    builderResult.hasCapacity = true
                    builderResult.capacity = value
                }
            }
            public var hasCapacity:Bool {
                get {
                    return builderResult.hasCapacity
                }
            }
            @discardableResult
            public func setCapacity(_ value:Int64) -> Lnrpc.ChannelEdge.Builder {
                self.capacity = value
                return self
            }
            @discardableResult
            public func clearCapacity() -> Lnrpc.ChannelEdge.Builder{
                builderResult.hasCapacity = false
                builderResult.capacity = nil
                return self
            }
            public var node1Policy:Lnrpc.RoutingPolicy! {
                get {
                    if node1PolicyBuilder_ != nil {
                        builderResult.node1Policy = node1PolicyBuilder_.getMessage()
                    }
                    return builderResult.node1Policy
                }
                set (value) {
                    builderResult.hasNode1Policy = value != nil
                    builderResult.node1Policy = value
                }
            }
            public var hasNode1Policy:Bool {
                get {
                    return builderResult.hasNode1Policy
                }
            }
            fileprivate var node1PolicyBuilder_:Lnrpc.RoutingPolicy.Builder! {
                didSet {
                    builderResult.hasNode1Policy = true
                }
            }
            public func getNode1PolicyBuilder() -> Lnrpc.RoutingPolicy.Builder {
                if node1PolicyBuilder_ == nil {
                    node1PolicyBuilder_ = Lnrpc.RoutingPolicy.Builder()
                    builderResult.node1Policy = node1PolicyBuilder_.getMessage()
                    if node1Policy != nil {
                        try! node1PolicyBuilder_.mergeFrom(other: node1Policy)
                    }
                }
                return node1PolicyBuilder_
            }
            @discardableResult
            public func setNode1Policy(_ value:Lnrpc.RoutingPolicy!) -> Lnrpc.ChannelEdge.Builder {
                self.node1Policy = value
                return self
            }
            @discardableResult
            public func mergeNode1Policy(value:Lnrpc.RoutingPolicy) throws -> Lnrpc.ChannelEdge.Builder {
                if builderResult.hasNode1Policy {
                    builderResult.node1Policy = try Lnrpc.RoutingPolicy.builderWithPrototype(prototype:builderResult.node1Policy).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.node1Policy = value
                }
                builderResult.hasNode1Policy = true
                return self
            }
            @discardableResult
            public func clearNode1Policy() -> Lnrpc.ChannelEdge.Builder {
                node1PolicyBuilder_ = nil
                builderResult.hasNode1Policy = false
                builderResult.node1Policy = nil
                return self
            }
            public var node2Policy:Lnrpc.RoutingPolicy! {
                get {
                    if node2PolicyBuilder_ != nil {
                        builderResult.node2Policy = node2PolicyBuilder_.getMessage()
                    }
                    return builderResult.node2Policy
                }
                set (value) {
                    builderResult.hasNode2Policy = value != nil
                    builderResult.node2Policy = value
                }
            }
            public var hasNode2Policy:Bool {
                get {
                    return builderResult.hasNode2Policy
                }
            }
            fileprivate var node2PolicyBuilder_:Lnrpc.RoutingPolicy.Builder! {
                didSet {
                    builderResult.hasNode2Policy = true
                }
            }
            public func getNode2PolicyBuilder() -> Lnrpc.RoutingPolicy.Builder {
                if node2PolicyBuilder_ == nil {
                    node2PolicyBuilder_ = Lnrpc.RoutingPolicy.Builder()
                    builderResult.node2Policy = node2PolicyBuilder_.getMessage()
                    if node2Policy != nil {
                        try! node2PolicyBuilder_.mergeFrom(other: node2Policy)
                    }
                }
                return node2PolicyBuilder_
            }
            @discardableResult
            public func setNode2Policy(_ value:Lnrpc.RoutingPolicy!) -> Lnrpc.ChannelEdge.Builder {
                self.node2Policy = value
                return self
            }
            @discardableResult
            public func mergeNode2Policy(value:Lnrpc.RoutingPolicy) throws -> Lnrpc.ChannelEdge.Builder {
                if builderResult.hasNode2Policy {
                    builderResult.node2Policy = try Lnrpc.RoutingPolicy.builderWithPrototype(prototype:builderResult.node2Policy).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.node2Policy = value
                }
                builderResult.hasNode2Policy = true
                return self
            }
            @discardableResult
            public func clearNode2Policy() -> Lnrpc.ChannelEdge.Builder {
                node2PolicyBuilder_ = nil
                builderResult.hasNode2Policy = false
                builderResult.node2Policy = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ChannelEdge.Builder {
                builderResult = Lnrpc.ChannelEdge()
                return self
            }
            override public func clone() throws -> Lnrpc.ChannelEdge.Builder {
                return try Lnrpc.ChannelEdge.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ChannelEdge {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ChannelEdge {
                let returnMe:Lnrpc.ChannelEdge = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ChannelEdge) throws -> Lnrpc.ChannelEdge.Builder {
                if other == Lnrpc.ChannelEdge() {
                    return self
                }
                if other.hasChannelId {
                    channelId = other.channelId
                }
                if other.hasChanPoint {
                    chanPoint = other.chanPoint
                }
                if other.hasLastUpdate {
                    lastUpdate = other.lastUpdate
                }
                if other.hasNode1Pub {
                    node1Pub = other.node1Pub
                }
                if other.hasNode2Pub {
                    node2Pub = other.node2Pub
                }
                if other.hasCapacity {
                    capacity = other.capacity
                }
                if (other.hasNode1Policy) {
                    try mergeNode1Policy(value: other.node1Policy)
                }
                if (other.hasNode2Policy) {
                    try mergeNode2Policy(value: other.node2Policy)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChannelEdge.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelEdge.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        channelId = try codedInputStream.readUInt64()

                    case 18:
                        chanPoint = try codedInputStream.readString()

                    case 24:
                        lastUpdate = try codedInputStream.readUInt32()

                    case 34:
                        node1Pub = try codedInputStream.readString()

                    case 42:
                        node2Pub = try codedInputStream.readString()

                    case 48:
                        capacity = try codedInputStream.readInt64()

                    case 58:
                        let subBuilder:Lnrpc.RoutingPolicy.Builder = Lnrpc.RoutingPolicy.Builder()
                        if hasNode1Policy {
                            try subBuilder.mergeFrom(other: node1Policy)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        node1Policy = subBuilder.buildPartial()

                    case 66:
                        let subBuilder:Lnrpc.RoutingPolicy.Builder = Lnrpc.RoutingPolicy.Builder()
                        if hasNode2Policy {
                            try subBuilder.mergeFrom(other: node2Policy)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        node2Policy = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChannelEdge.Builder {
                let resultDecodedBuilder = Lnrpc.ChannelEdge.Builder()
                if let jsonValueChannelId = jsonMap["channel_id"] as? String {
                    resultDecodedBuilder.channelId = UInt64(jsonValueChannelId)!
                } else if let jsonValueChannelId = jsonMap["channel_id"] as? UInt {
                    resultDecodedBuilder.channelId = UInt64(jsonValueChannelId)
                }
                if let jsonValueChanPoint = jsonMap["chan_point"] as? String {
                    resultDecodedBuilder.chanPoint = jsonValueChanPoint
                }
                if let jsonValueLastUpdate = jsonMap["last_update"] as? UInt {
                    resultDecodedBuilder.lastUpdate = UInt32(jsonValueLastUpdate)
                } else if let jsonValueLastUpdate = jsonMap["last_update"] as? String {
                    resultDecodedBuilder.lastUpdate = UInt32(jsonValueLastUpdate)!
                }
                if let jsonValueNode1Pub = jsonMap["node1_pub"] as? String {
                    resultDecodedBuilder.node1Pub = jsonValueNode1Pub
                }
                if let jsonValueNode2Pub = jsonMap["node2_pub"] as? String {
                    resultDecodedBuilder.node2Pub = jsonValueNode2Pub
                }
                if let jsonValueCapacity = jsonMap["capacity"] as? String {
                    resultDecodedBuilder.capacity = Int64(jsonValueCapacity)!
                } else if let jsonValueCapacity = jsonMap["capacity"] as? Int {
                    resultDecodedBuilder.capacity = Int64(jsonValueCapacity)
                }
                if let jsonValueNode1Policy = jsonMap["node1_policy"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.node1Policy = try Lnrpc.RoutingPolicy.Builder.decodeToBuilder(jsonMap:jsonValueNode1Policy).build()

                }
                if let jsonValueNode2Policy = jsonMap["node2_policy"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.node2Policy = try Lnrpc.RoutingPolicy.Builder.decodeToBuilder(jsonMap:jsonValueNode2Policy).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChannelEdge.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ChannelEdge.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ChannelGraphRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ChannelGraphRequest.Builder

        public static func == (lhs: Lnrpc.ChannelGraphRequest, rhs: Lnrpc.ChannelGraphRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ChannelGraphRequest.Builder {
            return Lnrpc.ChannelGraphRequest.classBuilder() as! Lnrpc.ChannelGraphRequest.Builder
        }
        public func getBuilder() -> Lnrpc.ChannelGraphRequest.Builder {
            return classBuilder() as! Lnrpc.ChannelGraphRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChannelGraphRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChannelGraphRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ChannelGraphRequest.Builder {
            return try Lnrpc.ChannelGraphRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ChannelGraphRequest) throws -> Lnrpc.ChannelGraphRequest.Builder {
            return try Lnrpc.ChannelGraphRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChannelGraphRequest {
            return try Lnrpc.ChannelGraphRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChannelGraphRequest {
            return try Lnrpc.ChannelGraphRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ChannelGraphRequest"
        }
        override public func className() -> String {
            return "Lnrpc.ChannelGraphRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ChannelGraphRequest = Lnrpc.ChannelGraphRequest()
            public func getMessage() -> Lnrpc.ChannelGraphRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ChannelGraphRequest.Builder {
                builderResult = Lnrpc.ChannelGraphRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.ChannelGraphRequest.Builder {
                return try Lnrpc.ChannelGraphRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ChannelGraphRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ChannelGraphRequest {
                let returnMe:Lnrpc.ChannelGraphRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ChannelGraphRequest) throws -> Lnrpc.ChannelGraphRequest.Builder {
                if other == Lnrpc.ChannelGraphRequest() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChannelGraphRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelGraphRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChannelGraphRequest.Builder {
                let resultDecodedBuilder = Lnrpc.ChannelGraphRequest.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChannelGraphRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ChannelGraphRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    //// Returns a new instance of the directed channel graph.
    final public class ChannelGraph : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ChannelGraph.Builder

        public static func == (lhs: Lnrpc.ChannelGraph, rhs: Lnrpc.ChannelGraph) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.nodes == rhs.nodes)
            fieldCheck = fieldCheck && (lhs.edges == rhs.edges)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var nodes:Array<Lnrpc.LightningNode>  = Array<Lnrpc.LightningNode>()
        public fileprivate(set) var edges:Array<Lnrpc.ChannelEdge>  = Array<Lnrpc.ChannelEdge>()
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementNodes in nodes {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementNodes)
            }
            for oneElementEdges in edges {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementEdges)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementNodes in nodes {
                serialize_size += oneElementNodes.computeMessageSize(fieldNumber: 1)
            }
            for oneElementEdges in edges {
                serialize_size += oneElementEdges.computeMessageSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ChannelGraph.Builder {
            return Lnrpc.ChannelGraph.classBuilder() as! Lnrpc.ChannelGraph.Builder
        }
        public func getBuilder() -> Lnrpc.ChannelGraph.Builder {
            return classBuilder() as! Lnrpc.ChannelGraph.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChannelGraph.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChannelGraph.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ChannelGraph.Builder {
            return try Lnrpc.ChannelGraph.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ChannelGraph) throws -> Lnrpc.ChannelGraph.Builder {
            return try Lnrpc.ChannelGraph.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !nodes.isEmpty {
                var jsonArrayNodes:Array<Dictionary<String,Any>> = []
                for oneValueNodes in nodes {
                    let ecodedMessageNodes = try oneValueNodes.encode()
                    jsonArrayNodes.append(ecodedMessageNodes)
                }
                jsonMap["nodes"] = jsonArrayNodes
            }
            if !edges.isEmpty {
                var jsonArrayEdges:Array<Dictionary<String,Any>> = []
                for oneValueEdges in edges {
                    let ecodedMessageEdges = try oneValueEdges.encode()
                    jsonArrayEdges.append(ecodedMessageEdges)
                }
                jsonMap["edges"] = jsonArrayEdges
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChannelGraph {
            return try Lnrpc.ChannelGraph.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChannelGraph {
            return try Lnrpc.ChannelGraph.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var nodesElementIndex:Int = 0
            for oneElementNodes in nodes {
                output += "\(indent) nodes[\(nodesElementIndex)] {\n"
                output += try oneElementNodes.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                nodesElementIndex += 1
            }
            var edgesElementIndex:Int = 0
            for oneElementEdges in edges {
                output += "\(indent) edges[\(edgesElementIndex)] {\n"
                output += try oneElementEdges.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                edgesElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementNodes in nodes {
                    hashCode = (hashCode &* 31) &+ oneElementNodes.hashValue
                }
                for oneElementEdges in edges {
                    hashCode = (hashCode &* 31) &+ oneElementEdges.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ChannelGraph"
        }
        override public func className() -> String {
            return "Lnrpc.ChannelGraph"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ChannelGraph = Lnrpc.ChannelGraph()
            public func getMessage() -> Lnrpc.ChannelGraph {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The list of `LightningNode`s in this channel graph
            public var nodes:Array<Lnrpc.LightningNode> {
                get {
                    return builderResult.nodes
                }
                set (value) {
                    builderResult.nodes = value
                }
            }
            @discardableResult
            public func setNodes(_ value:Array<Lnrpc.LightningNode>) -> Lnrpc.ChannelGraph.Builder {
                self.nodes = value
                return self
            }
            @discardableResult
            public func clearNodes() -> Lnrpc.ChannelGraph.Builder {
                builderResult.nodes.removeAll(keepingCapacity: false)
                return self
            }
            //// The list of `ChannelEdge`s in this channel graph
            public var edges:Array<Lnrpc.ChannelEdge> {
                get {
                    return builderResult.edges
                }
                set (value) {
                    builderResult.edges = value
                }
            }
            @discardableResult
            public func setEdges(_ value:Array<Lnrpc.ChannelEdge>) -> Lnrpc.ChannelGraph.Builder {
                self.edges = value
                return self
            }
            @discardableResult
            public func clearEdges() -> Lnrpc.ChannelGraph.Builder {
                builderResult.edges.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ChannelGraph.Builder {
                builderResult = Lnrpc.ChannelGraph()
                return self
            }
            override public func clone() throws -> Lnrpc.ChannelGraph.Builder {
                return try Lnrpc.ChannelGraph.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ChannelGraph {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ChannelGraph {
                let returnMe:Lnrpc.ChannelGraph = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ChannelGraph) throws -> Lnrpc.ChannelGraph.Builder {
                if other == Lnrpc.ChannelGraph() {
                    return self
                }
                if !other.nodes.isEmpty  {
                     builderResult.nodes += other.nodes
                }
                if !other.edges.isEmpty  {
                     builderResult.edges += other.edges
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChannelGraph.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelGraph.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Lnrpc.LightningNode.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        nodes.append(subBuilder.buildPartial())

                    case 18:
                        let subBuilder = Lnrpc.ChannelEdge.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        edges.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChannelGraph.Builder {
                let resultDecodedBuilder = Lnrpc.ChannelGraph.Builder()
                if let jsonValueNodes = jsonMap["nodes"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayNodes:Array<Lnrpc.LightningNode> = []
                    for oneValueNodes in jsonValueNodes {
                        let messageFromStringNodes = try Lnrpc.LightningNode.Builder.decodeToBuilder(jsonMap:oneValueNodes).build()

                        jsonArrayNodes.append(messageFromStringNodes)
                    }
                    resultDecodedBuilder.nodes = jsonArrayNodes
                }
                if let jsonValueEdges = jsonMap["edges"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayEdges:Array<Lnrpc.ChannelEdge> = []
                    for oneValueEdges in jsonValueEdges {
                        let messageFromStringEdges = try Lnrpc.ChannelEdge.Builder.decodeToBuilder(jsonMap:oneValueEdges).build()

                        jsonArrayEdges.append(messageFromStringEdges)
                    }
                    resultDecodedBuilder.edges = jsonArrayEdges
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChannelGraph.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ChannelGraph.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ChanInfoRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ChanInfoRequest.Builder

        public static func == (lhs: Lnrpc.ChanInfoRequest, rhs: Lnrpc.ChanInfoRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasChanId == rhs.hasChanId) && (!lhs.hasChanId || lhs.chanId == rhs.chanId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///*
        ///The unique channel ID for the channel. The first 3 bytes are the block
        ///height, the next 3 the index within the block, and the last 2 bytes are the
        ///output index for the channel.
        public fileprivate(set) var chanId:UInt64! = nil
        public fileprivate(set) var hasChanId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasChanId {
                try codedOutputStream.writeUInt64(fieldNumber: 1, value:chanId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasChanId {
                serialize_size += chanId.computeUInt64Size(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ChanInfoRequest.Builder {
            return Lnrpc.ChanInfoRequest.classBuilder() as! Lnrpc.ChanInfoRequest.Builder
        }
        public func getBuilder() -> Lnrpc.ChanInfoRequest.Builder {
            return classBuilder() as! Lnrpc.ChanInfoRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChanInfoRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChanInfoRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ChanInfoRequest.Builder {
            return try Lnrpc.ChanInfoRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ChanInfoRequest) throws -> Lnrpc.ChanInfoRequest.Builder {
            return try Lnrpc.ChanInfoRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasChanId {
                jsonMap["chanId"] = "\(chanId!)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChanInfoRequest {
            return try Lnrpc.ChanInfoRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChanInfoRequest {
            return try Lnrpc.ChanInfoRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasChanId {
                output += "\(indent) chanId: \(chanId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasChanId {
                    hashCode = (hashCode &* 31) &+ chanId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ChanInfoRequest"
        }
        override public func className() -> String {
            return "Lnrpc.ChanInfoRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ChanInfoRequest = Lnrpc.ChanInfoRequest()
            public func getMessage() -> Lnrpc.ChanInfoRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///*
            ///The unique channel ID for the channel. The first 3 bytes are the block
            ///height, the next 3 the index within the block, and the last 2 bytes are the
            ///output index for the channel.
            public var chanId:UInt64 {
                get {
                    return builderResult.chanId
                }
                set (value) {
                    builderResult.hasChanId = true
                    builderResult.chanId = value
                }
            }
            public var hasChanId:Bool {
                get {
                    return builderResult.hasChanId
                }
            }
            @discardableResult
            public func setChanId(_ value:UInt64) -> Lnrpc.ChanInfoRequest.Builder {
                self.chanId = value
                return self
            }
            @discardableResult
            public func clearChanId() -> Lnrpc.ChanInfoRequest.Builder{
                builderResult.hasChanId = false
                builderResult.chanId = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ChanInfoRequest.Builder {
                builderResult = Lnrpc.ChanInfoRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.ChanInfoRequest.Builder {
                return try Lnrpc.ChanInfoRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ChanInfoRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ChanInfoRequest {
                let returnMe:Lnrpc.ChanInfoRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ChanInfoRequest) throws -> Lnrpc.ChanInfoRequest.Builder {
                if other == Lnrpc.ChanInfoRequest() {
                    return self
                }
                if other.hasChanId {
                    chanId = other.chanId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChanInfoRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChanInfoRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        chanId = try codedInputStream.readUInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChanInfoRequest.Builder {
                let resultDecodedBuilder = Lnrpc.ChanInfoRequest.Builder()
                if let jsonValueChanId = jsonMap["chanId"] as? String {
                    resultDecodedBuilder.chanId = UInt64(jsonValueChanId)!
                } else if let jsonValueChanId = jsonMap["chanId"] as? UInt {
                    resultDecodedBuilder.chanId = UInt64(jsonValueChanId)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChanInfoRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ChanInfoRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class NetworkInfoRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.NetworkInfoRequest.Builder

        public static func == (lhs: Lnrpc.NetworkInfoRequest, rhs: Lnrpc.NetworkInfoRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.NetworkInfoRequest.Builder {
            return Lnrpc.NetworkInfoRequest.classBuilder() as! Lnrpc.NetworkInfoRequest.Builder
        }
        public func getBuilder() -> Lnrpc.NetworkInfoRequest.Builder {
            return classBuilder() as! Lnrpc.NetworkInfoRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.NetworkInfoRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.NetworkInfoRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.NetworkInfoRequest.Builder {
            return try Lnrpc.NetworkInfoRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.NetworkInfoRequest) throws -> Lnrpc.NetworkInfoRequest.Builder {
            return try Lnrpc.NetworkInfoRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.NetworkInfoRequest {
            return try Lnrpc.NetworkInfoRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.NetworkInfoRequest {
            return try Lnrpc.NetworkInfoRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.NetworkInfoRequest"
        }
        override public func className() -> String {
            return "Lnrpc.NetworkInfoRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.NetworkInfoRequest = Lnrpc.NetworkInfoRequest()
            public func getMessage() -> Lnrpc.NetworkInfoRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.NetworkInfoRequest.Builder {
                builderResult = Lnrpc.NetworkInfoRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.NetworkInfoRequest.Builder {
                return try Lnrpc.NetworkInfoRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.NetworkInfoRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.NetworkInfoRequest {
                let returnMe:Lnrpc.NetworkInfoRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.NetworkInfoRequest) throws -> Lnrpc.NetworkInfoRequest.Builder {
                if other == Lnrpc.NetworkInfoRequest() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.NetworkInfoRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NetworkInfoRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.NetworkInfoRequest.Builder {
                let resultDecodedBuilder = Lnrpc.NetworkInfoRequest.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.NetworkInfoRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.NetworkInfoRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class NetworkInfo : GeneratedMessage {
        public typealias BuilderType = Lnrpc.NetworkInfo.Builder

        public static func == (lhs: Lnrpc.NetworkInfo, rhs: Lnrpc.NetworkInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGraphDiameter == rhs.hasGraphDiameter) && (!lhs.hasGraphDiameter || lhs.graphDiameter == rhs.graphDiameter)
            fieldCheck = fieldCheck && (lhs.hasAvgOutDegree == rhs.hasAvgOutDegree) && (!lhs.hasAvgOutDegree || lhs.avgOutDegree == rhs.avgOutDegree)
            fieldCheck = fieldCheck && (lhs.hasMaxOutDegree == rhs.hasMaxOutDegree) && (!lhs.hasMaxOutDegree || lhs.maxOutDegree == rhs.maxOutDegree)
            fieldCheck = fieldCheck && (lhs.hasNumNodes == rhs.hasNumNodes) && (!lhs.hasNumNodes || lhs.numNodes == rhs.numNodes)
            fieldCheck = fieldCheck && (lhs.hasNumChannels == rhs.hasNumChannels) && (!lhs.hasNumChannels || lhs.numChannels == rhs.numChannels)
            fieldCheck = fieldCheck && (lhs.hasTotalNetworkCapacity == rhs.hasTotalNetworkCapacity) && (!lhs.hasTotalNetworkCapacity || lhs.totalNetworkCapacity == rhs.totalNetworkCapacity)
            fieldCheck = fieldCheck && (lhs.hasAvgChannelSize == rhs.hasAvgChannelSize) && (!lhs.hasAvgChannelSize || lhs.avgChannelSize == rhs.avgChannelSize)
            fieldCheck = fieldCheck && (lhs.hasMinChannelSize == rhs.hasMinChannelSize) && (!lhs.hasMinChannelSize || lhs.minChannelSize == rhs.minChannelSize)
            fieldCheck = fieldCheck && (lhs.hasMaxChannelSize == rhs.hasMaxChannelSize) && (!lhs.hasMaxChannelSize || lhs.maxChannelSize == rhs.maxChannelSize)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var graphDiameter:UInt32! = nil
        public fileprivate(set) var hasGraphDiameter:Bool = false

        public fileprivate(set) var avgOutDegree:Double! = nil
        public fileprivate(set) var hasAvgOutDegree:Bool = false

        public fileprivate(set) var maxOutDegree:UInt32! = nil
        public fileprivate(set) var hasMaxOutDegree:Bool = false

        public fileprivate(set) var numNodes:UInt32! = nil
        public fileprivate(set) var hasNumNodes:Bool = false

        public fileprivate(set) var numChannels:UInt32! = nil
        public fileprivate(set) var hasNumChannels:Bool = false

        public fileprivate(set) var totalNetworkCapacity:Int64! = nil
        public fileprivate(set) var hasTotalNetworkCapacity:Bool = false

        public fileprivate(set) var avgChannelSize:Double! = nil
        public fileprivate(set) var hasAvgChannelSize:Bool = false

        public fileprivate(set) var minChannelSize:Int64! = nil
        public fileprivate(set) var hasMinChannelSize:Bool = false

        public fileprivate(set) var maxChannelSize:Int64! = nil
        public fileprivate(set) var hasMaxChannelSize:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGraphDiameter {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:graphDiameter)
            }
            if hasAvgOutDegree {
                try codedOutputStream.writeDouble(fieldNumber: 2, value:avgOutDegree)
            }
            if hasMaxOutDegree {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:maxOutDegree)
            }
            if hasNumNodes {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:numNodes)
            }
            if hasNumChannels {
                try codedOutputStream.writeUInt32(fieldNumber: 5, value:numChannels)
            }
            if hasTotalNetworkCapacity {
                try codedOutputStream.writeInt64(fieldNumber: 6, value:totalNetworkCapacity)
            }
            if hasAvgChannelSize {
                try codedOutputStream.writeDouble(fieldNumber: 7, value:avgChannelSize)
            }
            if hasMinChannelSize {
                try codedOutputStream.writeInt64(fieldNumber: 8, value:minChannelSize)
            }
            if hasMaxChannelSize {
                try codedOutputStream.writeInt64(fieldNumber: 9, value:maxChannelSize)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGraphDiameter {
                serialize_size += graphDiameter.computeUInt32Size(fieldNumber: 1)
            }
            if hasAvgOutDegree {
                serialize_size += avgOutDegree.computeDoubleSize(fieldNumber: 2)
            }
            if hasMaxOutDegree {
                serialize_size += maxOutDegree.computeUInt32Size(fieldNumber: 3)
            }
            if hasNumNodes {
                serialize_size += numNodes.computeUInt32Size(fieldNumber: 4)
            }
            if hasNumChannels {
                serialize_size += numChannels.computeUInt32Size(fieldNumber: 5)
            }
            if hasTotalNetworkCapacity {
                serialize_size += totalNetworkCapacity.computeInt64Size(fieldNumber: 6)
            }
            if hasAvgChannelSize {
                serialize_size += avgChannelSize.computeDoubleSize(fieldNumber: 7)
            }
            if hasMinChannelSize {
                serialize_size += minChannelSize.computeInt64Size(fieldNumber: 8)
            }
            if hasMaxChannelSize {
                serialize_size += maxChannelSize.computeInt64Size(fieldNumber: 9)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.NetworkInfo.Builder {
            return Lnrpc.NetworkInfo.classBuilder() as! Lnrpc.NetworkInfo.Builder
        }
        public func getBuilder() -> Lnrpc.NetworkInfo.Builder {
            return classBuilder() as! Lnrpc.NetworkInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.NetworkInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.NetworkInfo.Builder()
        }
        public func toBuilder() throws -> Lnrpc.NetworkInfo.Builder {
            return try Lnrpc.NetworkInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.NetworkInfo) throws -> Lnrpc.NetworkInfo.Builder {
            return try Lnrpc.NetworkInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGraphDiameter {
                jsonMap["graph_diameter"] = UInt(graphDiameter)
            }
            if hasAvgOutDegree {
                jsonMap["avg_out_degree"] = Double(avgOutDegree)
            }
            if hasMaxOutDegree {
                jsonMap["max_out_degree"] = UInt(maxOutDegree)
            }
            if hasNumNodes {
                jsonMap["num_nodes"] = UInt(numNodes)
            }
            if hasNumChannels {
                jsonMap["num_channels"] = UInt(numChannels)
            }
            if hasTotalNetworkCapacity {
                jsonMap["total_network_capacity"] = "\(totalNetworkCapacity!)"
            }
            if hasAvgChannelSize {
                jsonMap["avg_channel_size"] = Double(avgChannelSize)
            }
            if hasMinChannelSize {
                jsonMap["min_channel_size"] = "\(minChannelSize!)"
            }
            if hasMaxChannelSize {
                jsonMap["max_channel_size"] = "\(maxChannelSize!)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.NetworkInfo {
            return try Lnrpc.NetworkInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.NetworkInfo {
            return try Lnrpc.NetworkInfo.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGraphDiameter {
                output += "\(indent) graphDiameter: \(graphDiameter) \n"
            }
            if hasAvgOutDegree {
                output += "\(indent) avgOutDegree: \(avgOutDegree) \n"
            }
            if hasMaxOutDegree {
                output += "\(indent) maxOutDegree: \(maxOutDegree) \n"
            }
            if hasNumNodes {
                output += "\(indent) numNodes: \(numNodes) \n"
            }
            if hasNumChannels {
                output += "\(indent) numChannels: \(numChannels) \n"
            }
            if hasTotalNetworkCapacity {
                output += "\(indent) totalNetworkCapacity: \(totalNetworkCapacity) \n"
            }
            if hasAvgChannelSize {
                output += "\(indent) avgChannelSize: \(avgChannelSize) \n"
            }
            if hasMinChannelSize {
                output += "\(indent) minChannelSize: \(minChannelSize) \n"
            }
            if hasMaxChannelSize {
                output += "\(indent) maxChannelSize: \(maxChannelSize) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGraphDiameter {
                    hashCode = (hashCode &* 31) &+ graphDiameter.hashValue
                }
                if hasAvgOutDegree {
                    hashCode = (hashCode &* 31) &+ avgOutDegree.hashValue
                }
                if hasMaxOutDegree {
                    hashCode = (hashCode &* 31) &+ maxOutDegree.hashValue
                }
                if hasNumNodes {
                    hashCode = (hashCode &* 31) &+ numNodes.hashValue
                }
                if hasNumChannels {
                    hashCode = (hashCode &* 31) &+ numChannels.hashValue
                }
                if hasTotalNetworkCapacity {
                    hashCode = (hashCode &* 31) &+ totalNetworkCapacity.hashValue
                }
                if hasAvgChannelSize {
                    hashCode = (hashCode &* 31) &+ avgChannelSize.hashValue
                }
                if hasMinChannelSize {
                    hashCode = (hashCode &* 31) &+ minChannelSize.hashValue
                }
                if hasMaxChannelSize {
                    hashCode = (hashCode &* 31) &+ maxChannelSize.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.NetworkInfo"
        }
        override public func className() -> String {
            return "Lnrpc.NetworkInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.NetworkInfo = Lnrpc.NetworkInfo()
            public func getMessage() -> Lnrpc.NetworkInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var graphDiameter:UInt32 {
                get {
                    return builderResult.graphDiameter
                }
                set (value) {
                    builderResult.hasGraphDiameter = true
                    builderResult.graphDiameter = value
                }
            }
            public var hasGraphDiameter:Bool {
                get {
                    return builderResult.hasGraphDiameter
                }
            }
            @discardableResult
            public func setGraphDiameter(_ value:UInt32) -> Lnrpc.NetworkInfo.Builder {
                self.graphDiameter = value
                return self
            }
            @discardableResult
            public func clearGraphDiameter() -> Lnrpc.NetworkInfo.Builder{
                builderResult.hasGraphDiameter = false
                builderResult.graphDiameter = nil
                return self
            }
            public var avgOutDegree:Double {
                get {
                    return builderResult.avgOutDegree
                }
                set (value) {
                    builderResult.hasAvgOutDegree = true
                    builderResult.avgOutDegree = value
                }
            }
            public var hasAvgOutDegree:Bool {
                get {
                    return builderResult.hasAvgOutDegree
                }
            }
            @discardableResult
            public func setAvgOutDegree(_ value:Double) -> Lnrpc.NetworkInfo.Builder {
                self.avgOutDegree = value
                return self
            }
            @discardableResult
            public func clearAvgOutDegree() -> Lnrpc.NetworkInfo.Builder{
                builderResult.hasAvgOutDegree = false
                builderResult.avgOutDegree = nil
                return self
            }
            public var maxOutDegree:UInt32 {
                get {
                    return builderResult.maxOutDegree
                }
                set (value) {
                    builderResult.hasMaxOutDegree = true
                    builderResult.maxOutDegree = value
                }
            }
            public var hasMaxOutDegree:Bool {
                get {
                    return builderResult.hasMaxOutDegree
                }
            }
            @discardableResult
            public func setMaxOutDegree(_ value:UInt32) -> Lnrpc.NetworkInfo.Builder {
                self.maxOutDegree = value
                return self
            }
            @discardableResult
            public func clearMaxOutDegree() -> Lnrpc.NetworkInfo.Builder{
                builderResult.hasMaxOutDegree = false
                builderResult.maxOutDegree = nil
                return self
            }
            public var numNodes:UInt32 {
                get {
                    return builderResult.numNodes
                }
                set (value) {
                    builderResult.hasNumNodes = true
                    builderResult.numNodes = value
                }
            }
            public var hasNumNodes:Bool {
                get {
                    return builderResult.hasNumNodes
                }
            }
            @discardableResult
            public func setNumNodes(_ value:UInt32) -> Lnrpc.NetworkInfo.Builder {
                self.numNodes = value
                return self
            }
            @discardableResult
            public func clearNumNodes() -> Lnrpc.NetworkInfo.Builder{
                builderResult.hasNumNodes = false
                builderResult.numNodes = nil
                return self
            }
            public var numChannels:UInt32 {
                get {
                    return builderResult.numChannels
                }
                set (value) {
                    builderResult.hasNumChannels = true
                    builderResult.numChannels = value
                }
            }
            public var hasNumChannels:Bool {
                get {
                    return builderResult.hasNumChannels
                }
            }
            @discardableResult
            public func setNumChannels(_ value:UInt32) -> Lnrpc.NetworkInfo.Builder {
                self.numChannels = value
                return self
            }
            @discardableResult
            public func clearNumChannels() -> Lnrpc.NetworkInfo.Builder{
                builderResult.hasNumChannels = false
                builderResult.numChannels = nil
                return self
            }
            public var totalNetworkCapacity:Int64 {
                get {
                    return builderResult.totalNetworkCapacity
                }
                set (value) {
                    builderResult.hasTotalNetworkCapacity = true
                    builderResult.totalNetworkCapacity = value
                }
            }
            public var hasTotalNetworkCapacity:Bool {
                get {
                    return builderResult.hasTotalNetworkCapacity
                }
            }
            @discardableResult
            public func setTotalNetworkCapacity(_ value:Int64) -> Lnrpc.NetworkInfo.Builder {
                self.totalNetworkCapacity = value
                return self
            }
            @discardableResult
            public func clearTotalNetworkCapacity() -> Lnrpc.NetworkInfo.Builder{
                builderResult.hasTotalNetworkCapacity = false
                builderResult.totalNetworkCapacity = nil
                return self
            }
            public var avgChannelSize:Double {
                get {
                    return builderResult.avgChannelSize
                }
                set (value) {
                    builderResult.hasAvgChannelSize = true
                    builderResult.avgChannelSize = value
                }
            }
            public var hasAvgChannelSize:Bool {
                get {
                    return builderResult.hasAvgChannelSize
                }
            }
            @discardableResult
            public func setAvgChannelSize(_ value:Double) -> Lnrpc.NetworkInfo.Builder {
                self.avgChannelSize = value
                return self
            }
            @discardableResult
            public func clearAvgChannelSize() -> Lnrpc.NetworkInfo.Builder{
                builderResult.hasAvgChannelSize = false
                builderResult.avgChannelSize = nil
                return self
            }
            public var minChannelSize:Int64 {
                get {
                    return builderResult.minChannelSize
                }
                set (value) {
                    builderResult.hasMinChannelSize = true
                    builderResult.minChannelSize = value
                }
            }
            public var hasMinChannelSize:Bool {
                get {
                    return builderResult.hasMinChannelSize
                }
            }
            @discardableResult
            public func setMinChannelSize(_ value:Int64) -> Lnrpc.NetworkInfo.Builder {
                self.minChannelSize = value
                return self
            }
            @discardableResult
            public func clearMinChannelSize() -> Lnrpc.NetworkInfo.Builder{
                builderResult.hasMinChannelSize = false
                builderResult.minChannelSize = nil
                return self
            }
            public var maxChannelSize:Int64 {
                get {
                    return builderResult.maxChannelSize
                }
                set (value) {
                    builderResult.hasMaxChannelSize = true
                    builderResult.maxChannelSize = value
                }
            }
            public var hasMaxChannelSize:Bool {
                get {
                    return builderResult.hasMaxChannelSize
                }
            }
            @discardableResult
            public func setMaxChannelSize(_ value:Int64) -> Lnrpc.NetworkInfo.Builder {
                self.maxChannelSize = value
                return self
            }
            @discardableResult
            public func clearMaxChannelSize() -> Lnrpc.NetworkInfo.Builder{
                builderResult.hasMaxChannelSize = false
                builderResult.maxChannelSize = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.NetworkInfo.Builder {
                builderResult = Lnrpc.NetworkInfo()
                return self
            }
            override public func clone() throws -> Lnrpc.NetworkInfo.Builder {
                return try Lnrpc.NetworkInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.NetworkInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.NetworkInfo {
                let returnMe:Lnrpc.NetworkInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.NetworkInfo) throws -> Lnrpc.NetworkInfo.Builder {
                if other == Lnrpc.NetworkInfo() {
                    return self
                }
                if other.hasGraphDiameter {
                    graphDiameter = other.graphDiameter
                }
                if other.hasAvgOutDegree {
                    avgOutDegree = other.avgOutDegree
                }
                if other.hasMaxOutDegree {
                    maxOutDegree = other.maxOutDegree
                }
                if other.hasNumNodes {
                    numNodes = other.numNodes
                }
                if other.hasNumChannels {
                    numChannels = other.numChannels
                }
                if other.hasTotalNetworkCapacity {
                    totalNetworkCapacity = other.totalNetworkCapacity
                }
                if other.hasAvgChannelSize {
                    avgChannelSize = other.avgChannelSize
                }
                if other.hasMinChannelSize {
                    minChannelSize = other.minChannelSize
                }
                if other.hasMaxChannelSize {
                    maxChannelSize = other.maxChannelSize
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.NetworkInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NetworkInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        graphDiameter = try codedInputStream.readUInt32()

                    case 17:
                        avgOutDegree = try codedInputStream.readDouble()

                    case 24:
                        maxOutDegree = try codedInputStream.readUInt32()

                    case 32:
                        numNodes = try codedInputStream.readUInt32()

                    case 40:
                        numChannels = try codedInputStream.readUInt32()

                    case 48:
                        totalNetworkCapacity = try codedInputStream.readInt64()

                    case 57:
                        avgChannelSize = try codedInputStream.readDouble()

                    case 64:
                        minChannelSize = try codedInputStream.readInt64()

                    case 72:
                        maxChannelSize = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.NetworkInfo.Builder {
                let resultDecodedBuilder = Lnrpc.NetworkInfo.Builder()
                if let jsonValueGraphDiameter = jsonMap["graph_diameter"] as? UInt {
                    resultDecodedBuilder.graphDiameter = UInt32(jsonValueGraphDiameter)
                } else if let jsonValueGraphDiameter = jsonMap["graph_diameter"] as? String {
                    resultDecodedBuilder.graphDiameter = UInt32(jsonValueGraphDiameter)!
                }
                if let jsonValueAvgOutDegree = jsonMap["avg_out_degree"] as? Double {
                    resultDecodedBuilder.avgOutDegree = Double(jsonValueAvgOutDegree)
                } else if let jsonValueAvgOutDegree = jsonMap["avg_out_degree"] as? String {
                    resultDecodedBuilder.avgOutDegree = Double(jsonValueAvgOutDegree)!
                }
                if let jsonValueMaxOutDegree = jsonMap["max_out_degree"] as? UInt {
                    resultDecodedBuilder.maxOutDegree = UInt32(jsonValueMaxOutDegree)
                } else if let jsonValueMaxOutDegree = jsonMap["max_out_degree"] as? String {
                    resultDecodedBuilder.maxOutDegree = UInt32(jsonValueMaxOutDegree)!
                }
                if let jsonValueNumNodes = jsonMap["num_nodes"] as? UInt {
                    resultDecodedBuilder.numNodes = UInt32(jsonValueNumNodes)
                } else if let jsonValueNumNodes = jsonMap["num_nodes"] as? String {
                    resultDecodedBuilder.numNodes = UInt32(jsonValueNumNodes)!
                }
                if let jsonValueNumChannels = jsonMap["num_channels"] as? UInt {
                    resultDecodedBuilder.numChannels = UInt32(jsonValueNumChannels)
                } else if let jsonValueNumChannels = jsonMap["num_channels"] as? String {
                    resultDecodedBuilder.numChannels = UInt32(jsonValueNumChannels)!
                }
                if let jsonValueTotalNetworkCapacity = jsonMap["total_network_capacity"] as? String {
                    resultDecodedBuilder.totalNetworkCapacity = Int64(jsonValueTotalNetworkCapacity)!
                } else if let jsonValueTotalNetworkCapacity = jsonMap["total_network_capacity"] as? Int {
                    resultDecodedBuilder.totalNetworkCapacity = Int64(jsonValueTotalNetworkCapacity)
                }
                if let jsonValueAvgChannelSize = jsonMap["avg_channel_size"] as? Double {
                    resultDecodedBuilder.avgChannelSize = Double(jsonValueAvgChannelSize)
                } else if let jsonValueAvgChannelSize = jsonMap["avg_channel_size"] as? String {
                    resultDecodedBuilder.avgChannelSize = Double(jsonValueAvgChannelSize)!
                }
                if let jsonValueMinChannelSize = jsonMap["min_channel_size"] as? String {
                    resultDecodedBuilder.minChannelSize = Int64(jsonValueMinChannelSize)!
                } else if let jsonValueMinChannelSize = jsonMap["min_channel_size"] as? Int {
                    resultDecodedBuilder.minChannelSize = Int64(jsonValueMinChannelSize)
                }
                if let jsonValueMaxChannelSize = jsonMap["max_channel_size"] as? String {
                    resultDecodedBuilder.maxChannelSize = Int64(jsonValueMaxChannelSize)!
                } else if let jsonValueMaxChannelSize = jsonMap["max_channel_size"] as? Int {
                    resultDecodedBuilder.maxChannelSize = Int64(jsonValueMaxChannelSize)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.NetworkInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.NetworkInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class StopRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.StopRequest.Builder

        public static func == (lhs: Lnrpc.StopRequest, rhs: Lnrpc.StopRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.StopRequest.Builder {
            return Lnrpc.StopRequest.classBuilder() as! Lnrpc.StopRequest.Builder
        }
        public func getBuilder() -> Lnrpc.StopRequest.Builder {
            return classBuilder() as! Lnrpc.StopRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.StopRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.StopRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.StopRequest.Builder {
            return try Lnrpc.StopRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.StopRequest) throws -> Lnrpc.StopRequest.Builder {
            return try Lnrpc.StopRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.StopRequest {
            return try Lnrpc.StopRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.StopRequest {
            return try Lnrpc.StopRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.StopRequest"
        }
        override public func className() -> String {
            return "Lnrpc.StopRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.StopRequest = Lnrpc.StopRequest()
            public func getMessage() -> Lnrpc.StopRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.StopRequest.Builder {
                builderResult = Lnrpc.StopRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.StopRequest.Builder {
                return try Lnrpc.StopRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.StopRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.StopRequest {
                let returnMe:Lnrpc.StopRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.StopRequest) throws -> Lnrpc.StopRequest.Builder {
                if other == Lnrpc.StopRequest() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.StopRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.StopRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.StopRequest.Builder {
                let resultDecodedBuilder = Lnrpc.StopRequest.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.StopRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.StopRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class StopResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.StopResponse.Builder

        public static func == (lhs: Lnrpc.StopResponse, rhs: Lnrpc.StopResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.StopResponse.Builder {
            return Lnrpc.StopResponse.classBuilder() as! Lnrpc.StopResponse.Builder
        }
        public func getBuilder() -> Lnrpc.StopResponse.Builder {
            return classBuilder() as! Lnrpc.StopResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.StopResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.StopResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.StopResponse.Builder {
            return try Lnrpc.StopResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.StopResponse) throws -> Lnrpc.StopResponse.Builder {
            return try Lnrpc.StopResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.StopResponse {
            return try Lnrpc.StopResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.StopResponse {
            return try Lnrpc.StopResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.StopResponse"
        }
        override public func className() -> String {
            return "Lnrpc.StopResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.StopResponse = Lnrpc.StopResponse()
            public func getMessage() -> Lnrpc.StopResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.StopResponse.Builder {
                builderResult = Lnrpc.StopResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.StopResponse.Builder {
                return try Lnrpc.StopResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.StopResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.StopResponse {
                let returnMe:Lnrpc.StopResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.StopResponse) throws -> Lnrpc.StopResponse.Builder {
                if other == Lnrpc.StopResponse() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.StopResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.StopResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.StopResponse.Builder {
                let resultDecodedBuilder = Lnrpc.StopResponse.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.StopResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.StopResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GraphTopologySubscription : GeneratedMessage {
        public typealias BuilderType = Lnrpc.GraphTopologySubscription.Builder

        public static func == (lhs: Lnrpc.GraphTopologySubscription, rhs: Lnrpc.GraphTopologySubscription) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.GraphTopologySubscription.Builder {
            return Lnrpc.GraphTopologySubscription.classBuilder() as! Lnrpc.GraphTopologySubscription.Builder
        }
        public func getBuilder() -> Lnrpc.GraphTopologySubscription.Builder {
            return classBuilder() as! Lnrpc.GraphTopologySubscription.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.GraphTopologySubscription.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.GraphTopologySubscription.Builder()
        }
        public func toBuilder() throws -> Lnrpc.GraphTopologySubscription.Builder {
            return try Lnrpc.GraphTopologySubscription.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.GraphTopologySubscription) throws -> Lnrpc.GraphTopologySubscription.Builder {
            return try Lnrpc.GraphTopologySubscription.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.GraphTopologySubscription {
            return try Lnrpc.GraphTopologySubscription.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.GraphTopologySubscription {
            return try Lnrpc.GraphTopologySubscription.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.GraphTopologySubscription"
        }
        override public func className() -> String {
            return "Lnrpc.GraphTopologySubscription"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.GraphTopologySubscription = Lnrpc.GraphTopologySubscription()
            public func getMessage() -> Lnrpc.GraphTopologySubscription {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.GraphTopologySubscription.Builder {
                builderResult = Lnrpc.GraphTopologySubscription()
                return self
            }
            override public func clone() throws -> Lnrpc.GraphTopologySubscription.Builder {
                return try Lnrpc.GraphTopologySubscription.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.GraphTopologySubscription {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.GraphTopologySubscription {
                let returnMe:Lnrpc.GraphTopologySubscription = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.GraphTopologySubscription) throws -> Lnrpc.GraphTopologySubscription.Builder {
                if other == Lnrpc.GraphTopologySubscription() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.GraphTopologySubscription.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GraphTopologySubscription.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.GraphTopologySubscription.Builder {
                let resultDecodedBuilder = Lnrpc.GraphTopologySubscription.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.GraphTopologySubscription.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.GraphTopologySubscription.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GraphTopologyUpdate : GeneratedMessage {
        public typealias BuilderType = Lnrpc.GraphTopologyUpdate.Builder

        public static func == (lhs: Lnrpc.GraphTopologyUpdate, rhs: Lnrpc.GraphTopologyUpdate) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.nodeUpdates == rhs.nodeUpdates)
            fieldCheck = fieldCheck && (lhs.channelUpdates == rhs.channelUpdates)
            fieldCheck = fieldCheck && (lhs.closedChans == rhs.closedChans)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var nodeUpdates:Array<Lnrpc.NodeUpdate>  = Array<Lnrpc.NodeUpdate>()
        public fileprivate(set) var channelUpdates:Array<Lnrpc.ChannelEdgeUpdate>  = Array<Lnrpc.ChannelEdgeUpdate>()
        public fileprivate(set) var closedChans:Array<Lnrpc.ClosedChannelUpdate>  = Array<Lnrpc.ClosedChannelUpdate>()
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementNodeUpdates in nodeUpdates {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementNodeUpdates)
            }
            for oneElementChannelUpdates in channelUpdates {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementChannelUpdates)
            }
            for oneElementClosedChans in closedChans {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementClosedChans)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementNodeUpdates in nodeUpdates {
                serialize_size += oneElementNodeUpdates.computeMessageSize(fieldNumber: 1)
            }
            for oneElementChannelUpdates in channelUpdates {
                serialize_size += oneElementChannelUpdates.computeMessageSize(fieldNumber: 2)
            }
            for oneElementClosedChans in closedChans {
                serialize_size += oneElementClosedChans.computeMessageSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.GraphTopologyUpdate.Builder {
            return Lnrpc.GraphTopologyUpdate.classBuilder() as! Lnrpc.GraphTopologyUpdate.Builder
        }
        public func getBuilder() -> Lnrpc.GraphTopologyUpdate.Builder {
            return classBuilder() as! Lnrpc.GraphTopologyUpdate.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.GraphTopologyUpdate.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.GraphTopologyUpdate.Builder()
        }
        public func toBuilder() throws -> Lnrpc.GraphTopologyUpdate.Builder {
            return try Lnrpc.GraphTopologyUpdate.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.GraphTopologyUpdate) throws -> Lnrpc.GraphTopologyUpdate.Builder {
            return try Lnrpc.GraphTopologyUpdate.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !nodeUpdates.isEmpty {
                var jsonArrayNodeUpdates:Array<Dictionary<String,Any>> = []
                for oneValueNodeUpdates in nodeUpdates {
                    let ecodedMessageNodeUpdates = try oneValueNodeUpdates.encode()
                    jsonArrayNodeUpdates.append(ecodedMessageNodeUpdates)
                }
                jsonMap["nodeUpdates"] = jsonArrayNodeUpdates
            }
            if !channelUpdates.isEmpty {
                var jsonArrayChannelUpdates:Array<Dictionary<String,Any>> = []
                for oneValueChannelUpdates in channelUpdates {
                    let ecodedMessageChannelUpdates = try oneValueChannelUpdates.encode()
                    jsonArrayChannelUpdates.append(ecodedMessageChannelUpdates)
                }
                jsonMap["channelUpdates"] = jsonArrayChannelUpdates
            }
            if !closedChans.isEmpty {
                var jsonArrayClosedChans:Array<Dictionary<String,Any>> = []
                for oneValueClosedChans in closedChans {
                    let ecodedMessageClosedChans = try oneValueClosedChans.encode()
                    jsonArrayClosedChans.append(ecodedMessageClosedChans)
                }
                jsonMap["closedChans"] = jsonArrayClosedChans
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.GraphTopologyUpdate {
            return try Lnrpc.GraphTopologyUpdate.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.GraphTopologyUpdate {
            return try Lnrpc.GraphTopologyUpdate.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var nodeUpdatesElementIndex:Int = 0
            for oneElementNodeUpdates in nodeUpdates {
                output += "\(indent) nodeUpdates[\(nodeUpdatesElementIndex)] {\n"
                output += try oneElementNodeUpdates.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                nodeUpdatesElementIndex += 1
            }
            var channelUpdatesElementIndex:Int = 0
            for oneElementChannelUpdates in channelUpdates {
                output += "\(indent) channelUpdates[\(channelUpdatesElementIndex)] {\n"
                output += try oneElementChannelUpdates.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                channelUpdatesElementIndex += 1
            }
            var closedChansElementIndex:Int = 0
            for oneElementClosedChans in closedChans {
                output += "\(indent) closedChans[\(closedChansElementIndex)] {\n"
                output += try oneElementClosedChans.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                closedChansElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementNodeUpdates in nodeUpdates {
                    hashCode = (hashCode &* 31) &+ oneElementNodeUpdates.hashValue
                }
                for oneElementChannelUpdates in channelUpdates {
                    hashCode = (hashCode &* 31) &+ oneElementChannelUpdates.hashValue
                }
                for oneElementClosedChans in closedChans {
                    hashCode = (hashCode &* 31) &+ oneElementClosedChans.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.GraphTopologyUpdate"
        }
        override public func className() -> String {
            return "Lnrpc.GraphTopologyUpdate"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.GraphTopologyUpdate = Lnrpc.GraphTopologyUpdate()
            public func getMessage() -> Lnrpc.GraphTopologyUpdate {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var nodeUpdates:Array<Lnrpc.NodeUpdate> {
                get {
                    return builderResult.nodeUpdates
                }
                set (value) {
                    builderResult.nodeUpdates = value
                }
            }
            @discardableResult
            public func setNodeUpdates(_ value:Array<Lnrpc.NodeUpdate>) -> Lnrpc.GraphTopologyUpdate.Builder {
                self.nodeUpdates = value
                return self
            }
            @discardableResult
            public func clearNodeUpdates() -> Lnrpc.GraphTopologyUpdate.Builder {
                builderResult.nodeUpdates.removeAll(keepingCapacity: false)
                return self
            }
            public var channelUpdates:Array<Lnrpc.ChannelEdgeUpdate> {
                get {
                    return builderResult.channelUpdates
                }
                set (value) {
                    builderResult.channelUpdates = value
                }
            }
            @discardableResult
            public func setChannelUpdates(_ value:Array<Lnrpc.ChannelEdgeUpdate>) -> Lnrpc.GraphTopologyUpdate.Builder {
                self.channelUpdates = value
                return self
            }
            @discardableResult
            public func clearChannelUpdates() -> Lnrpc.GraphTopologyUpdate.Builder {
                builderResult.channelUpdates.removeAll(keepingCapacity: false)
                return self
            }
            public var closedChans:Array<Lnrpc.ClosedChannelUpdate> {
                get {
                    return builderResult.closedChans
                }
                set (value) {
                    builderResult.closedChans = value
                }
            }
            @discardableResult
            public func setClosedChans(_ value:Array<Lnrpc.ClosedChannelUpdate>) -> Lnrpc.GraphTopologyUpdate.Builder {
                self.closedChans = value
                return self
            }
            @discardableResult
            public func clearClosedChans() -> Lnrpc.GraphTopologyUpdate.Builder {
                builderResult.closedChans.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.GraphTopologyUpdate.Builder {
                builderResult = Lnrpc.GraphTopologyUpdate()
                return self
            }
            override public func clone() throws -> Lnrpc.GraphTopologyUpdate.Builder {
                return try Lnrpc.GraphTopologyUpdate.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.GraphTopologyUpdate {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.GraphTopologyUpdate {
                let returnMe:Lnrpc.GraphTopologyUpdate = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.GraphTopologyUpdate) throws -> Lnrpc.GraphTopologyUpdate.Builder {
                if other == Lnrpc.GraphTopologyUpdate() {
                    return self
                }
                if !other.nodeUpdates.isEmpty  {
                     builderResult.nodeUpdates += other.nodeUpdates
                }
                if !other.channelUpdates.isEmpty  {
                     builderResult.channelUpdates += other.channelUpdates
                }
                if !other.closedChans.isEmpty  {
                     builderResult.closedChans += other.closedChans
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.GraphTopologyUpdate.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GraphTopologyUpdate.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Lnrpc.NodeUpdate.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        nodeUpdates.append(subBuilder.buildPartial())

                    case 18:
                        let subBuilder = Lnrpc.ChannelEdgeUpdate.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        channelUpdates.append(subBuilder.buildPartial())

                    case 26:
                        let subBuilder = Lnrpc.ClosedChannelUpdate.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        closedChans.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.GraphTopologyUpdate.Builder {
                let resultDecodedBuilder = Lnrpc.GraphTopologyUpdate.Builder()
                if let jsonValueNodeUpdates = jsonMap["nodeUpdates"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayNodeUpdates:Array<Lnrpc.NodeUpdate> = []
                    for oneValueNodeUpdates in jsonValueNodeUpdates {
                        let messageFromStringNodeUpdates = try Lnrpc.NodeUpdate.Builder.decodeToBuilder(jsonMap:oneValueNodeUpdates).build()

                        jsonArrayNodeUpdates.append(messageFromStringNodeUpdates)
                    }
                    resultDecodedBuilder.nodeUpdates = jsonArrayNodeUpdates
                }
                if let jsonValueChannelUpdates = jsonMap["channelUpdates"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayChannelUpdates:Array<Lnrpc.ChannelEdgeUpdate> = []
                    for oneValueChannelUpdates in jsonValueChannelUpdates {
                        let messageFromStringChannelUpdates = try Lnrpc.ChannelEdgeUpdate.Builder.decodeToBuilder(jsonMap:oneValueChannelUpdates).build()

                        jsonArrayChannelUpdates.append(messageFromStringChannelUpdates)
                    }
                    resultDecodedBuilder.channelUpdates = jsonArrayChannelUpdates
                }
                if let jsonValueClosedChans = jsonMap["closedChans"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayClosedChans:Array<Lnrpc.ClosedChannelUpdate> = []
                    for oneValueClosedChans in jsonValueClosedChans {
                        let messageFromStringClosedChans = try Lnrpc.ClosedChannelUpdate.Builder.decodeToBuilder(jsonMap:oneValueClosedChans).build()

                        jsonArrayClosedChans.append(messageFromStringClosedChans)
                    }
                    resultDecodedBuilder.closedChans = jsonArrayClosedChans
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.GraphTopologyUpdate.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.GraphTopologyUpdate.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class NodeUpdate : GeneratedMessage {
        public typealias BuilderType = Lnrpc.NodeUpdate.Builder

        public static func == (lhs: Lnrpc.NodeUpdate, rhs: Lnrpc.NodeUpdate) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.addresses == rhs.addresses)
            fieldCheck = fieldCheck && (lhs.hasIdentityKey == rhs.hasIdentityKey) && (!lhs.hasIdentityKey || lhs.identityKey == rhs.identityKey)
            fieldCheck = fieldCheck && (lhs.hasGlobalFeatures == rhs.hasGlobalFeatures) && (!lhs.hasGlobalFeatures || lhs.globalFeatures == rhs.globalFeatures)
            fieldCheck = fieldCheck && (lhs.hasAlias == rhs.hasAlias) && (!lhs.hasAlias || lhs.alias == rhs.alias)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var addresses:Array<String> = Array<String>()
        public fileprivate(set) var identityKey:String! = nil
        public fileprivate(set) var hasIdentityKey:Bool = false

        public fileprivate(set) var globalFeatures:Data! = nil
        public fileprivate(set) var hasGlobalFeatures:Bool = false

        public fileprivate(set) var alias:String! = nil
        public fileprivate(set) var hasAlias:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if !addresses.isEmpty {
                for oneValueaddresses in addresses {
                    try codedOutputStream.writeString(fieldNumber: 1, value:oneValueaddresses)
                }
            }
            if hasIdentityKey {
                try codedOutputStream.writeString(fieldNumber: 2, value:identityKey)
            }
            if hasGlobalFeatures {
                try codedOutputStream.writeData(fieldNumber: 3, value:globalFeatures)
            }
            if hasAlias {
                try codedOutputStream.writeString(fieldNumber: 4, value:alias)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            var dataSizeAddresses:Int32 = 0
            for oneValueaddresses in addresses {
                dataSizeAddresses += oneValueaddresses.computeStringSizeNoTag()
            }
            serialize_size += dataSizeAddresses
            serialize_size += 1 * Int32(addresses.count)
            if hasIdentityKey {
                serialize_size += identityKey.computeStringSize(fieldNumber: 2)
            }
            if hasGlobalFeatures {
                serialize_size += globalFeatures.computeDataSize(fieldNumber: 3)
            }
            if hasAlias {
                serialize_size += alias.computeStringSize(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.NodeUpdate.Builder {
            return Lnrpc.NodeUpdate.classBuilder() as! Lnrpc.NodeUpdate.Builder
        }
        public func getBuilder() -> Lnrpc.NodeUpdate.Builder {
            return classBuilder() as! Lnrpc.NodeUpdate.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.NodeUpdate.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.NodeUpdate.Builder()
        }
        public func toBuilder() throws -> Lnrpc.NodeUpdate.Builder {
            return try Lnrpc.NodeUpdate.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.NodeUpdate) throws -> Lnrpc.NodeUpdate.Builder {
            return try Lnrpc.NodeUpdate.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !addresses.isEmpty {
                var jsonArrayAddresses:Array<String> = []
                for oneValueAddresses in addresses {
                    jsonArrayAddresses.append(oneValueAddresses)
                }
                jsonMap["addresses"] = jsonArrayAddresses
            }
            if hasIdentityKey {
                jsonMap["identityKey"] = identityKey
            }
            if hasGlobalFeatures {
                jsonMap["globalFeatures"] = globalFeatures.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasAlias {
                jsonMap["alias"] = alias
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.NodeUpdate {
            return try Lnrpc.NodeUpdate.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.NodeUpdate {
            return try Lnrpc.NodeUpdate.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var addressesElementIndex:Int = 0
            for oneValueAddresses in addresses  {
                output += "\(indent) addresses[\(addressesElementIndex)]: \(oneValueAddresses)\n"
                addressesElementIndex += 1
            }
            if hasIdentityKey {
                output += "\(indent) identityKey: \(identityKey) \n"
            }
            if hasGlobalFeatures {
                output += "\(indent) globalFeatures: \(globalFeatures) \n"
            }
            if hasAlias {
                output += "\(indent) alias: \(alias) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValueAddresses in addresses {
                    hashCode = (hashCode &* 31) &+ oneValueAddresses.hashValue
                }
                if hasIdentityKey {
                    hashCode = (hashCode &* 31) &+ identityKey.hashValue
                }
                if hasGlobalFeatures {
                    hashCode = (hashCode &* 31) &+ globalFeatures.hashValue
                }
                if hasAlias {
                    hashCode = (hashCode &* 31) &+ alias.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.NodeUpdate"
        }
        override public func className() -> String {
            return "Lnrpc.NodeUpdate"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.NodeUpdate = Lnrpc.NodeUpdate()
            public func getMessage() -> Lnrpc.NodeUpdate {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var addresses:Array<String> {
                get {
                    return builderResult.addresses
                }
                set (array) {
                    builderResult.addresses = array
                }
            }
            @discardableResult
            public func setAddresses(_ value:Array<String>) -> Lnrpc.NodeUpdate.Builder {
                self.addresses = value
                return self
            }
            @discardableResult
            public func clearAddresses() -> Lnrpc.NodeUpdate.Builder {
                builderResult.addresses.removeAll(keepingCapacity: false)
                return self
            }
            public var identityKey:String {
                get {
                    return builderResult.identityKey
                }
                set (value) {
                    builderResult.hasIdentityKey = true
                    builderResult.identityKey = value
                }
            }
            public var hasIdentityKey:Bool {
                get {
                    return builderResult.hasIdentityKey
                }
            }
            @discardableResult
            public func setIdentityKey(_ value:String) -> Lnrpc.NodeUpdate.Builder {
                self.identityKey = value
                return self
            }
            @discardableResult
            public func clearIdentityKey() -> Lnrpc.NodeUpdate.Builder{
                builderResult.hasIdentityKey = false
                builderResult.identityKey = nil
                return self
            }
            public var globalFeatures:Data {
                get {
                    return builderResult.globalFeatures
                }
                set (value) {
                    builderResult.hasGlobalFeatures = true
                    builderResult.globalFeatures = value
                }
            }
            public var hasGlobalFeatures:Bool {
                get {
                    return builderResult.hasGlobalFeatures
                }
            }
            @discardableResult
            public func setGlobalFeatures(_ value:Data) -> Lnrpc.NodeUpdate.Builder {
                self.globalFeatures = value
                return self
            }
            @discardableResult
            public func clearGlobalFeatures() -> Lnrpc.NodeUpdate.Builder{
                builderResult.hasGlobalFeatures = false
                builderResult.globalFeatures = nil
                return self
            }
            public var alias:String {
                get {
                    return builderResult.alias
                }
                set (value) {
                    builderResult.hasAlias = true
                    builderResult.alias = value
                }
            }
            public var hasAlias:Bool {
                get {
                    return builderResult.hasAlias
                }
            }
            @discardableResult
            public func setAlias(_ value:String) -> Lnrpc.NodeUpdate.Builder {
                self.alias = value
                return self
            }
            @discardableResult
            public func clearAlias() -> Lnrpc.NodeUpdate.Builder{
                builderResult.hasAlias = false
                builderResult.alias = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.NodeUpdate.Builder {
                builderResult = Lnrpc.NodeUpdate()
                return self
            }
            override public func clone() throws -> Lnrpc.NodeUpdate.Builder {
                return try Lnrpc.NodeUpdate.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.NodeUpdate {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.NodeUpdate {
                let returnMe:Lnrpc.NodeUpdate = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.NodeUpdate) throws -> Lnrpc.NodeUpdate.Builder {
                if other == Lnrpc.NodeUpdate() {
                    return self
                }
                if !other.addresses.isEmpty {
                    builderResult.addresses += other.addresses
                }
                if other.hasIdentityKey {
                    identityKey = other.identityKey
                }
                if other.hasGlobalFeatures {
                    globalFeatures = other.globalFeatures
                }
                if other.hasAlias {
                    alias = other.alias
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.NodeUpdate.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NodeUpdate.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        addresses += [try codedInputStream.readString()]

                    case 18:
                        identityKey = try codedInputStream.readString()

                    case 26:
                        globalFeatures = try codedInputStream.readData()

                    case 34:
                        alias = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.NodeUpdate.Builder {
                let resultDecodedBuilder = Lnrpc.NodeUpdate.Builder()
                if let jsonValueAddresses = jsonMap["addresses"] as? Array<String> {
                    var jsonArrayAddresses:Array<String> = []
                    for oneValueAddresses in jsonValueAddresses {
                        jsonArrayAddresses.append(oneValueAddresses)
                    }
                    resultDecodedBuilder.addresses = jsonArrayAddresses
                }
                if let jsonValueIdentityKey = jsonMap["identityKey"] as? String {
                    resultDecodedBuilder.identityKey = jsonValueIdentityKey
                }
                if let jsonValueGlobalFeatures = jsonMap["globalFeatures"] as? String {
                    resultDecodedBuilder.globalFeatures = Data(base64Encoded:jsonValueGlobalFeatures, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueAlias = jsonMap["alias"] as? String {
                    resultDecodedBuilder.alias = jsonValueAlias
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.NodeUpdate.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.NodeUpdate.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ChannelEdgeUpdate : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ChannelEdgeUpdate.Builder

        public static func == (lhs: Lnrpc.ChannelEdgeUpdate, rhs: Lnrpc.ChannelEdgeUpdate) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasChanId == rhs.hasChanId) && (!lhs.hasChanId || lhs.chanId == rhs.chanId)
            fieldCheck = fieldCheck && (lhs.hasChanPoint == rhs.hasChanPoint) && (!lhs.hasChanPoint || lhs.chanPoint == rhs.chanPoint)
            fieldCheck = fieldCheck && (lhs.hasCapacity == rhs.hasCapacity) && (!lhs.hasCapacity || lhs.capacity == rhs.capacity)
            fieldCheck = fieldCheck && (lhs.hasRoutingPolicy == rhs.hasRoutingPolicy) && (!lhs.hasRoutingPolicy || lhs.routingPolicy == rhs.routingPolicy)
            fieldCheck = fieldCheck && (lhs.hasAdvertisingNode == rhs.hasAdvertisingNode) && (!lhs.hasAdvertisingNode || lhs.advertisingNode == rhs.advertisingNode)
            fieldCheck = fieldCheck && (lhs.hasConnectingNode == rhs.hasConnectingNode) && (!lhs.hasConnectingNode || lhs.connectingNode == rhs.connectingNode)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///*
        ///The unique channel ID for the channel. The first 3 bytes are the block
        ///height, the next 3 the index within the block, and the last 2 bytes are the
        ///output index for the channel.
        public fileprivate(set) var chanId:UInt64! = nil
        public fileprivate(set) var hasChanId:Bool = false

        public fileprivate(set) var chanPoint:Lnrpc.ChannelPoint!
        public fileprivate(set) var hasChanPoint:Bool = false
        public fileprivate(set) var capacity:Int64! = nil
        public fileprivate(set) var hasCapacity:Bool = false

        public fileprivate(set) var routingPolicy:Lnrpc.RoutingPolicy!
        public fileprivate(set) var hasRoutingPolicy:Bool = false
        public fileprivate(set) var advertisingNode:String! = nil
        public fileprivate(set) var hasAdvertisingNode:Bool = false

        public fileprivate(set) var connectingNode:String! = nil
        public fileprivate(set) var hasConnectingNode:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasChanId {
                try codedOutputStream.writeUInt64(fieldNumber: 1, value:chanId)
            }
            if hasChanPoint {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:chanPoint)
            }
            if hasCapacity {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:capacity)
            }
            if hasRoutingPolicy {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:routingPolicy)
            }
            if hasAdvertisingNode {
                try codedOutputStream.writeString(fieldNumber: 5, value:advertisingNode)
            }
            if hasConnectingNode {
                try codedOutputStream.writeString(fieldNumber: 6, value:connectingNode)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasChanId {
                serialize_size += chanId.computeUInt64Size(fieldNumber: 1)
            }
            if hasChanPoint {
                if let varSizechanPoint = chanPoint?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizechanPoint
                }
            }
            if hasCapacity {
                serialize_size += capacity.computeInt64Size(fieldNumber: 3)
            }
            if hasRoutingPolicy {
                if let varSizeroutingPolicy = routingPolicy?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizeroutingPolicy
                }
            }
            if hasAdvertisingNode {
                serialize_size += advertisingNode.computeStringSize(fieldNumber: 5)
            }
            if hasConnectingNode {
                serialize_size += connectingNode.computeStringSize(fieldNumber: 6)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ChannelEdgeUpdate.Builder {
            return Lnrpc.ChannelEdgeUpdate.classBuilder() as! Lnrpc.ChannelEdgeUpdate.Builder
        }
        public func getBuilder() -> Lnrpc.ChannelEdgeUpdate.Builder {
            return classBuilder() as! Lnrpc.ChannelEdgeUpdate.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChannelEdgeUpdate.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChannelEdgeUpdate.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ChannelEdgeUpdate.Builder {
            return try Lnrpc.ChannelEdgeUpdate.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ChannelEdgeUpdate) throws -> Lnrpc.ChannelEdgeUpdate.Builder {
            return try Lnrpc.ChannelEdgeUpdate.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasChanId {
                jsonMap["chanId"] = "\(chanId!)"
            }
            if hasChanPoint {
                jsonMap["chanPoint"] = try chanPoint.encode()
            }
            if hasCapacity {
                jsonMap["capacity"] = "\(capacity!)"
            }
            if hasRoutingPolicy {
                jsonMap["routingPolicy"] = try routingPolicy.encode()
            }
            if hasAdvertisingNode {
                jsonMap["advertisingNode"] = advertisingNode
            }
            if hasConnectingNode {
                jsonMap["connectingNode"] = connectingNode
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChannelEdgeUpdate {
            return try Lnrpc.ChannelEdgeUpdate.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChannelEdgeUpdate {
            return try Lnrpc.ChannelEdgeUpdate.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasChanId {
                output += "\(indent) chanId: \(chanId) \n"
            }
            if hasChanPoint {
                output += "\(indent) chanPoint {\n"
                if let outDescChanPoint = chanPoint {
                    output += try outDescChanPoint.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasCapacity {
                output += "\(indent) capacity: \(capacity) \n"
            }
            if hasRoutingPolicy {
                output += "\(indent) routingPolicy {\n"
                if let outDescRoutingPolicy = routingPolicy {
                    output += try outDescRoutingPolicy.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasAdvertisingNode {
                output += "\(indent) advertisingNode: \(advertisingNode) \n"
            }
            if hasConnectingNode {
                output += "\(indent) connectingNode: \(connectingNode) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasChanId {
                    hashCode = (hashCode &* 31) &+ chanId.hashValue
                }
                if hasChanPoint {
                    if let hashValuechanPoint = chanPoint?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuechanPoint
                    }
                }
                if hasCapacity {
                    hashCode = (hashCode &* 31) &+ capacity.hashValue
                }
                if hasRoutingPolicy {
                    if let hashValueroutingPolicy = routingPolicy?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueroutingPolicy
                    }
                }
                if hasAdvertisingNode {
                    hashCode = (hashCode &* 31) &+ advertisingNode.hashValue
                }
                if hasConnectingNode {
                    hashCode = (hashCode &* 31) &+ connectingNode.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ChannelEdgeUpdate"
        }
        override public func className() -> String {
            return "Lnrpc.ChannelEdgeUpdate"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ChannelEdgeUpdate = Lnrpc.ChannelEdgeUpdate()
            public func getMessage() -> Lnrpc.ChannelEdgeUpdate {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///*
            ///The unique channel ID for the channel. The first 3 bytes are the block
            ///height, the next 3 the index within the block, and the last 2 bytes are the
            ///output index for the channel.
            public var chanId:UInt64 {
                get {
                    return builderResult.chanId
                }
                set (value) {
                    builderResult.hasChanId = true
                    builderResult.chanId = value
                }
            }
            public var hasChanId:Bool {
                get {
                    return builderResult.hasChanId
                }
            }
            @discardableResult
            public func setChanId(_ value:UInt64) -> Lnrpc.ChannelEdgeUpdate.Builder {
                self.chanId = value
                return self
            }
            @discardableResult
            public func clearChanId() -> Lnrpc.ChannelEdgeUpdate.Builder{
                builderResult.hasChanId = false
                builderResult.chanId = nil
                return self
            }
            public var chanPoint:Lnrpc.ChannelPoint! {
                get {
                    if chanPointBuilder_ != nil {
                        builderResult.chanPoint = chanPointBuilder_.getMessage()
                    }
                    return builderResult.chanPoint
                }
                set (value) {
                    builderResult.hasChanPoint = value != nil
                    builderResult.chanPoint = value
                }
            }
            public var hasChanPoint:Bool {
                get {
                    return builderResult.hasChanPoint
                }
            }
            fileprivate var chanPointBuilder_:Lnrpc.ChannelPoint.Builder! {
                didSet {
                    builderResult.hasChanPoint = true
                }
            }
            public func getChanPointBuilder() -> Lnrpc.ChannelPoint.Builder {
                if chanPointBuilder_ == nil {
                    chanPointBuilder_ = Lnrpc.ChannelPoint.Builder()
                    builderResult.chanPoint = chanPointBuilder_.getMessage()
                    if chanPoint != nil {
                        try! chanPointBuilder_.mergeFrom(other: chanPoint)
                    }
                }
                return chanPointBuilder_
            }
            @discardableResult
            public func setChanPoint(_ value:Lnrpc.ChannelPoint!) -> Lnrpc.ChannelEdgeUpdate.Builder {
                self.chanPoint = value
                return self
            }
            @discardableResult
            public func mergeChanPoint(value:Lnrpc.ChannelPoint) throws -> Lnrpc.ChannelEdgeUpdate.Builder {
                if builderResult.hasChanPoint {
                    builderResult.chanPoint = try Lnrpc.ChannelPoint.builderWithPrototype(prototype:builderResult.chanPoint).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.chanPoint = value
                }
                builderResult.hasChanPoint = true
                return self
            }
            @discardableResult
            public func clearChanPoint() -> Lnrpc.ChannelEdgeUpdate.Builder {
                chanPointBuilder_ = nil
                builderResult.hasChanPoint = false
                builderResult.chanPoint = nil
                return self
            }
            public var capacity:Int64 {
                get {
                    return builderResult.capacity
                }
                set (value) {
                    builderResult.hasCapacity = true
                    builderResult.capacity = value
                }
            }
            public var hasCapacity:Bool {
                get {
                    return builderResult.hasCapacity
                }
            }
            @discardableResult
            public func setCapacity(_ value:Int64) -> Lnrpc.ChannelEdgeUpdate.Builder {
                self.capacity = value
                return self
            }
            @discardableResult
            public func clearCapacity() -> Lnrpc.ChannelEdgeUpdate.Builder{
                builderResult.hasCapacity = false
                builderResult.capacity = nil
                return self
            }
            public var routingPolicy:Lnrpc.RoutingPolicy! {
                get {
                    if routingPolicyBuilder_ != nil {
                        builderResult.routingPolicy = routingPolicyBuilder_.getMessage()
                    }
                    return builderResult.routingPolicy
                }
                set (value) {
                    builderResult.hasRoutingPolicy = value != nil
                    builderResult.routingPolicy = value
                }
            }
            public var hasRoutingPolicy:Bool {
                get {
                    return builderResult.hasRoutingPolicy
                }
            }
            fileprivate var routingPolicyBuilder_:Lnrpc.RoutingPolicy.Builder! {
                didSet {
                    builderResult.hasRoutingPolicy = true
                }
            }
            public func getRoutingPolicyBuilder() -> Lnrpc.RoutingPolicy.Builder {
                if routingPolicyBuilder_ == nil {
                    routingPolicyBuilder_ = Lnrpc.RoutingPolicy.Builder()
                    builderResult.routingPolicy = routingPolicyBuilder_.getMessage()
                    if routingPolicy != nil {
                        try! routingPolicyBuilder_.mergeFrom(other: routingPolicy)
                    }
                }
                return routingPolicyBuilder_
            }
            @discardableResult
            public func setRoutingPolicy(_ value:Lnrpc.RoutingPolicy!) -> Lnrpc.ChannelEdgeUpdate.Builder {
                self.routingPolicy = value
                return self
            }
            @discardableResult
            public func mergeRoutingPolicy(value:Lnrpc.RoutingPolicy) throws -> Lnrpc.ChannelEdgeUpdate.Builder {
                if builderResult.hasRoutingPolicy {
                    builderResult.routingPolicy = try Lnrpc.RoutingPolicy.builderWithPrototype(prototype:builderResult.routingPolicy).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.routingPolicy = value
                }
                builderResult.hasRoutingPolicy = true
                return self
            }
            @discardableResult
            public func clearRoutingPolicy() -> Lnrpc.ChannelEdgeUpdate.Builder {
                routingPolicyBuilder_ = nil
                builderResult.hasRoutingPolicy = false
                builderResult.routingPolicy = nil
                return self
            }
            public var advertisingNode:String {
                get {
                    return builderResult.advertisingNode
                }
                set (value) {
                    builderResult.hasAdvertisingNode = true
                    builderResult.advertisingNode = value
                }
            }
            public var hasAdvertisingNode:Bool {
                get {
                    return builderResult.hasAdvertisingNode
                }
            }
            @discardableResult
            public func setAdvertisingNode(_ value:String) -> Lnrpc.ChannelEdgeUpdate.Builder {
                self.advertisingNode = value
                return self
            }
            @discardableResult
            public func clearAdvertisingNode() -> Lnrpc.ChannelEdgeUpdate.Builder{
                builderResult.hasAdvertisingNode = false
                builderResult.advertisingNode = nil
                return self
            }
            public var connectingNode:String {
                get {
                    return builderResult.connectingNode
                }
                set (value) {
                    builderResult.hasConnectingNode = true
                    builderResult.connectingNode = value
                }
            }
            public var hasConnectingNode:Bool {
                get {
                    return builderResult.hasConnectingNode
                }
            }
            @discardableResult
            public func setConnectingNode(_ value:String) -> Lnrpc.ChannelEdgeUpdate.Builder {
                self.connectingNode = value
                return self
            }
            @discardableResult
            public func clearConnectingNode() -> Lnrpc.ChannelEdgeUpdate.Builder{
                builderResult.hasConnectingNode = false
                builderResult.connectingNode = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ChannelEdgeUpdate.Builder {
                builderResult = Lnrpc.ChannelEdgeUpdate()
                return self
            }
            override public func clone() throws -> Lnrpc.ChannelEdgeUpdate.Builder {
                return try Lnrpc.ChannelEdgeUpdate.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ChannelEdgeUpdate {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ChannelEdgeUpdate {
                let returnMe:Lnrpc.ChannelEdgeUpdate = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ChannelEdgeUpdate) throws -> Lnrpc.ChannelEdgeUpdate.Builder {
                if other == Lnrpc.ChannelEdgeUpdate() {
                    return self
                }
                if other.hasChanId {
                    chanId = other.chanId
                }
                if (other.hasChanPoint) {
                    try mergeChanPoint(value: other.chanPoint)
                }
                if other.hasCapacity {
                    capacity = other.capacity
                }
                if (other.hasRoutingPolicy) {
                    try mergeRoutingPolicy(value: other.routingPolicy)
                }
                if other.hasAdvertisingNode {
                    advertisingNode = other.advertisingNode
                }
                if other.hasConnectingNode {
                    connectingNode = other.connectingNode
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChannelEdgeUpdate.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelEdgeUpdate.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        chanId = try codedInputStream.readUInt64()

                    case 18:
                        let subBuilder:Lnrpc.ChannelPoint.Builder = Lnrpc.ChannelPoint.Builder()
                        if hasChanPoint {
                            try subBuilder.mergeFrom(other: chanPoint)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        chanPoint = subBuilder.buildPartial()

                    case 24:
                        capacity = try codedInputStream.readInt64()

                    case 34:
                        let subBuilder:Lnrpc.RoutingPolicy.Builder = Lnrpc.RoutingPolicy.Builder()
                        if hasRoutingPolicy {
                            try subBuilder.mergeFrom(other: routingPolicy)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        routingPolicy = subBuilder.buildPartial()

                    case 42:
                        advertisingNode = try codedInputStream.readString()

                    case 50:
                        connectingNode = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChannelEdgeUpdate.Builder {
                let resultDecodedBuilder = Lnrpc.ChannelEdgeUpdate.Builder()
                if let jsonValueChanId = jsonMap["chanId"] as? String {
                    resultDecodedBuilder.chanId = UInt64(jsonValueChanId)!
                } else if let jsonValueChanId = jsonMap["chanId"] as? UInt {
                    resultDecodedBuilder.chanId = UInt64(jsonValueChanId)
                }
                if let jsonValueChanPoint = jsonMap["chanPoint"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.chanPoint = try Lnrpc.ChannelPoint.Builder.decodeToBuilder(jsonMap:jsonValueChanPoint).build()

                }
                if let jsonValueCapacity = jsonMap["capacity"] as? String {
                    resultDecodedBuilder.capacity = Int64(jsonValueCapacity)!
                } else if let jsonValueCapacity = jsonMap["capacity"] as? Int {
                    resultDecodedBuilder.capacity = Int64(jsonValueCapacity)
                }
                if let jsonValueRoutingPolicy = jsonMap["routingPolicy"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.routingPolicy = try Lnrpc.RoutingPolicy.Builder.decodeToBuilder(jsonMap:jsonValueRoutingPolicy).build()

                }
                if let jsonValueAdvertisingNode = jsonMap["advertisingNode"] as? String {
                    resultDecodedBuilder.advertisingNode = jsonValueAdvertisingNode
                }
                if let jsonValueConnectingNode = jsonMap["connectingNode"] as? String {
                    resultDecodedBuilder.connectingNode = jsonValueConnectingNode
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChannelEdgeUpdate.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ChannelEdgeUpdate.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ClosedChannelUpdate : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ClosedChannelUpdate.Builder

        public static func == (lhs: Lnrpc.ClosedChannelUpdate, rhs: Lnrpc.ClosedChannelUpdate) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasChanId == rhs.hasChanId) && (!lhs.hasChanId || lhs.chanId == rhs.chanId)
            fieldCheck = fieldCheck && (lhs.hasCapacity == rhs.hasCapacity) && (!lhs.hasCapacity || lhs.capacity == rhs.capacity)
            fieldCheck = fieldCheck && (lhs.hasClosedHeight == rhs.hasClosedHeight) && (!lhs.hasClosedHeight || lhs.closedHeight == rhs.closedHeight)
            fieldCheck = fieldCheck && (lhs.hasChanPoint == rhs.hasChanPoint) && (!lhs.hasChanPoint || lhs.chanPoint == rhs.chanPoint)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///*
        ///The unique channel ID for the channel. The first 3 bytes are the block
        ///height, the next 3 the index within the block, and the last 2 bytes are the
        ///output index for the channel.
        public fileprivate(set) var chanId:UInt64! = nil
        public fileprivate(set) var hasChanId:Bool = false

        public fileprivate(set) var capacity:Int64! = nil
        public fileprivate(set) var hasCapacity:Bool = false

        public fileprivate(set) var closedHeight:UInt32! = nil
        public fileprivate(set) var hasClosedHeight:Bool = false

        public fileprivate(set) var chanPoint:Lnrpc.ChannelPoint!
        public fileprivate(set) var hasChanPoint:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasChanId {
                try codedOutputStream.writeUInt64(fieldNumber: 1, value:chanId)
            }
            if hasCapacity {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:capacity)
            }
            if hasClosedHeight {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:closedHeight)
            }
            if hasChanPoint {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:chanPoint)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasChanId {
                serialize_size += chanId.computeUInt64Size(fieldNumber: 1)
            }
            if hasCapacity {
                serialize_size += capacity.computeInt64Size(fieldNumber: 2)
            }
            if hasClosedHeight {
                serialize_size += closedHeight.computeUInt32Size(fieldNumber: 3)
            }
            if hasChanPoint {
                if let varSizechanPoint = chanPoint?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizechanPoint
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ClosedChannelUpdate.Builder {
            return Lnrpc.ClosedChannelUpdate.classBuilder() as! Lnrpc.ClosedChannelUpdate.Builder
        }
        public func getBuilder() -> Lnrpc.ClosedChannelUpdate.Builder {
            return classBuilder() as! Lnrpc.ClosedChannelUpdate.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ClosedChannelUpdate.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ClosedChannelUpdate.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ClosedChannelUpdate.Builder {
            return try Lnrpc.ClosedChannelUpdate.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ClosedChannelUpdate) throws -> Lnrpc.ClosedChannelUpdate.Builder {
            return try Lnrpc.ClosedChannelUpdate.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasChanId {
                jsonMap["chanId"] = "\(chanId!)"
            }
            if hasCapacity {
                jsonMap["capacity"] = "\(capacity!)"
            }
            if hasClosedHeight {
                jsonMap["closedHeight"] = UInt(closedHeight)
            }
            if hasChanPoint {
                jsonMap["chanPoint"] = try chanPoint.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ClosedChannelUpdate {
            return try Lnrpc.ClosedChannelUpdate.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ClosedChannelUpdate {
            return try Lnrpc.ClosedChannelUpdate.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasChanId {
                output += "\(indent) chanId: \(chanId) \n"
            }
            if hasCapacity {
                output += "\(indent) capacity: \(capacity) \n"
            }
            if hasClosedHeight {
                output += "\(indent) closedHeight: \(closedHeight) \n"
            }
            if hasChanPoint {
                output += "\(indent) chanPoint {\n"
                if let outDescChanPoint = chanPoint {
                    output += try outDescChanPoint.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasChanId {
                    hashCode = (hashCode &* 31) &+ chanId.hashValue
                }
                if hasCapacity {
                    hashCode = (hashCode &* 31) &+ capacity.hashValue
                }
                if hasClosedHeight {
                    hashCode = (hashCode &* 31) &+ closedHeight.hashValue
                }
                if hasChanPoint {
                    if let hashValuechanPoint = chanPoint?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuechanPoint
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ClosedChannelUpdate"
        }
        override public func className() -> String {
            return "Lnrpc.ClosedChannelUpdate"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ClosedChannelUpdate = Lnrpc.ClosedChannelUpdate()
            public func getMessage() -> Lnrpc.ClosedChannelUpdate {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///*
            ///The unique channel ID for the channel. The first 3 bytes are the block
            ///height, the next 3 the index within the block, and the last 2 bytes are the
            ///output index for the channel.
            public var chanId:UInt64 {
                get {
                    return builderResult.chanId
                }
                set (value) {
                    builderResult.hasChanId = true
                    builderResult.chanId = value
                }
            }
            public var hasChanId:Bool {
                get {
                    return builderResult.hasChanId
                }
            }
            @discardableResult
            public func setChanId(_ value:UInt64) -> Lnrpc.ClosedChannelUpdate.Builder {
                self.chanId = value
                return self
            }
            @discardableResult
            public func clearChanId() -> Lnrpc.ClosedChannelUpdate.Builder{
                builderResult.hasChanId = false
                builderResult.chanId = nil
                return self
            }
            public var capacity:Int64 {
                get {
                    return builderResult.capacity
                }
                set (value) {
                    builderResult.hasCapacity = true
                    builderResult.capacity = value
                }
            }
            public var hasCapacity:Bool {
                get {
                    return builderResult.hasCapacity
                }
            }
            @discardableResult
            public func setCapacity(_ value:Int64) -> Lnrpc.ClosedChannelUpdate.Builder {
                self.capacity = value
                return self
            }
            @discardableResult
            public func clearCapacity() -> Lnrpc.ClosedChannelUpdate.Builder{
                builderResult.hasCapacity = false
                builderResult.capacity = nil
                return self
            }
            public var closedHeight:UInt32 {
                get {
                    return builderResult.closedHeight
                }
                set (value) {
                    builderResult.hasClosedHeight = true
                    builderResult.closedHeight = value
                }
            }
            public var hasClosedHeight:Bool {
                get {
                    return builderResult.hasClosedHeight
                }
            }
            @discardableResult
            public func setClosedHeight(_ value:UInt32) -> Lnrpc.ClosedChannelUpdate.Builder {
                self.closedHeight = value
                return self
            }
            @discardableResult
            public func clearClosedHeight() -> Lnrpc.ClosedChannelUpdate.Builder{
                builderResult.hasClosedHeight = false
                builderResult.closedHeight = nil
                return self
            }
            public var chanPoint:Lnrpc.ChannelPoint! {
                get {
                    if chanPointBuilder_ != nil {
                        builderResult.chanPoint = chanPointBuilder_.getMessage()
                    }
                    return builderResult.chanPoint
                }
                set (value) {
                    builderResult.hasChanPoint = value != nil
                    builderResult.chanPoint = value
                }
            }
            public var hasChanPoint:Bool {
                get {
                    return builderResult.hasChanPoint
                }
            }
            fileprivate var chanPointBuilder_:Lnrpc.ChannelPoint.Builder! {
                didSet {
                    builderResult.hasChanPoint = true
                }
            }
            public func getChanPointBuilder() -> Lnrpc.ChannelPoint.Builder {
                if chanPointBuilder_ == nil {
                    chanPointBuilder_ = Lnrpc.ChannelPoint.Builder()
                    builderResult.chanPoint = chanPointBuilder_.getMessage()
                    if chanPoint != nil {
                        try! chanPointBuilder_.mergeFrom(other: chanPoint)
                    }
                }
                return chanPointBuilder_
            }
            @discardableResult
            public func setChanPoint(_ value:Lnrpc.ChannelPoint!) -> Lnrpc.ClosedChannelUpdate.Builder {
                self.chanPoint = value
                return self
            }
            @discardableResult
            public func mergeChanPoint(value:Lnrpc.ChannelPoint) throws -> Lnrpc.ClosedChannelUpdate.Builder {
                if builderResult.hasChanPoint {
                    builderResult.chanPoint = try Lnrpc.ChannelPoint.builderWithPrototype(prototype:builderResult.chanPoint).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.chanPoint = value
                }
                builderResult.hasChanPoint = true
                return self
            }
            @discardableResult
            public func clearChanPoint() -> Lnrpc.ClosedChannelUpdate.Builder {
                chanPointBuilder_ = nil
                builderResult.hasChanPoint = false
                builderResult.chanPoint = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ClosedChannelUpdate.Builder {
                builderResult = Lnrpc.ClosedChannelUpdate()
                return self
            }
            override public func clone() throws -> Lnrpc.ClosedChannelUpdate.Builder {
                return try Lnrpc.ClosedChannelUpdate.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ClosedChannelUpdate {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ClosedChannelUpdate {
                let returnMe:Lnrpc.ClosedChannelUpdate = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ClosedChannelUpdate) throws -> Lnrpc.ClosedChannelUpdate.Builder {
                if other == Lnrpc.ClosedChannelUpdate() {
                    return self
                }
                if other.hasChanId {
                    chanId = other.chanId
                }
                if other.hasCapacity {
                    capacity = other.capacity
                }
                if other.hasClosedHeight {
                    closedHeight = other.closedHeight
                }
                if (other.hasChanPoint) {
                    try mergeChanPoint(value: other.chanPoint)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ClosedChannelUpdate.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ClosedChannelUpdate.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        chanId = try codedInputStream.readUInt64()

                    case 16:
                        capacity = try codedInputStream.readInt64()

                    case 24:
                        closedHeight = try codedInputStream.readUInt32()

                    case 34:
                        let subBuilder:Lnrpc.ChannelPoint.Builder = Lnrpc.ChannelPoint.Builder()
                        if hasChanPoint {
                            try subBuilder.mergeFrom(other: chanPoint)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        chanPoint = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ClosedChannelUpdate.Builder {
                let resultDecodedBuilder = Lnrpc.ClosedChannelUpdate.Builder()
                if let jsonValueChanId = jsonMap["chanId"] as? String {
                    resultDecodedBuilder.chanId = UInt64(jsonValueChanId)!
                } else if let jsonValueChanId = jsonMap["chanId"] as? UInt {
                    resultDecodedBuilder.chanId = UInt64(jsonValueChanId)
                }
                if let jsonValueCapacity = jsonMap["capacity"] as? String {
                    resultDecodedBuilder.capacity = Int64(jsonValueCapacity)!
                } else if let jsonValueCapacity = jsonMap["capacity"] as? Int {
                    resultDecodedBuilder.capacity = Int64(jsonValueCapacity)
                }
                if let jsonValueClosedHeight = jsonMap["closedHeight"] as? UInt {
                    resultDecodedBuilder.closedHeight = UInt32(jsonValueClosedHeight)
                } else if let jsonValueClosedHeight = jsonMap["closedHeight"] as? String {
                    resultDecodedBuilder.closedHeight = UInt32(jsonValueClosedHeight)!
                }
                if let jsonValueChanPoint = jsonMap["chanPoint"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.chanPoint = try Lnrpc.ChannelPoint.Builder.decodeToBuilder(jsonMap:jsonValueChanPoint).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ClosedChannelUpdate.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ClosedChannelUpdate.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class HopHint : GeneratedMessage {
        public typealias BuilderType = Lnrpc.HopHint.Builder

        public static func == (lhs: Lnrpc.HopHint, rhs: Lnrpc.HopHint) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasNodeId == rhs.hasNodeId) && (!lhs.hasNodeId || lhs.nodeId == rhs.nodeId)
            fieldCheck = fieldCheck && (lhs.hasChanId == rhs.hasChanId) && (!lhs.hasChanId || lhs.chanId == rhs.chanId)
            fieldCheck = fieldCheck && (lhs.hasFeeBaseMsat == rhs.hasFeeBaseMsat) && (!lhs.hasFeeBaseMsat || lhs.feeBaseMsat == rhs.feeBaseMsat)
            fieldCheck = fieldCheck && (lhs.hasFeeProportionalMillionths == rhs.hasFeeProportionalMillionths) && (!lhs.hasFeeProportionalMillionths || lhs.feeProportionalMillionths == rhs.feeProportionalMillionths)
            fieldCheck = fieldCheck && (lhs.hasCltvExpiryDelta == rhs.hasCltvExpiryDelta) && (!lhs.hasCltvExpiryDelta || lhs.cltvExpiryDelta == rhs.cltvExpiryDelta)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// The public key of the node at the start of the channel.
        public fileprivate(set) var nodeId:String! = nil
        public fileprivate(set) var hasNodeId:Bool = false

        //// The unique identifier of the channel.
        public fileprivate(set) var chanId:UInt64! = nil
        public fileprivate(set) var hasChanId:Bool = false

        //// The base fee of the channel denominated in millisatoshis.
        public fileprivate(set) var feeBaseMsat:UInt32! = nil
        public fileprivate(set) var hasFeeBaseMsat:Bool = false

        ///*
        ///The fee rate of the channel for sending one satoshi across it denominated in
        ///millionths of a satoshi.
        public fileprivate(set) var feeProportionalMillionths:UInt32! = nil
        public fileprivate(set) var hasFeeProportionalMillionths:Bool = false

        //// The time-lock delta of the channel.
        public fileprivate(set) var cltvExpiryDelta:UInt32! = nil
        public fileprivate(set) var hasCltvExpiryDelta:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasNodeId {
                try codedOutputStream.writeString(fieldNumber: 1, value:nodeId)
            }
            if hasChanId {
                try codedOutputStream.writeUInt64(fieldNumber: 2, value:chanId)
            }
            if hasFeeBaseMsat {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:feeBaseMsat)
            }
            if hasFeeProportionalMillionths {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:feeProportionalMillionths)
            }
            if hasCltvExpiryDelta {
                try codedOutputStream.writeUInt32(fieldNumber: 5, value:cltvExpiryDelta)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasNodeId {
                serialize_size += nodeId.computeStringSize(fieldNumber: 1)
            }
            if hasChanId {
                serialize_size += chanId.computeUInt64Size(fieldNumber: 2)
            }
            if hasFeeBaseMsat {
                serialize_size += feeBaseMsat.computeUInt32Size(fieldNumber: 3)
            }
            if hasFeeProportionalMillionths {
                serialize_size += feeProportionalMillionths.computeUInt32Size(fieldNumber: 4)
            }
            if hasCltvExpiryDelta {
                serialize_size += cltvExpiryDelta.computeUInt32Size(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.HopHint.Builder {
            return Lnrpc.HopHint.classBuilder() as! Lnrpc.HopHint.Builder
        }
        public func getBuilder() -> Lnrpc.HopHint.Builder {
            return classBuilder() as! Lnrpc.HopHint.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.HopHint.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.HopHint.Builder()
        }
        public func toBuilder() throws -> Lnrpc.HopHint.Builder {
            return try Lnrpc.HopHint.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.HopHint) throws -> Lnrpc.HopHint.Builder {
            return try Lnrpc.HopHint.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasNodeId {
                jsonMap["node_id"] = nodeId
            }
            if hasChanId {
                jsonMap["chan_id"] = "\(chanId!)"
            }
            if hasFeeBaseMsat {
                jsonMap["fee_base_msat"] = UInt(feeBaseMsat)
            }
            if hasFeeProportionalMillionths {
                jsonMap["fee_proportional_millionths"] = UInt(feeProportionalMillionths)
            }
            if hasCltvExpiryDelta {
                jsonMap["cltv_expiry_delta"] = UInt(cltvExpiryDelta)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.HopHint {
            return try Lnrpc.HopHint.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.HopHint {
            return try Lnrpc.HopHint.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasNodeId {
                output += "\(indent) nodeId: \(nodeId) \n"
            }
            if hasChanId {
                output += "\(indent) chanId: \(chanId) \n"
            }
            if hasFeeBaseMsat {
                output += "\(indent) feeBaseMsat: \(feeBaseMsat) \n"
            }
            if hasFeeProportionalMillionths {
                output += "\(indent) feeProportionalMillionths: \(feeProportionalMillionths) \n"
            }
            if hasCltvExpiryDelta {
                output += "\(indent) cltvExpiryDelta: \(cltvExpiryDelta) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasNodeId {
                    hashCode = (hashCode &* 31) &+ nodeId.hashValue
                }
                if hasChanId {
                    hashCode = (hashCode &* 31) &+ chanId.hashValue
                }
                if hasFeeBaseMsat {
                    hashCode = (hashCode &* 31) &+ feeBaseMsat.hashValue
                }
                if hasFeeProportionalMillionths {
                    hashCode = (hashCode &* 31) &+ feeProportionalMillionths.hashValue
                }
                if hasCltvExpiryDelta {
                    hashCode = (hashCode &* 31) &+ cltvExpiryDelta.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.HopHint"
        }
        override public func className() -> String {
            return "Lnrpc.HopHint"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.HopHint = Lnrpc.HopHint()
            public func getMessage() -> Lnrpc.HopHint {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The public key of the node at the start of the channel.
            public var nodeId:String {
                get {
                    return builderResult.nodeId
                }
                set (value) {
                    builderResult.hasNodeId = true
                    builderResult.nodeId = value
                }
            }
            public var hasNodeId:Bool {
                get {
                    return builderResult.hasNodeId
                }
            }
            @discardableResult
            public func setNodeId(_ value:String) -> Lnrpc.HopHint.Builder {
                self.nodeId = value
                return self
            }
            @discardableResult
            public func clearNodeId() -> Lnrpc.HopHint.Builder{
                builderResult.hasNodeId = false
                builderResult.nodeId = nil
                return self
            }
            //// The unique identifier of the channel.
            public var chanId:UInt64 {
                get {
                    return builderResult.chanId
                }
                set (value) {
                    builderResult.hasChanId = true
                    builderResult.chanId = value
                }
            }
            public var hasChanId:Bool {
                get {
                    return builderResult.hasChanId
                }
            }
            @discardableResult
            public func setChanId(_ value:UInt64) -> Lnrpc.HopHint.Builder {
                self.chanId = value
                return self
            }
            @discardableResult
            public func clearChanId() -> Lnrpc.HopHint.Builder{
                builderResult.hasChanId = false
                builderResult.chanId = nil
                return self
            }
            //// The base fee of the channel denominated in millisatoshis.
            public var feeBaseMsat:UInt32 {
                get {
                    return builderResult.feeBaseMsat
                }
                set (value) {
                    builderResult.hasFeeBaseMsat = true
                    builderResult.feeBaseMsat = value
                }
            }
            public var hasFeeBaseMsat:Bool {
                get {
                    return builderResult.hasFeeBaseMsat
                }
            }
            @discardableResult
            public func setFeeBaseMsat(_ value:UInt32) -> Lnrpc.HopHint.Builder {
                self.feeBaseMsat = value
                return self
            }
            @discardableResult
            public func clearFeeBaseMsat() -> Lnrpc.HopHint.Builder{
                builderResult.hasFeeBaseMsat = false
                builderResult.feeBaseMsat = nil
                return self
            }
            ///*
            ///The fee rate of the channel for sending one satoshi across it denominated in
            ///millionths of a satoshi.
            public var feeProportionalMillionths:UInt32 {
                get {
                    return builderResult.feeProportionalMillionths
                }
                set (value) {
                    builderResult.hasFeeProportionalMillionths = true
                    builderResult.feeProportionalMillionths = value
                }
            }
            public var hasFeeProportionalMillionths:Bool {
                get {
                    return builderResult.hasFeeProportionalMillionths
                }
            }
            @discardableResult
            public func setFeeProportionalMillionths(_ value:UInt32) -> Lnrpc.HopHint.Builder {
                self.feeProportionalMillionths = value
                return self
            }
            @discardableResult
            public func clearFeeProportionalMillionths() -> Lnrpc.HopHint.Builder{
                builderResult.hasFeeProportionalMillionths = false
                builderResult.feeProportionalMillionths = nil
                return self
            }
            //// The time-lock delta of the channel.
            public var cltvExpiryDelta:UInt32 {
                get {
                    return builderResult.cltvExpiryDelta
                }
                set (value) {
                    builderResult.hasCltvExpiryDelta = true
                    builderResult.cltvExpiryDelta = value
                }
            }
            public var hasCltvExpiryDelta:Bool {
                get {
                    return builderResult.hasCltvExpiryDelta
                }
            }
            @discardableResult
            public func setCltvExpiryDelta(_ value:UInt32) -> Lnrpc.HopHint.Builder {
                self.cltvExpiryDelta = value
                return self
            }
            @discardableResult
            public func clearCltvExpiryDelta() -> Lnrpc.HopHint.Builder{
                builderResult.hasCltvExpiryDelta = false
                builderResult.cltvExpiryDelta = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.HopHint.Builder {
                builderResult = Lnrpc.HopHint()
                return self
            }
            override public func clone() throws -> Lnrpc.HopHint.Builder {
                return try Lnrpc.HopHint.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.HopHint {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.HopHint {
                let returnMe:Lnrpc.HopHint = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.HopHint) throws -> Lnrpc.HopHint.Builder {
                if other == Lnrpc.HopHint() {
                    return self
                }
                if other.hasNodeId {
                    nodeId = other.nodeId
                }
                if other.hasChanId {
                    chanId = other.chanId
                }
                if other.hasFeeBaseMsat {
                    feeBaseMsat = other.feeBaseMsat
                }
                if other.hasFeeProportionalMillionths {
                    feeProportionalMillionths = other.feeProportionalMillionths
                }
                if other.hasCltvExpiryDelta {
                    cltvExpiryDelta = other.cltvExpiryDelta
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.HopHint.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.HopHint.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        nodeId = try codedInputStream.readString()

                    case 16:
                        chanId = try codedInputStream.readUInt64()

                    case 24:
                        feeBaseMsat = try codedInputStream.readUInt32()

                    case 32:
                        feeProportionalMillionths = try codedInputStream.readUInt32()

                    case 40:
                        cltvExpiryDelta = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.HopHint.Builder {
                let resultDecodedBuilder = Lnrpc.HopHint.Builder()
                if let jsonValueNodeId = jsonMap["node_id"] as? String {
                    resultDecodedBuilder.nodeId = jsonValueNodeId
                }
                if let jsonValueChanId = jsonMap["chan_id"] as? String {
                    resultDecodedBuilder.chanId = UInt64(jsonValueChanId)!
                } else if let jsonValueChanId = jsonMap["chan_id"] as? UInt {
                    resultDecodedBuilder.chanId = UInt64(jsonValueChanId)
                }
                if let jsonValueFeeBaseMsat = jsonMap["fee_base_msat"] as? UInt {
                    resultDecodedBuilder.feeBaseMsat = UInt32(jsonValueFeeBaseMsat)
                } else if let jsonValueFeeBaseMsat = jsonMap["fee_base_msat"] as? String {
                    resultDecodedBuilder.feeBaseMsat = UInt32(jsonValueFeeBaseMsat)!
                }
                if let jsonValueFeeProportionalMillionths = jsonMap["fee_proportional_millionths"] as? UInt {
                    resultDecodedBuilder.feeProportionalMillionths = UInt32(jsonValueFeeProportionalMillionths)
                } else if let jsonValueFeeProportionalMillionths = jsonMap["fee_proportional_millionths"] as? String {
                    resultDecodedBuilder.feeProportionalMillionths = UInt32(jsonValueFeeProportionalMillionths)!
                }
                if let jsonValueCltvExpiryDelta = jsonMap["cltv_expiry_delta"] as? UInt {
                    resultDecodedBuilder.cltvExpiryDelta = UInt32(jsonValueCltvExpiryDelta)
                } else if let jsonValueCltvExpiryDelta = jsonMap["cltv_expiry_delta"] as? String {
                    resultDecodedBuilder.cltvExpiryDelta = UInt32(jsonValueCltvExpiryDelta)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.HopHint.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.HopHint.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class RouteHint : GeneratedMessage {
        public typealias BuilderType = Lnrpc.RouteHint.Builder

        public static func == (lhs: Lnrpc.RouteHint, rhs: Lnrpc.RouteHint) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hopHints == rhs.hopHints)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var hopHints:Array<Lnrpc.HopHint>  = Array<Lnrpc.HopHint>()
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementHopHints in hopHints {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementHopHints)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementHopHints in hopHints {
                serialize_size += oneElementHopHints.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.RouteHint.Builder {
            return Lnrpc.RouteHint.classBuilder() as! Lnrpc.RouteHint.Builder
        }
        public func getBuilder() -> Lnrpc.RouteHint.Builder {
            return classBuilder() as! Lnrpc.RouteHint.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.RouteHint.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.RouteHint.Builder()
        }
        public func toBuilder() throws -> Lnrpc.RouteHint.Builder {
            return try Lnrpc.RouteHint.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.RouteHint) throws -> Lnrpc.RouteHint.Builder {
            return try Lnrpc.RouteHint.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !hopHints.isEmpty {
                var jsonArrayHopHints:Array<Dictionary<String,Any>> = []
                for oneValueHopHints in hopHints {
                    let ecodedMessageHopHints = try oneValueHopHints.encode()
                    jsonArrayHopHints.append(ecodedMessageHopHints)
                }
                jsonMap["hop_hints"] = jsonArrayHopHints
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.RouteHint {
            return try Lnrpc.RouteHint.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.RouteHint {
            return try Lnrpc.RouteHint.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var hopHintsElementIndex:Int = 0
            for oneElementHopHints in hopHints {
                output += "\(indent) hopHints[\(hopHintsElementIndex)] {\n"
                output += try oneElementHopHints.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                hopHintsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementHopHints in hopHints {
                    hashCode = (hashCode &* 31) &+ oneElementHopHints.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.RouteHint"
        }
        override public func className() -> String {
            return "Lnrpc.RouteHint"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.RouteHint = Lnrpc.RouteHint()
            public func getMessage() -> Lnrpc.RouteHint {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///*
            ///A list of hop hints that when chained together can assist in reaching a
            ///specific destination.
            public var hopHints:Array<Lnrpc.HopHint> {
                get {
                    return builderResult.hopHints
                }
                set (value) {
                    builderResult.hopHints = value
                }
            }
            @discardableResult
            public func setHopHints(_ value:Array<Lnrpc.HopHint>) -> Lnrpc.RouteHint.Builder {
                self.hopHints = value
                return self
            }
            @discardableResult
            public func clearHopHints() -> Lnrpc.RouteHint.Builder {
                builderResult.hopHints.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.RouteHint.Builder {
                builderResult = Lnrpc.RouteHint()
                return self
            }
            override public func clone() throws -> Lnrpc.RouteHint.Builder {
                return try Lnrpc.RouteHint.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.RouteHint {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.RouteHint {
                let returnMe:Lnrpc.RouteHint = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.RouteHint) throws -> Lnrpc.RouteHint.Builder {
                if other == Lnrpc.RouteHint() {
                    return self
                }
                if !other.hopHints.isEmpty  {
                     builderResult.hopHints += other.hopHints
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.RouteHint.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.RouteHint.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Lnrpc.HopHint.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        hopHints.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.RouteHint.Builder {
                let resultDecodedBuilder = Lnrpc.RouteHint.Builder()
                if let jsonValueHopHints = jsonMap["hop_hints"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayHopHints:Array<Lnrpc.HopHint> = []
                    for oneValueHopHints in jsonValueHopHints {
                        let messageFromStringHopHints = try Lnrpc.HopHint.Builder.decodeToBuilder(jsonMap:oneValueHopHints).build()

                        jsonArrayHopHints.append(messageFromStringHopHints)
                    }
                    resultDecodedBuilder.hopHints = jsonArrayHopHints
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.RouteHint.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.RouteHint.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class Invoice : GeneratedMessage {
        public typealias BuilderType = Lnrpc.Invoice.Builder

        public static func == (lhs: Lnrpc.Invoice, rhs: Lnrpc.Invoice) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasMemo == rhs.hasMemo) && (!lhs.hasMemo || lhs.memo == rhs.memo)
            fieldCheck = fieldCheck && (lhs.hasReceipt == rhs.hasReceipt) && (!lhs.hasReceipt || lhs.receipt == rhs.receipt)
            fieldCheck = fieldCheck && (lhs.hasRPreimage == rhs.hasRPreimage) && (!lhs.hasRPreimage || lhs.rPreimage == rhs.rPreimage)
            fieldCheck = fieldCheck && (lhs.hasRHash == rhs.hasRHash) && (!lhs.hasRHash || lhs.rHash == rhs.rHash)
            fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
            fieldCheck = fieldCheck && (lhs.hasSettled == rhs.hasSettled) && (!lhs.hasSettled || lhs.settled == rhs.settled)
            fieldCheck = fieldCheck && (lhs.hasCreationDate == rhs.hasCreationDate) && (!lhs.hasCreationDate || lhs.creationDate == rhs.creationDate)
            fieldCheck = fieldCheck && (lhs.hasSettleDate == rhs.hasSettleDate) && (!lhs.hasSettleDate || lhs.settleDate == rhs.settleDate)
            fieldCheck = fieldCheck && (lhs.hasPaymentRequest == rhs.hasPaymentRequest) && (!lhs.hasPaymentRequest || lhs.paymentRequest == rhs.paymentRequest)
            fieldCheck = fieldCheck && (lhs.hasDescriptionHash == rhs.hasDescriptionHash) && (!lhs.hasDescriptionHash || lhs.descriptionHash == rhs.descriptionHash)
            fieldCheck = fieldCheck && (lhs.hasExpiry == rhs.hasExpiry) && (!lhs.hasExpiry || lhs.expiry == rhs.expiry)
            fieldCheck = fieldCheck && (lhs.hasFallbackAddr == rhs.hasFallbackAddr) && (!lhs.hasFallbackAddr || lhs.fallbackAddr == rhs.fallbackAddr)
            fieldCheck = fieldCheck && (lhs.hasCltvExpiry == rhs.hasCltvExpiry) && (!lhs.hasCltvExpiry || lhs.cltvExpiry == rhs.cltvExpiry)
            fieldCheck = fieldCheck && (lhs.routeHints == rhs.routeHints)
            fieldCheck = fieldCheck && (lhs.hasPrivate == rhs.hasPrivate) && (!lhs.hasPrivate || lhs.private == rhs.private)
            fieldCheck = fieldCheck && (lhs.hasAddIndex == rhs.hasAddIndex) && (!lhs.hasAddIndex || lhs.addIndex == rhs.addIndex)
            fieldCheck = fieldCheck && (lhs.hasSettleIndex == rhs.hasSettleIndex) && (!lhs.hasSettleIndex || lhs.settleIndex == rhs.settleIndex)
            fieldCheck = fieldCheck && (lhs.hasAmtPaid == rhs.hasAmtPaid) && (!lhs.hasAmtPaid || lhs.amtPaid == rhs.amtPaid)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///*
        ///An optional memo to attach along with the invoice. Used for record keeping
        ///purposes for the invoice's creator, and will also be set in the description
        ///field of the encoded payment request if the description_hash field is not
        ///being used.
        public fileprivate(set) var memo:String! = nil
        public fileprivate(set) var hasMemo:Bool = false

        //// An optional cryptographic receipt of payment
        public fileprivate(set) var receipt:Data! = nil
        public fileprivate(set) var hasReceipt:Bool = false

        ///*
        ///The hex-encoded preimage (32 byte) which will allow settling an incoming
        ///HTLC payable to this preimage
        public fileprivate(set) var rPreimage:Data! = nil
        public fileprivate(set) var hasRPreimage:Bool = false

        //// The hash of the preimage
        public fileprivate(set) var rHash:Data! = nil
        public fileprivate(set) var hasRHash:Bool = false

        //// The value of this invoice in satoshis
        public fileprivate(set) var value:Int64! = nil
        public fileprivate(set) var hasValue:Bool = false

        //// Whether this invoice has been fulfilled
        public fileprivate(set) var settled:Bool! = nil
        public fileprivate(set) var hasSettled:Bool = false

        //// When this invoice was created
        public fileprivate(set) var creationDate:Int64! = nil
        public fileprivate(set) var hasCreationDate:Bool = false

        //// When this invoice was settled
        public fileprivate(set) var settleDate:Int64! = nil
        public fileprivate(set) var hasSettleDate:Bool = false

        ///*
        ///A bare-bones invoice for a payment within the Lightning Network.  With the
        ///details of the invoice, the sender has all the data necessary to send a
        ///payment to the recipient.
        public fileprivate(set) var paymentRequest:String! = nil
        public fileprivate(set) var hasPaymentRequest:Bool = false

        ///*
        ///Hash (SHA-256) of a description of the payment. Used if the description of
        ///payment (memo) is too long to naturally fit within the description field
        ///of an encoded payment request.
        public fileprivate(set) var descriptionHash:Data! = nil
        public fileprivate(set) var hasDescriptionHash:Bool = false

        //// Payment request expiry time in seconds. Default is 3600 (1 hour).
        public fileprivate(set) var expiry:Int64! = nil
        public fileprivate(set) var hasExpiry:Bool = false

        //// Fallback on-chain address.
        public fileprivate(set) var fallbackAddr:String! = nil
        public fileprivate(set) var hasFallbackAddr:Bool = false

        //// Delta to use for the time-lock of the CLTV extended to the final hop.
        public fileprivate(set) var cltvExpiry:UInt64! = nil
        public fileprivate(set) var hasCltvExpiry:Bool = false

        public fileprivate(set) var routeHints:Array<Lnrpc.RouteHint>  = Array<Lnrpc.RouteHint>()
        //// Whether this invoice should include routing hints for private channels.
        public fileprivate(set) var private:Bool! = nil
        public fileprivate(set) var hasPrivate:Bool = false

        ///*
        ///The "add" index of this invoice. Each newly created invoice will increment
        ///this index making it monotonically increasing. Callers to the
        ///SubscribeInvoices call can use this to instantly get notified of all added
        ///invoices with an add_index greater than this one.
        public fileprivate(set) var addIndex:UInt64! = nil
        public fileprivate(set) var hasAddIndex:Bool = false

        ///*
        ///The "settle" index of this invoice. Each newly settled invoice will
        ///increment this index making it monotonically increasing. Callers to the
        ///SubscribeInvoices call can use this to instantly get notified of all
        ///settled invoices with an settle_index greater than this one.
        public fileprivate(set) var settleIndex:UInt64! = nil
        public fileprivate(set) var hasSettleIndex:Bool = false

        ///*
        ///The amount that was accepted for this invoice. This will ONLY be set if
        ///this invoice has been settled. We provide this field as if the invoice was
        ///created with a zero value, then we need to record what amount was
        ///ultimately accepted. Additionally, it's possible that the sender paid MORE
        ///that was specified in the original invoice. So we'll record that here as
        ///well.
        public fileprivate(set) var amtPaid:Int64! = nil
        public fileprivate(set) var hasAmtPaid:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasMemo {
                try codedOutputStream.writeString(fieldNumber: 1, value:memo)
            }
            if hasReceipt {
                try codedOutputStream.writeData(fieldNumber: 2, value:receipt)
            }
            if hasRPreimage {
                try codedOutputStream.writeData(fieldNumber: 3, value:rPreimage)
            }
            if hasRHash {
                try codedOutputStream.writeData(fieldNumber: 4, value:rHash)
            }
            if hasValue {
                try codedOutputStream.writeInt64(fieldNumber: 5, value:value)
            }
            if hasSettled {
                try codedOutputStream.writeBool(fieldNumber: 6, value:settled)
            }
            if hasCreationDate {
                try codedOutputStream.writeInt64(fieldNumber: 7, value:creationDate)
            }
            if hasSettleDate {
                try codedOutputStream.writeInt64(fieldNumber: 8, value:settleDate)
            }
            if hasPaymentRequest {
                try codedOutputStream.writeString(fieldNumber: 9, value:paymentRequest)
            }
            if hasDescriptionHash {
                try codedOutputStream.writeData(fieldNumber: 10, value:descriptionHash)
            }
            if hasExpiry {
                try codedOutputStream.writeInt64(fieldNumber: 11, value:expiry)
            }
            if hasFallbackAddr {
                try codedOutputStream.writeString(fieldNumber: 12, value:fallbackAddr)
            }
            if hasCltvExpiry {
                try codedOutputStream.writeUInt64(fieldNumber: 13, value:cltvExpiry)
            }
            for oneElementRouteHints in routeHints {
                  try codedOutputStream.writeMessage(fieldNumber: 14, value:oneElementRouteHints)
            }
            if hasPrivate {
                try codedOutputStream.writeBool(fieldNumber: 15, value:private)
            }
            if hasAddIndex {
                try codedOutputStream.writeUInt64(fieldNumber: 16, value:addIndex)
            }
            if hasSettleIndex {
                try codedOutputStream.writeUInt64(fieldNumber: 17, value:settleIndex)
            }
            if hasAmtPaid {
                try codedOutputStream.writeInt64(fieldNumber: 18, value:amtPaid)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasMemo {
                serialize_size += memo.computeStringSize(fieldNumber: 1)
            }
            if hasReceipt {
                serialize_size += receipt.computeDataSize(fieldNumber: 2)
            }
            if hasRPreimage {
                serialize_size += rPreimage.computeDataSize(fieldNumber: 3)
            }
            if hasRHash {
                serialize_size += rHash.computeDataSize(fieldNumber: 4)
            }
            if hasValue {
                serialize_size += value.computeInt64Size(fieldNumber: 5)
            }
            if hasSettled {
                serialize_size += settled.computeBoolSize(fieldNumber: 6)
            }
            if hasCreationDate {
                serialize_size += creationDate.computeInt64Size(fieldNumber: 7)
            }
            if hasSettleDate {
                serialize_size += settleDate.computeInt64Size(fieldNumber: 8)
            }
            if hasPaymentRequest {
                serialize_size += paymentRequest.computeStringSize(fieldNumber: 9)
            }
            if hasDescriptionHash {
                serialize_size += descriptionHash.computeDataSize(fieldNumber: 10)
            }
            if hasExpiry {
                serialize_size += expiry.computeInt64Size(fieldNumber: 11)
            }
            if hasFallbackAddr {
                serialize_size += fallbackAddr.computeStringSize(fieldNumber: 12)
            }
            if hasCltvExpiry {
                serialize_size += cltvExpiry.computeUInt64Size(fieldNumber: 13)
            }
            for oneElementRouteHints in routeHints {
                serialize_size += oneElementRouteHints.computeMessageSize(fieldNumber: 14)
            }
            if hasPrivate {
                serialize_size += private.computeBoolSize(fieldNumber: 15)
            }
            if hasAddIndex {
                serialize_size += addIndex.computeUInt64Size(fieldNumber: 16)
            }
            if hasSettleIndex {
                serialize_size += settleIndex.computeUInt64Size(fieldNumber: 17)
            }
            if hasAmtPaid {
                serialize_size += amtPaid.computeInt64Size(fieldNumber: 18)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.Invoice.Builder {
            return Lnrpc.Invoice.classBuilder() as! Lnrpc.Invoice.Builder
        }
        public func getBuilder() -> Lnrpc.Invoice.Builder {
            return classBuilder() as! Lnrpc.Invoice.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.Invoice.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.Invoice.Builder()
        }
        public func toBuilder() throws -> Lnrpc.Invoice.Builder {
            return try Lnrpc.Invoice.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.Invoice) throws -> Lnrpc.Invoice.Builder {
            return try Lnrpc.Invoice.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasMemo {
                jsonMap["memo"] = memo
            }
            if hasReceipt {
                jsonMap["receipt"] = receipt.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasRPreimage {
                jsonMap["r_preimage"] = rPreimage.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasRHash {
                jsonMap["r_hash"] = rHash.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasValue {
                jsonMap["value"] = "\(value!)"
            }
            if hasSettled {
                jsonMap["settled"] = settled
            }
            if hasCreationDate {
                jsonMap["creation_date"] = "\(creationDate!)"
            }
            if hasSettleDate {
                jsonMap["settle_date"] = "\(settleDate!)"
            }
            if hasPaymentRequest {
                jsonMap["payment_request"] = paymentRequest
            }
            if hasDescriptionHash {
                jsonMap["description_hash"] = descriptionHash.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasExpiry {
                jsonMap["expiry"] = "\(expiry!)"
            }
            if hasFallbackAddr {
                jsonMap["fallback_addr"] = fallbackAddr
            }
            if hasCltvExpiry {
                jsonMap["cltv_expiry"] = "\(cltvExpiry!)"
            }
            if !routeHints.isEmpty {
                var jsonArrayRouteHints:Array<Dictionary<String,Any>> = []
                for oneValueRouteHints in routeHints {
                    let ecodedMessageRouteHints = try oneValueRouteHints.encode()
                    jsonArrayRouteHints.append(ecodedMessageRouteHints)
                }
                jsonMap["route_hints"] = jsonArrayRouteHints
            }
            if hasPrivate {
                jsonMap["private"] = private
            }
            if hasAddIndex {
                jsonMap["add_index"] = "\(addIndex!)"
            }
            if hasSettleIndex {
                jsonMap["settle_index"] = "\(settleIndex!)"
            }
            if hasAmtPaid {
                jsonMap["amt_paid"] = "\(amtPaid!)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.Invoice {
            return try Lnrpc.Invoice.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.Invoice {
            return try Lnrpc.Invoice.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasMemo {
                output += "\(indent) memo: \(memo) \n"
            }
            if hasReceipt {
                output += "\(indent) receipt: \(receipt) \n"
            }
            if hasRPreimage {
                output += "\(indent) rPreimage: \(rPreimage) \n"
            }
            if hasRHash {
                output += "\(indent) rHash: \(rHash) \n"
            }
            if hasValue {
                output += "\(indent) value: \(value) \n"
            }
            if hasSettled {
                output += "\(indent) settled: \(settled) \n"
            }
            if hasCreationDate {
                output += "\(indent) creationDate: \(creationDate) \n"
            }
            if hasSettleDate {
                output += "\(indent) settleDate: \(settleDate) \n"
            }
            if hasPaymentRequest {
                output += "\(indent) paymentRequest: \(paymentRequest) \n"
            }
            if hasDescriptionHash {
                output += "\(indent) descriptionHash: \(descriptionHash) \n"
            }
            if hasExpiry {
                output += "\(indent) expiry: \(expiry) \n"
            }
            if hasFallbackAddr {
                output += "\(indent) fallbackAddr: \(fallbackAddr) \n"
            }
            if hasCltvExpiry {
                output += "\(indent) cltvExpiry: \(cltvExpiry) \n"
            }
            var routeHintsElementIndex:Int = 0
            for oneElementRouteHints in routeHints {
                output += "\(indent) routeHints[\(routeHintsElementIndex)] {\n"
                output += try oneElementRouteHints.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                routeHintsElementIndex += 1
            }
            if hasPrivate {
                output += "\(indent) private: \(private) \n"
            }
            if hasAddIndex {
                output += "\(indent) addIndex: \(addIndex) \n"
            }
            if hasSettleIndex {
                output += "\(indent) settleIndex: \(settleIndex) \n"
            }
            if hasAmtPaid {
                output += "\(indent) amtPaid: \(amtPaid) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasMemo {
                    hashCode = (hashCode &* 31) &+ memo.hashValue
                }
                if hasReceipt {
                    hashCode = (hashCode &* 31) &+ receipt.hashValue
                }
                if hasRPreimage {
                    hashCode = (hashCode &* 31) &+ rPreimage.hashValue
                }
                if hasRHash {
                    hashCode = (hashCode &* 31) &+ rHash.hashValue
                }
                if hasValue {
                    hashCode = (hashCode &* 31) &+ value.hashValue
                }
                if hasSettled {
                    hashCode = (hashCode &* 31) &+ settled.hashValue
                }
                if hasCreationDate {
                    hashCode = (hashCode &* 31) &+ creationDate.hashValue
                }
                if hasSettleDate {
                    hashCode = (hashCode &* 31) &+ settleDate.hashValue
                }
                if hasPaymentRequest {
                    hashCode = (hashCode &* 31) &+ paymentRequest.hashValue
                }
                if hasDescriptionHash {
                    hashCode = (hashCode &* 31) &+ descriptionHash.hashValue
                }
                if hasExpiry {
                    hashCode = (hashCode &* 31) &+ expiry.hashValue
                }
                if hasFallbackAddr {
                    hashCode = (hashCode &* 31) &+ fallbackAddr.hashValue
                }
                if hasCltvExpiry {
                    hashCode = (hashCode &* 31) &+ cltvExpiry.hashValue
                }
                for oneElementRouteHints in routeHints {
                    hashCode = (hashCode &* 31) &+ oneElementRouteHints.hashValue
                }
                if hasPrivate {
                    hashCode = (hashCode &* 31) &+ private.hashValue
                }
                if hasAddIndex {
                    hashCode = (hashCode &* 31) &+ addIndex.hashValue
                }
                if hasSettleIndex {
                    hashCode = (hashCode &* 31) &+ settleIndex.hashValue
                }
                if hasAmtPaid {
                    hashCode = (hashCode &* 31) &+ amtPaid.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.Invoice"
        }
        override public func className() -> String {
            return "Lnrpc.Invoice"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.Invoice = Lnrpc.Invoice()
            public func getMessage() -> Lnrpc.Invoice {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///*
            ///An optional memo to attach along with the invoice. Used for record keeping
            ///purposes for the invoice's creator, and will also be set in the description
            ///field of the encoded payment request if the description_hash field is not
            ///being used.
            public var memo:String {
                get {
                    return builderResult.memo
                }
                set (value) {
                    builderResult.hasMemo = true
                    builderResult.memo = value
                }
            }
            public var hasMemo:Bool {
                get {
                    return builderResult.hasMemo
                }
            }
            @discardableResult
            public func setMemo(_ value:String) -> Lnrpc.Invoice.Builder {
                self.memo = value
                return self
            }
            @discardableResult
            public func clearMemo() -> Lnrpc.Invoice.Builder{
                builderResult.hasMemo = false
                builderResult.memo = nil
                return self
            }
            //// An optional cryptographic receipt of payment
            public var receipt:Data {
                get {
                    return builderResult.receipt
                }
                set (value) {
                    builderResult.hasReceipt = true
                    builderResult.receipt = value
                }
            }
            public var hasReceipt:Bool {
                get {
                    return builderResult.hasReceipt
                }
            }
            @discardableResult
            public func setReceipt(_ value:Data) -> Lnrpc.Invoice.Builder {
                self.receipt = value
                return self
            }
            @discardableResult
            public func clearReceipt() -> Lnrpc.Invoice.Builder{
                builderResult.hasReceipt = false
                builderResult.receipt = nil
                return self
            }
            ///*
            ///The hex-encoded preimage (32 byte) which will allow settling an incoming
            ///HTLC payable to this preimage
            public var rPreimage:Data {
                get {
                    return builderResult.rPreimage
                }
                set (value) {
                    builderResult.hasRPreimage = true
                    builderResult.rPreimage = value
                }
            }
            public var hasRPreimage:Bool {
                get {
                    return builderResult.hasRPreimage
                }
            }
            @discardableResult
            public func setRPreimage(_ value:Data) -> Lnrpc.Invoice.Builder {
                self.rPreimage = value
                return self
            }
            @discardableResult
            public func clearRPreimage() -> Lnrpc.Invoice.Builder{
                builderResult.hasRPreimage = false
                builderResult.rPreimage = nil
                return self
            }
            //// The hash of the preimage
            public var rHash:Data {
                get {
                    return builderResult.rHash
                }
                set (value) {
                    builderResult.hasRHash = true
                    builderResult.rHash = value
                }
            }
            public var hasRHash:Bool {
                get {
                    return builderResult.hasRHash
                }
            }
            @discardableResult
            public func setRHash(_ value:Data) -> Lnrpc.Invoice.Builder {
                self.rHash = value
                return self
            }
            @discardableResult
            public func clearRHash() -> Lnrpc.Invoice.Builder{
                builderResult.hasRHash = false
                builderResult.rHash = nil
                return self
            }
            //// The value of this invoice in satoshis
            public var value:Int64 {
                get {
                    return builderResult.value
                }
                set (value) {
                    builderResult.hasValue = true
                    builderResult.value = value
                }
            }
            public var hasValue:Bool {
                get {
                    return builderResult.hasValue
                }
            }
            @discardableResult
            public func setValue(_ value:Int64) -> Lnrpc.Invoice.Builder {
                self.value = value
                return self
            }
            @discardableResult
            public func clearValue() -> Lnrpc.Invoice.Builder{
                builderResult.hasValue = false
                builderResult.value = nil
                return self
            }
            //// Whether this invoice has been fulfilled
            public var settled:Bool {
                get {
                    return builderResult.settled
                }
                set (value) {
                    builderResult.hasSettled = true
                    builderResult.settled = value
                }
            }
            public var hasSettled:Bool {
                get {
                    return builderResult.hasSettled
                }
            }
            @discardableResult
            public func setSettled(_ value:Bool) -> Lnrpc.Invoice.Builder {
                self.settled = value
                return self
            }
            @discardableResult
            public func clearSettled() -> Lnrpc.Invoice.Builder{
                builderResult.hasSettled = false
                builderResult.settled = nil
                return self
            }
            //// When this invoice was created
            public var creationDate:Int64 {
                get {
                    return builderResult.creationDate
                }
                set (value) {
                    builderResult.hasCreationDate = true
                    builderResult.creationDate = value
                }
            }
            public var hasCreationDate:Bool {
                get {
                    return builderResult.hasCreationDate
                }
            }
            @discardableResult
            public func setCreationDate(_ value:Int64) -> Lnrpc.Invoice.Builder {
                self.creationDate = value
                return self
            }
            @discardableResult
            public func clearCreationDate() -> Lnrpc.Invoice.Builder{
                builderResult.hasCreationDate = false
                builderResult.creationDate = nil
                return self
            }
            //// When this invoice was settled
            public var settleDate:Int64 {
                get {
                    return builderResult.settleDate
                }
                set (value) {
                    builderResult.hasSettleDate = true
                    builderResult.settleDate = value
                }
            }
            public var hasSettleDate:Bool {
                get {
                    return builderResult.hasSettleDate
                }
            }
            @discardableResult
            public func setSettleDate(_ value:Int64) -> Lnrpc.Invoice.Builder {
                self.settleDate = value
                return self
            }
            @discardableResult
            public func clearSettleDate() -> Lnrpc.Invoice.Builder{
                builderResult.hasSettleDate = false
                builderResult.settleDate = nil
                return self
            }
            ///*
            ///A bare-bones invoice for a payment within the Lightning Network.  With the
            ///details of the invoice, the sender has all the data necessary to send a
            ///payment to the recipient.
            public var paymentRequest:String {
                get {
                    return builderResult.paymentRequest
                }
                set (value) {
                    builderResult.hasPaymentRequest = true
                    builderResult.paymentRequest = value
                }
            }
            public var hasPaymentRequest:Bool {
                get {
                    return builderResult.hasPaymentRequest
                }
            }
            @discardableResult
            public func setPaymentRequest(_ value:String) -> Lnrpc.Invoice.Builder {
                self.paymentRequest = value
                return self
            }
            @discardableResult
            public func clearPaymentRequest() -> Lnrpc.Invoice.Builder{
                builderResult.hasPaymentRequest = false
                builderResult.paymentRequest = nil
                return self
            }
            ///*
            ///Hash (SHA-256) of a description of the payment. Used if the description of
            ///payment (memo) is too long to naturally fit within the description field
            ///of an encoded payment request.
            public var descriptionHash:Data {
                get {
                    return builderResult.descriptionHash
                }
                set (value) {
                    builderResult.hasDescriptionHash = true
                    builderResult.descriptionHash = value
                }
            }
            public var hasDescriptionHash:Bool {
                get {
                    return builderResult.hasDescriptionHash
                }
            }
            @discardableResult
            public func setDescriptionHash(_ value:Data) -> Lnrpc.Invoice.Builder {
                self.descriptionHash = value
                return self
            }
            @discardableResult
            public func clearDescriptionHash() -> Lnrpc.Invoice.Builder{
                builderResult.hasDescriptionHash = false
                builderResult.descriptionHash = nil
                return self
            }
            //// Payment request expiry time in seconds. Default is 3600 (1 hour).
            public var expiry:Int64 {
                get {
                    return builderResult.expiry
                }
                set (value) {
                    builderResult.hasExpiry = true
                    builderResult.expiry = value
                }
            }
            public var hasExpiry:Bool {
                get {
                    return builderResult.hasExpiry
                }
            }
            @discardableResult
            public func setExpiry(_ value:Int64) -> Lnrpc.Invoice.Builder {
                self.expiry = value
                return self
            }
            @discardableResult
            public func clearExpiry() -> Lnrpc.Invoice.Builder{
                builderResult.hasExpiry = false
                builderResult.expiry = nil
                return self
            }
            //// Fallback on-chain address.
            public var fallbackAddr:String {
                get {
                    return builderResult.fallbackAddr
                }
                set (value) {
                    builderResult.hasFallbackAddr = true
                    builderResult.fallbackAddr = value
                }
            }
            public var hasFallbackAddr:Bool {
                get {
                    return builderResult.hasFallbackAddr
                }
            }
            @discardableResult
            public func setFallbackAddr(_ value:String) -> Lnrpc.Invoice.Builder {
                self.fallbackAddr = value
                return self
            }
            @discardableResult
            public func clearFallbackAddr() -> Lnrpc.Invoice.Builder{
                builderResult.hasFallbackAddr = false
                builderResult.fallbackAddr = nil
                return self
            }
            //// Delta to use for the time-lock of the CLTV extended to the final hop.
            public var cltvExpiry:UInt64 {
                get {
                    return builderResult.cltvExpiry
                }
                set (value) {
                    builderResult.hasCltvExpiry = true
                    builderResult.cltvExpiry = value
                }
            }
            public var hasCltvExpiry:Bool {
                get {
                    return builderResult.hasCltvExpiry
                }
            }
            @discardableResult
            public func setCltvExpiry(_ value:UInt64) -> Lnrpc.Invoice.Builder {
                self.cltvExpiry = value
                return self
            }
            @discardableResult
            public func clearCltvExpiry() -> Lnrpc.Invoice.Builder{
                builderResult.hasCltvExpiry = false
                builderResult.cltvExpiry = nil
                return self
            }
            ///*
            ///Route hints that can each be individually used to assist in reaching the
            ///invoice's destination.
            public var routeHints:Array<Lnrpc.RouteHint> {
                get {
                    return builderResult.routeHints
                }
                set (value) {
                    builderResult.routeHints = value
                }
            }
            @discardableResult
            public func setRouteHints(_ value:Array<Lnrpc.RouteHint>) -> Lnrpc.Invoice.Builder {
                self.routeHints = value
                return self
            }
            @discardableResult
            public func clearRouteHints() -> Lnrpc.Invoice.Builder {
                builderResult.routeHints.removeAll(keepingCapacity: false)
                return self
            }
            //// Whether this invoice should include routing hints for private channels.
            public var private:Bool {
                get {
                    return builderResult.private
                }
                set (value) {
                    builderResult.hasPrivate = true
                    builderResult.private = value
                }
            }
            public var hasPrivate:Bool {
                get {
                    return builderResult.hasPrivate
                }
            }
            @discardableResult
            public func setPrivate(_ value:Bool) -> Lnrpc.Invoice.Builder {
                self.private = value
                return self
            }
            @discardableResult
            public func clearPrivate() -> Lnrpc.Invoice.Builder{
                builderResult.hasPrivate = false
                builderResult.private = nil
                return self
            }
            ///*
            ///The "add" index of this invoice. Each newly created invoice will increment
            ///this index making it monotonically increasing. Callers to the
            ///SubscribeInvoices call can use this to instantly get notified of all added
            ///invoices with an add_index greater than this one.
            public var addIndex:UInt64 {
                get {
                    return builderResult.addIndex
                }
                set (value) {
                    builderResult.hasAddIndex = true
                    builderResult.addIndex = value
                }
            }
            public var hasAddIndex:Bool {
                get {
                    return builderResult.hasAddIndex
                }
            }
            @discardableResult
            public func setAddIndex(_ value:UInt64) -> Lnrpc.Invoice.Builder {
                self.addIndex = value
                return self
            }
            @discardableResult
            public func clearAddIndex() -> Lnrpc.Invoice.Builder{
                builderResult.hasAddIndex = false
                builderResult.addIndex = nil
                return self
            }
            ///*
            ///The "settle" index of this invoice. Each newly settled invoice will
            ///increment this index making it monotonically increasing. Callers to the
            ///SubscribeInvoices call can use this to instantly get notified of all
            ///settled invoices with an settle_index greater than this one.
            public var settleIndex:UInt64 {
                get {
                    return builderResult.settleIndex
                }
                set (value) {
                    builderResult.hasSettleIndex = true
                    builderResult.settleIndex = value
                }
            }
            public var hasSettleIndex:Bool {
                get {
                    return builderResult.hasSettleIndex
                }
            }
            @discardableResult
            public func setSettleIndex(_ value:UInt64) -> Lnrpc.Invoice.Builder {
                self.settleIndex = value
                return self
            }
            @discardableResult
            public func clearSettleIndex() -> Lnrpc.Invoice.Builder{
                builderResult.hasSettleIndex = false
                builderResult.settleIndex = nil
                return self
            }
            ///*
            ///The amount that was accepted for this invoice. This will ONLY be set if
            ///this invoice has been settled. We provide this field as if the invoice was
            ///created with a zero value, then we need to record what amount was
            ///ultimately accepted. Additionally, it's possible that the sender paid MORE
            ///that was specified in the original invoice. So we'll record that here as
            ///well.
            public var amtPaid:Int64 {
                get {
                    return builderResult.amtPaid
                }
                set (value) {
                    builderResult.hasAmtPaid = true
                    builderResult.amtPaid = value
                }
            }
            public var hasAmtPaid:Bool {
                get {
                    return builderResult.hasAmtPaid
                }
            }
            @discardableResult
            public func setAmtPaid(_ value:Int64) -> Lnrpc.Invoice.Builder {
                self.amtPaid = value
                return self
            }
            @discardableResult
            public func clearAmtPaid() -> Lnrpc.Invoice.Builder{
                builderResult.hasAmtPaid = false
                builderResult.amtPaid = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.Invoice.Builder {
                builderResult = Lnrpc.Invoice()
                return self
            }
            override public func clone() throws -> Lnrpc.Invoice.Builder {
                return try Lnrpc.Invoice.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.Invoice {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.Invoice {
                let returnMe:Lnrpc.Invoice = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.Invoice) throws -> Lnrpc.Invoice.Builder {
                if other == Lnrpc.Invoice() {
                    return self
                }
                if other.hasMemo {
                    memo = other.memo
                }
                if other.hasReceipt {
                    receipt = other.receipt
                }
                if other.hasRPreimage {
                    rPreimage = other.rPreimage
                }
                if other.hasRHash {
                    rHash = other.rHash
                }
                if other.hasValue {
                    value = other.value
                }
                if other.hasSettled {
                    settled = other.settled
                }
                if other.hasCreationDate {
                    creationDate = other.creationDate
                }
                if other.hasSettleDate {
                    settleDate = other.settleDate
                }
                if other.hasPaymentRequest {
                    paymentRequest = other.paymentRequest
                }
                if other.hasDescriptionHash {
                    descriptionHash = other.descriptionHash
                }
                if other.hasExpiry {
                    expiry = other.expiry
                }
                if other.hasFallbackAddr {
                    fallbackAddr = other.fallbackAddr
                }
                if other.hasCltvExpiry {
                    cltvExpiry = other.cltvExpiry
                }
                if !other.routeHints.isEmpty  {
                     builderResult.routeHints += other.routeHints
                }
                if other.hasPrivate {
                    private = other.private
                }
                if other.hasAddIndex {
                    addIndex = other.addIndex
                }
                if other.hasSettleIndex {
                    settleIndex = other.settleIndex
                }
                if other.hasAmtPaid {
                    amtPaid = other.amtPaid
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.Invoice.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Invoice.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        memo = try codedInputStream.readString()

                    case 18:
                        receipt = try codedInputStream.readData()

                    case 26:
                        rPreimage = try codedInputStream.readData()

                    case 34:
                        rHash = try codedInputStream.readData()

                    case 40:
                        value = try codedInputStream.readInt64()

                    case 48:
                        settled = try codedInputStream.readBool()

                    case 56:
                        creationDate = try codedInputStream.readInt64()

                    case 64:
                        settleDate = try codedInputStream.readInt64()

                    case 74:
                        paymentRequest = try codedInputStream.readString()

                    case 82:
                        descriptionHash = try codedInputStream.readData()

                    case 88:
                        expiry = try codedInputStream.readInt64()

                    case 98:
                        fallbackAddr = try codedInputStream.readString()

                    case 104:
                        cltvExpiry = try codedInputStream.readUInt64()

                    case 114:
                        let subBuilder = Lnrpc.RouteHint.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        routeHints.append(subBuilder.buildPartial())

                    case 120:
                        private = try codedInputStream.readBool()

                    case 128:
                        addIndex = try codedInputStream.readUInt64()

                    case 136:
                        settleIndex = try codedInputStream.readUInt64()

                    case 144:
                        amtPaid = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.Invoice.Builder {
                let resultDecodedBuilder = Lnrpc.Invoice.Builder()
                if let jsonValueMemo = jsonMap["memo"] as? String {
                    resultDecodedBuilder.memo = jsonValueMemo
                }
                if let jsonValueReceipt = jsonMap["receipt"] as? String {
                    resultDecodedBuilder.receipt = Data(base64Encoded:jsonValueReceipt, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueRPreimage = jsonMap["r_preimage"] as? String {
                    resultDecodedBuilder.rPreimage = Data(base64Encoded:jsonValueRPreimage, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueRHash = jsonMap["r_hash"] as? String {
                    resultDecodedBuilder.rHash = Data(base64Encoded:jsonValueRHash, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueValue = jsonMap["value"] as? String {
                    resultDecodedBuilder.value = Int64(jsonValueValue)!
                } else if let jsonValueValue = jsonMap["value"] as? Int {
                    resultDecodedBuilder.value = Int64(jsonValueValue)
                }
                if let jsonValueSettled = jsonMap["settled"] as? Bool {
                    resultDecodedBuilder.settled = jsonValueSettled
                }
                if let jsonValueCreationDate = jsonMap["creation_date"] as? String {
                    resultDecodedBuilder.creationDate = Int64(jsonValueCreationDate)!
                } else if let jsonValueCreationDate = jsonMap["creation_date"] as? Int {
                    resultDecodedBuilder.creationDate = Int64(jsonValueCreationDate)
                }
                if let jsonValueSettleDate = jsonMap["settle_date"] as? String {
                    resultDecodedBuilder.settleDate = Int64(jsonValueSettleDate)!
                } else if let jsonValueSettleDate = jsonMap["settle_date"] as? Int {
                    resultDecodedBuilder.settleDate = Int64(jsonValueSettleDate)
                }
                if let jsonValuePaymentRequest = jsonMap["payment_request"] as? String {
                    resultDecodedBuilder.paymentRequest = jsonValuePaymentRequest
                }
                if let jsonValueDescriptionHash = jsonMap["description_hash"] as? String {
                    resultDecodedBuilder.descriptionHash = Data(base64Encoded:jsonValueDescriptionHash, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueExpiry = jsonMap["expiry"] as? String {
                    resultDecodedBuilder.expiry = Int64(jsonValueExpiry)!
                } else if let jsonValueExpiry = jsonMap["expiry"] as? Int {
                    resultDecodedBuilder.expiry = Int64(jsonValueExpiry)
                }
                if let jsonValueFallbackAddr = jsonMap["fallback_addr"] as? String {
                    resultDecodedBuilder.fallbackAddr = jsonValueFallbackAddr
                }
                if let jsonValueCltvExpiry = jsonMap["cltv_expiry"] as? String {
                    resultDecodedBuilder.cltvExpiry = UInt64(jsonValueCltvExpiry)!
                } else if let jsonValueCltvExpiry = jsonMap["cltv_expiry"] as? UInt {
                    resultDecodedBuilder.cltvExpiry = UInt64(jsonValueCltvExpiry)
                }
                if let jsonValueRouteHints = jsonMap["route_hints"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayRouteHints:Array<Lnrpc.RouteHint> = []
                    for oneValueRouteHints in jsonValueRouteHints {
                        let messageFromStringRouteHints = try Lnrpc.RouteHint.Builder.decodeToBuilder(jsonMap:oneValueRouteHints).build()

                        jsonArrayRouteHints.append(messageFromStringRouteHints)
                    }
                    resultDecodedBuilder.routeHints = jsonArrayRouteHints
                }
                if let jsonValuePrivate = jsonMap["private"] as? Bool {
                    resultDecodedBuilder.private = jsonValuePrivate
                }
                if let jsonValueAddIndex = jsonMap["add_index"] as? String {
                    resultDecodedBuilder.addIndex = UInt64(jsonValueAddIndex)!
                } else if let jsonValueAddIndex = jsonMap["add_index"] as? UInt {
                    resultDecodedBuilder.addIndex = UInt64(jsonValueAddIndex)
                }
                if let jsonValueSettleIndex = jsonMap["settle_index"] as? String {
                    resultDecodedBuilder.settleIndex = UInt64(jsonValueSettleIndex)!
                } else if let jsonValueSettleIndex = jsonMap["settle_index"] as? UInt {
                    resultDecodedBuilder.settleIndex = UInt64(jsonValueSettleIndex)
                }
                if let jsonValueAmtPaid = jsonMap["amt_paid"] as? String {
                    resultDecodedBuilder.amtPaid = Int64(jsonValueAmtPaid)!
                } else if let jsonValueAmtPaid = jsonMap["amt_paid"] as? Int {
                    resultDecodedBuilder.amtPaid = Int64(jsonValueAmtPaid)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.Invoice.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.Invoice.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class AddInvoiceResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.AddInvoiceResponse.Builder

        public static func == (lhs: Lnrpc.AddInvoiceResponse, rhs: Lnrpc.AddInvoiceResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasRHash == rhs.hasRHash) && (!lhs.hasRHash || lhs.rHash == rhs.rHash)
            fieldCheck = fieldCheck && (lhs.hasPaymentRequest == rhs.hasPaymentRequest) && (!lhs.hasPaymentRequest || lhs.paymentRequest == rhs.paymentRequest)
            fieldCheck = fieldCheck && (lhs.hasAddIndex == rhs.hasAddIndex) && (!lhs.hasAddIndex || lhs.addIndex == rhs.addIndex)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var rHash:Data! = nil
        public fileprivate(set) var hasRHash:Bool = false

        ///*
        ///A bare-bones invoice for a payment within the Lightning Network.  With the
        ///details of the invoice, the sender has all the data necessary to send a
        ///payment to the recipient.
        public fileprivate(set) var paymentRequest:String! = nil
        public fileprivate(set) var hasPaymentRequest:Bool = false

        ///*
        ///The "add" index of this invoice. Each newly created invoice will increment
        ///this index making it monotonically increasing. Callers to the
        ///SubscribeInvoices call can use this to instantly get notified of all added
        ///invoices with an add_index greater than this one.
        public fileprivate(set) var addIndex:UInt64! = nil
        public fileprivate(set) var hasAddIndex:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasRHash {
                try codedOutputStream.writeData(fieldNumber: 1, value:rHash)
            }
            if hasPaymentRequest {
                try codedOutputStream.writeString(fieldNumber: 2, value:paymentRequest)
            }
            if hasAddIndex {
                try codedOutputStream.writeUInt64(fieldNumber: 16, value:addIndex)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasRHash {
                serialize_size += rHash.computeDataSize(fieldNumber: 1)
            }
            if hasPaymentRequest {
                serialize_size += paymentRequest.computeStringSize(fieldNumber: 2)
            }
            if hasAddIndex {
                serialize_size += addIndex.computeUInt64Size(fieldNumber: 16)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.AddInvoiceResponse.Builder {
            return Lnrpc.AddInvoiceResponse.classBuilder() as! Lnrpc.AddInvoiceResponse.Builder
        }
        public func getBuilder() -> Lnrpc.AddInvoiceResponse.Builder {
            return classBuilder() as! Lnrpc.AddInvoiceResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.AddInvoiceResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.AddInvoiceResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.AddInvoiceResponse.Builder {
            return try Lnrpc.AddInvoiceResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.AddInvoiceResponse) throws -> Lnrpc.AddInvoiceResponse.Builder {
            return try Lnrpc.AddInvoiceResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasRHash {
                jsonMap["r_hash"] = rHash.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasPaymentRequest {
                jsonMap["payment_request"] = paymentRequest
            }
            if hasAddIndex {
                jsonMap["add_index"] = "\(addIndex!)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.AddInvoiceResponse {
            return try Lnrpc.AddInvoiceResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.AddInvoiceResponse {
            return try Lnrpc.AddInvoiceResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasRHash {
                output += "\(indent) rHash: \(rHash) \n"
            }
            if hasPaymentRequest {
                output += "\(indent) paymentRequest: \(paymentRequest) \n"
            }
            if hasAddIndex {
                output += "\(indent) addIndex: \(addIndex) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasRHash {
                    hashCode = (hashCode &* 31) &+ rHash.hashValue
                }
                if hasPaymentRequest {
                    hashCode = (hashCode &* 31) &+ paymentRequest.hashValue
                }
                if hasAddIndex {
                    hashCode = (hashCode &* 31) &+ addIndex.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.AddInvoiceResponse"
        }
        override public func className() -> String {
            return "Lnrpc.AddInvoiceResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.AddInvoiceResponse = Lnrpc.AddInvoiceResponse()
            public func getMessage() -> Lnrpc.AddInvoiceResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var rHash:Data {
                get {
                    return builderResult.rHash
                }
                set (value) {
                    builderResult.hasRHash = true
                    builderResult.rHash = value
                }
            }
            public var hasRHash:Bool {
                get {
                    return builderResult.hasRHash
                }
            }
            @discardableResult
            public func setRHash(_ value:Data) -> Lnrpc.AddInvoiceResponse.Builder {
                self.rHash = value
                return self
            }
            @discardableResult
            public func clearRHash() -> Lnrpc.AddInvoiceResponse.Builder{
                builderResult.hasRHash = false
                builderResult.rHash = nil
                return self
            }
            ///*
            ///A bare-bones invoice for a payment within the Lightning Network.  With the
            ///details of the invoice, the sender has all the data necessary to send a
            ///payment to the recipient.
            public var paymentRequest:String {
                get {
                    return builderResult.paymentRequest
                }
                set (value) {
                    builderResult.hasPaymentRequest = true
                    builderResult.paymentRequest = value
                }
            }
            public var hasPaymentRequest:Bool {
                get {
                    return builderResult.hasPaymentRequest
                }
            }
            @discardableResult
            public func setPaymentRequest(_ value:String) -> Lnrpc.AddInvoiceResponse.Builder {
                self.paymentRequest = value
                return self
            }
            @discardableResult
            public func clearPaymentRequest() -> Lnrpc.AddInvoiceResponse.Builder{
                builderResult.hasPaymentRequest = false
                builderResult.paymentRequest = nil
                return self
            }
            ///*
            ///The "add" index of this invoice. Each newly created invoice will increment
            ///this index making it monotonically increasing. Callers to the
            ///SubscribeInvoices call can use this to instantly get notified of all added
            ///invoices with an add_index greater than this one.
            public var addIndex:UInt64 {
                get {
                    return builderResult.addIndex
                }
                set (value) {
                    builderResult.hasAddIndex = true
                    builderResult.addIndex = value
                }
            }
            public var hasAddIndex:Bool {
                get {
                    return builderResult.hasAddIndex
                }
            }
            @discardableResult
            public func setAddIndex(_ value:UInt64) -> Lnrpc.AddInvoiceResponse.Builder {
                self.addIndex = value
                return self
            }
            @discardableResult
            public func clearAddIndex() -> Lnrpc.AddInvoiceResponse.Builder{
                builderResult.hasAddIndex = false
                builderResult.addIndex = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.AddInvoiceResponse.Builder {
                builderResult = Lnrpc.AddInvoiceResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.AddInvoiceResponse.Builder {
                return try Lnrpc.AddInvoiceResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.AddInvoiceResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.AddInvoiceResponse {
                let returnMe:Lnrpc.AddInvoiceResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.AddInvoiceResponse) throws -> Lnrpc.AddInvoiceResponse.Builder {
                if other == Lnrpc.AddInvoiceResponse() {
                    return self
                }
                if other.hasRHash {
                    rHash = other.rHash
                }
                if other.hasPaymentRequest {
                    paymentRequest = other.paymentRequest
                }
                if other.hasAddIndex {
                    addIndex = other.addIndex
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.AddInvoiceResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.AddInvoiceResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        rHash = try codedInputStream.readData()

                    case 18:
                        paymentRequest = try codedInputStream.readString()

                    case 128:
                        addIndex = try codedInputStream.readUInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.AddInvoiceResponse.Builder {
                let resultDecodedBuilder = Lnrpc.AddInvoiceResponse.Builder()
                if let jsonValueRHash = jsonMap["r_hash"] as? String {
                    resultDecodedBuilder.rHash = Data(base64Encoded:jsonValueRHash, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValuePaymentRequest = jsonMap["payment_request"] as? String {
                    resultDecodedBuilder.paymentRequest = jsonValuePaymentRequest
                }
                if let jsonValueAddIndex = jsonMap["add_index"] as? String {
                    resultDecodedBuilder.addIndex = UInt64(jsonValueAddIndex)!
                } else if let jsonValueAddIndex = jsonMap["add_index"] as? UInt {
                    resultDecodedBuilder.addIndex = UInt64(jsonValueAddIndex)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.AddInvoiceResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.AddInvoiceResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class PaymentHash : GeneratedMessage {
        public typealias BuilderType = Lnrpc.PaymentHash.Builder

        public static func == (lhs: Lnrpc.PaymentHash, rhs: Lnrpc.PaymentHash) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasRHashStr == rhs.hasRHashStr) && (!lhs.hasRHashStr || lhs.rHashStr == rhs.rHashStr)
            fieldCheck = fieldCheck && (lhs.hasRHash == rhs.hasRHash) && (!lhs.hasRHash || lhs.rHash == rhs.rHash)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///*
        ///The hex-encoded payment hash of the invoice to be looked up. The passed
        ///payment hash must be exactly 32 bytes, otherwise an error is returned.
        public fileprivate(set) var rHashStr:String! = nil
        public fileprivate(set) var hasRHashStr:Bool = false

        //// The payment hash of the invoice to be looked up.
        public fileprivate(set) var rHash:Data! = nil
        public fileprivate(set) var hasRHash:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasRHashStr {
                try codedOutputStream.writeString(fieldNumber: 1, value:rHashStr)
            }
            if hasRHash {
                try codedOutputStream.writeData(fieldNumber: 2, value:rHash)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasRHashStr {
                serialize_size += rHashStr.computeStringSize(fieldNumber: 1)
            }
            if hasRHash {
                serialize_size += rHash.computeDataSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.PaymentHash.Builder {
            return Lnrpc.PaymentHash.classBuilder() as! Lnrpc.PaymentHash.Builder
        }
        public func getBuilder() -> Lnrpc.PaymentHash.Builder {
            return classBuilder() as! Lnrpc.PaymentHash.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.PaymentHash.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.PaymentHash.Builder()
        }
        public func toBuilder() throws -> Lnrpc.PaymentHash.Builder {
            return try Lnrpc.PaymentHash.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.PaymentHash) throws -> Lnrpc.PaymentHash.Builder {
            return try Lnrpc.PaymentHash.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasRHashStr {
                jsonMap["r_hash_str"] = rHashStr
            }
            if hasRHash {
                jsonMap["r_hash"] = rHash.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PaymentHash {
            return try Lnrpc.PaymentHash.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PaymentHash {
            return try Lnrpc.PaymentHash.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasRHashStr {
                output += "\(indent) rHashStr: \(rHashStr) \n"
            }
            if hasRHash {
                output += "\(indent) rHash: \(rHash) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasRHashStr {
                    hashCode = (hashCode &* 31) &+ rHashStr.hashValue
                }
                if hasRHash {
                    hashCode = (hashCode &* 31) &+ rHash.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.PaymentHash"
        }
        override public func className() -> String {
            return "Lnrpc.PaymentHash"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.PaymentHash = Lnrpc.PaymentHash()
            public func getMessage() -> Lnrpc.PaymentHash {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///*
            ///The hex-encoded payment hash of the invoice to be looked up. The passed
            ///payment hash must be exactly 32 bytes, otherwise an error is returned.
            public var rHashStr:String {
                get {
                    return builderResult.rHashStr
                }
                set (value) {
                    builderResult.hasRHashStr = true
                    builderResult.rHashStr = value
                }
            }
            public var hasRHashStr:Bool {
                get {
                    return builderResult.hasRHashStr
                }
            }
            @discardableResult
            public func setRHashStr(_ value:String) -> Lnrpc.PaymentHash.Builder {
                self.rHashStr = value
                return self
            }
            @discardableResult
            public func clearRHashStr() -> Lnrpc.PaymentHash.Builder{
                builderResult.hasRHashStr = false
                builderResult.rHashStr = nil
                return self
            }
            //// The payment hash of the invoice to be looked up.
            public var rHash:Data {
                get {
                    return builderResult.rHash
                }
                set (value) {
                    builderResult.hasRHash = true
                    builderResult.rHash = value
                }
            }
            public var hasRHash:Bool {
                get {
                    return builderResult.hasRHash
                }
            }
            @discardableResult
            public func setRHash(_ value:Data) -> Lnrpc.PaymentHash.Builder {
                self.rHash = value
                return self
            }
            @discardableResult
            public func clearRHash() -> Lnrpc.PaymentHash.Builder{
                builderResult.hasRHash = false
                builderResult.rHash = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.PaymentHash.Builder {
                builderResult = Lnrpc.PaymentHash()
                return self
            }
            override public func clone() throws -> Lnrpc.PaymentHash.Builder {
                return try Lnrpc.PaymentHash.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.PaymentHash {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.PaymentHash {
                let returnMe:Lnrpc.PaymentHash = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.PaymentHash) throws -> Lnrpc.PaymentHash.Builder {
                if other == Lnrpc.PaymentHash() {
                    return self
                }
                if other.hasRHashStr {
                    rHashStr = other.rHashStr
                }
                if other.hasRHash {
                    rHash = other.rHash
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PaymentHash.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PaymentHash.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        rHashStr = try codedInputStream.readString()

                    case 18:
                        rHash = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PaymentHash.Builder {
                let resultDecodedBuilder = Lnrpc.PaymentHash.Builder()
                if let jsonValueRHashStr = jsonMap["r_hash_str"] as? String {
                    resultDecodedBuilder.rHashStr = jsonValueRHashStr
                }
                if let jsonValueRHash = jsonMap["r_hash"] as? String {
                    resultDecodedBuilder.rHash = Data(base64Encoded:jsonValueRHash, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PaymentHash.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.PaymentHash.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ListInvoiceRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ListInvoiceRequest.Builder

        public static func == (lhs: Lnrpc.ListInvoiceRequest, rhs: Lnrpc.ListInvoiceRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasPendingOnly == rhs.hasPendingOnly) && (!lhs.hasPendingOnly || lhs.pendingOnly == rhs.pendingOnly)
            fieldCheck = fieldCheck && (lhs.hasIndexOffset == rhs.hasIndexOffset) && (!lhs.hasIndexOffset || lhs.indexOffset == rhs.indexOffset)
            fieldCheck = fieldCheck && (lhs.hasNumMaxInvoices == rhs.hasNumMaxInvoices) && (!lhs.hasNumMaxInvoices || lhs.numMaxInvoices == rhs.numMaxInvoices)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// If set, only unsettled invoices will be returned in the response.
        public fileprivate(set) var pendingOnly:Bool! = nil
        public fileprivate(set) var hasPendingOnly:Bool = false

        ///*
        ///The offset in the time series to start at. As each response can only contain
        ///50k invoices, callers can use this to skip around within a packed time
        ///series.
        public fileprivate(set) var indexOffset:UInt32! = nil
        public fileprivate(set) var hasIndexOffset:Bool = false

        //// The max number of invoices to return in the response to this query.
        public fileprivate(set) var numMaxInvoices:UInt32! = nil
        public fileprivate(set) var hasNumMaxInvoices:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasPendingOnly {
                try codedOutputStream.writeBool(fieldNumber: 1, value:pendingOnly)
            }
            if hasIndexOffset {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:indexOffset)
            }
            if hasNumMaxInvoices {
                try codedOutputStream.writeUInt32(fieldNumber: 5, value:numMaxInvoices)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasPendingOnly {
                serialize_size += pendingOnly.computeBoolSize(fieldNumber: 1)
            }
            if hasIndexOffset {
                serialize_size += indexOffset.computeUInt32Size(fieldNumber: 4)
            }
            if hasNumMaxInvoices {
                serialize_size += numMaxInvoices.computeUInt32Size(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ListInvoiceRequest.Builder {
            return Lnrpc.ListInvoiceRequest.classBuilder() as! Lnrpc.ListInvoiceRequest.Builder
        }
        public func getBuilder() -> Lnrpc.ListInvoiceRequest.Builder {
            return classBuilder() as! Lnrpc.ListInvoiceRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ListInvoiceRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ListInvoiceRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ListInvoiceRequest.Builder {
            return try Lnrpc.ListInvoiceRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ListInvoiceRequest) throws -> Lnrpc.ListInvoiceRequest.Builder {
            return try Lnrpc.ListInvoiceRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasPendingOnly {
                jsonMap["pending_only"] = pendingOnly
            }
            if hasIndexOffset {
                jsonMap["index_offset"] = UInt(indexOffset)
            }
            if hasNumMaxInvoices {
                jsonMap["num_max_invoices"] = UInt(numMaxInvoices)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ListInvoiceRequest {
            return try Lnrpc.ListInvoiceRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ListInvoiceRequest {
            return try Lnrpc.ListInvoiceRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasPendingOnly {
                output += "\(indent) pendingOnly: \(pendingOnly) \n"
            }
            if hasIndexOffset {
                output += "\(indent) indexOffset: \(indexOffset) \n"
            }
            if hasNumMaxInvoices {
                output += "\(indent) numMaxInvoices: \(numMaxInvoices) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasPendingOnly {
                    hashCode = (hashCode &* 31) &+ pendingOnly.hashValue
                }
                if hasIndexOffset {
                    hashCode = (hashCode &* 31) &+ indexOffset.hashValue
                }
                if hasNumMaxInvoices {
                    hashCode = (hashCode &* 31) &+ numMaxInvoices.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ListInvoiceRequest"
        }
        override public func className() -> String {
            return "Lnrpc.ListInvoiceRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ListInvoiceRequest = Lnrpc.ListInvoiceRequest()
            public func getMessage() -> Lnrpc.ListInvoiceRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// If set, only unsettled invoices will be returned in the response.
            public var pendingOnly:Bool {
                get {
                    return builderResult.pendingOnly
                }
                set (value) {
                    builderResult.hasPendingOnly = true
                    builderResult.pendingOnly = value
                }
            }
            public var hasPendingOnly:Bool {
                get {
                    return builderResult.hasPendingOnly
                }
            }
            @discardableResult
            public func setPendingOnly(_ value:Bool) -> Lnrpc.ListInvoiceRequest.Builder {
                self.pendingOnly = value
                return self
            }
            @discardableResult
            public func clearPendingOnly() -> Lnrpc.ListInvoiceRequest.Builder{
                builderResult.hasPendingOnly = false
                builderResult.pendingOnly = nil
                return self
            }
            ///*
            ///The offset in the time series to start at. As each response can only contain
            ///50k invoices, callers can use this to skip around within a packed time
            ///series.
            public var indexOffset:UInt32 {
                get {
                    return builderResult.indexOffset
                }
                set (value) {
                    builderResult.hasIndexOffset = true
                    builderResult.indexOffset = value
                }
            }
            public var hasIndexOffset:Bool {
                get {
                    return builderResult.hasIndexOffset
                }
            }
            @discardableResult
            public func setIndexOffset(_ value:UInt32) -> Lnrpc.ListInvoiceRequest.Builder {
                self.indexOffset = value
                return self
            }
            @discardableResult
            public func clearIndexOffset() -> Lnrpc.ListInvoiceRequest.Builder{
                builderResult.hasIndexOffset = false
                builderResult.indexOffset = nil
                return self
            }
            //// The max number of invoices to return in the response to this query.
            public var numMaxInvoices:UInt32 {
                get {
                    return builderResult.numMaxInvoices
                }
                set (value) {
                    builderResult.hasNumMaxInvoices = true
                    builderResult.numMaxInvoices = value
                }
            }
            public var hasNumMaxInvoices:Bool {
                get {
                    return builderResult.hasNumMaxInvoices
                }
            }
            @discardableResult
            public func setNumMaxInvoices(_ value:UInt32) -> Lnrpc.ListInvoiceRequest.Builder {
                self.numMaxInvoices = value
                return self
            }
            @discardableResult
            public func clearNumMaxInvoices() -> Lnrpc.ListInvoiceRequest.Builder{
                builderResult.hasNumMaxInvoices = false
                builderResult.numMaxInvoices = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ListInvoiceRequest.Builder {
                builderResult = Lnrpc.ListInvoiceRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.ListInvoiceRequest.Builder {
                return try Lnrpc.ListInvoiceRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ListInvoiceRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ListInvoiceRequest {
                let returnMe:Lnrpc.ListInvoiceRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ListInvoiceRequest) throws -> Lnrpc.ListInvoiceRequest.Builder {
                if other == Lnrpc.ListInvoiceRequest() {
                    return self
                }
                if other.hasPendingOnly {
                    pendingOnly = other.pendingOnly
                }
                if other.hasIndexOffset {
                    indexOffset = other.indexOffset
                }
                if other.hasNumMaxInvoices {
                    numMaxInvoices = other.numMaxInvoices
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ListInvoiceRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListInvoiceRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        pendingOnly = try codedInputStream.readBool()

                    case 32:
                        indexOffset = try codedInputStream.readUInt32()

                    case 40:
                        numMaxInvoices = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ListInvoiceRequest.Builder {
                let resultDecodedBuilder = Lnrpc.ListInvoiceRequest.Builder()
                if let jsonValuePendingOnly = jsonMap["pending_only"] as? Bool {
                    resultDecodedBuilder.pendingOnly = jsonValuePendingOnly
                }
                if let jsonValueIndexOffset = jsonMap["index_offset"] as? UInt {
                    resultDecodedBuilder.indexOffset = UInt32(jsonValueIndexOffset)
                } else if let jsonValueIndexOffset = jsonMap["index_offset"] as? String {
                    resultDecodedBuilder.indexOffset = UInt32(jsonValueIndexOffset)!
                }
                if let jsonValueNumMaxInvoices = jsonMap["num_max_invoices"] as? UInt {
                    resultDecodedBuilder.numMaxInvoices = UInt32(jsonValueNumMaxInvoices)
                } else if let jsonValueNumMaxInvoices = jsonMap["num_max_invoices"] as? String {
                    resultDecodedBuilder.numMaxInvoices = UInt32(jsonValueNumMaxInvoices)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ListInvoiceRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ListInvoiceRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ListInvoiceResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ListInvoiceResponse.Builder

        public static func == (lhs: Lnrpc.ListInvoiceResponse, rhs: Lnrpc.ListInvoiceResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.invoices == rhs.invoices)
            fieldCheck = fieldCheck && (lhs.hasLastIndexOffset == rhs.hasLastIndexOffset) && (!lhs.hasLastIndexOffset || lhs.lastIndexOffset == rhs.lastIndexOffset)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var invoices:Array<Lnrpc.Invoice>  = Array<Lnrpc.Invoice>()
        ///*
        ///The index of the last time in the set of returned invoices. Can be used to
        ///seek further, pagination style.
        public fileprivate(set) var lastIndexOffset:UInt32! = nil
        public fileprivate(set) var hasLastIndexOffset:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementInvoices in invoices {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementInvoices)
            }
            if hasLastIndexOffset {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:lastIndexOffset)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementInvoices in invoices {
                serialize_size += oneElementInvoices.computeMessageSize(fieldNumber: 1)
            }
            if hasLastIndexOffset {
                serialize_size += lastIndexOffset.computeUInt32Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ListInvoiceResponse.Builder {
            return Lnrpc.ListInvoiceResponse.classBuilder() as! Lnrpc.ListInvoiceResponse.Builder
        }
        public func getBuilder() -> Lnrpc.ListInvoiceResponse.Builder {
            return classBuilder() as! Lnrpc.ListInvoiceResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ListInvoiceResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ListInvoiceResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ListInvoiceResponse.Builder {
            return try Lnrpc.ListInvoiceResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ListInvoiceResponse) throws -> Lnrpc.ListInvoiceResponse.Builder {
            return try Lnrpc.ListInvoiceResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !invoices.isEmpty {
                var jsonArrayInvoices:Array<Dictionary<String,Any>> = []
                for oneValueInvoices in invoices {
                    let ecodedMessageInvoices = try oneValueInvoices.encode()
                    jsonArrayInvoices.append(ecodedMessageInvoices)
                }
                jsonMap["invoices"] = jsonArrayInvoices
            }
            if hasLastIndexOffset {
                jsonMap["last_index_offset"] = UInt(lastIndexOffset)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ListInvoiceResponse {
            return try Lnrpc.ListInvoiceResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ListInvoiceResponse {
            return try Lnrpc.ListInvoiceResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var invoicesElementIndex:Int = 0
            for oneElementInvoices in invoices {
                output += "\(indent) invoices[\(invoicesElementIndex)] {\n"
                output += try oneElementInvoices.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                invoicesElementIndex += 1
            }
            if hasLastIndexOffset {
                output += "\(indent) lastIndexOffset: \(lastIndexOffset) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementInvoices in invoices {
                    hashCode = (hashCode &* 31) &+ oneElementInvoices.hashValue
                }
                if hasLastIndexOffset {
                    hashCode = (hashCode &* 31) &+ lastIndexOffset.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ListInvoiceResponse"
        }
        override public func className() -> String {
            return "Lnrpc.ListInvoiceResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ListInvoiceResponse = Lnrpc.ListInvoiceResponse()
            public func getMessage() -> Lnrpc.ListInvoiceResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///*
            ///A list of invoices from the time slice of the time series specified in the
            ///request.
            public var invoices:Array<Lnrpc.Invoice> {
                get {
                    return builderResult.invoices
                }
                set (value) {
                    builderResult.invoices = value
                }
            }
            @discardableResult
            public func setInvoices(_ value:Array<Lnrpc.Invoice>) -> Lnrpc.ListInvoiceResponse.Builder {
                self.invoices = value
                return self
            }
            @discardableResult
            public func clearInvoices() -> Lnrpc.ListInvoiceResponse.Builder {
                builderResult.invoices.removeAll(keepingCapacity: false)
                return self
            }
            ///*
            ///The index of the last time in the set of returned invoices. Can be used to
            ///seek further, pagination style.
            public var lastIndexOffset:UInt32 {
                get {
                    return builderResult.lastIndexOffset
                }
                set (value) {
                    builderResult.hasLastIndexOffset = true
                    builderResult.lastIndexOffset = value
                }
            }
            public var hasLastIndexOffset:Bool {
                get {
                    return builderResult.hasLastIndexOffset
                }
            }
            @discardableResult
            public func setLastIndexOffset(_ value:UInt32) -> Lnrpc.ListInvoiceResponse.Builder {
                self.lastIndexOffset = value
                return self
            }
            @discardableResult
            public func clearLastIndexOffset() -> Lnrpc.ListInvoiceResponse.Builder{
                builderResult.hasLastIndexOffset = false
                builderResult.lastIndexOffset = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ListInvoiceResponse.Builder {
                builderResult = Lnrpc.ListInvoiceResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.ListInvoiceResponse.Builder {
                return try Lnrpc.ListInvoiceResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ListInvoiceResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ListInvoiceResponse {
                let returnMe:Lnrpc.ListInvoiceResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ListInvoiceResponse) throws -> Lnrpc.ListInvoiceResponse.Builder {
                if other == Lnrpc.ListInvoiceResponse() {
                    return self
                }
                if !other.invoices.isEmpty  {
                     builderResult.invoices += other.invoices
                }
                if other.hasLastIndexOffset {
                    lastIndexOffset = other.lastIndexOffset
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ListInvoiceResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListInvoiceResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Lnrpc.Invoice.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        invoices.append(subBuilder.buildPartial())

                    case 16:
                        lastIndexOffset = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ListInvoiceResponse.Builder {
                let resultDecodedBuilder = Lnrpc.ListInvoiceResponse.Builder()
                if let jsonValueInvoices = jsonMap["invoices"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayInvoices:Array<Lnrpc.Invoice> = []
                    for oneValueInvoices in jsonValueInvoices {
                        let messageFromStringInvoices = try Lnrpc.Invoice.Builder.decodeToBuilder(jsonMap:oneValueInvoices).build()

                        jsonArrayInvoices.append(messageFromStringInvoices)
                    }
                    resultDecodedBuilder.invoices = jsonArrayInvoices
                }
                if let jsonValueLastIndexOffset = jsonMap["last_index_offset"] as? UInt {
                    resultDecodedBuilder.lastIndexOffset = UInt32(jsonValueLastIndexOffset)
                } else if let jsonValueLastIndexOffset = jsonMap["last_index_offset"] as? String {
                    resultDecodedBuilder.lastIndexOffset = UInt32(jsonValueLastIndexOffset)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ListInvoiceResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ListInvoiceResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class InvoiceSubscription : GeneratedMessage {
        public typealias BuilderType = Lnrpc.InvoiceSubscription.Builder

        public static func == (lhs: Lnrpc.InvoiceSubscription, rhs: Lnrpc.InvoiceSubscription) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasAddIndex == rhs.hasAddIndex) && (!lhs.hasAddIndex || lhs.addIndex == rhs.addIndex)
            fieldCheck = fieldCheck && (lhs.hasSettleIndex == rhs.hasSettleIndex) && (!lhs.hasSettleIndex || lhs.settleIndex == rhs.settleIndex)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///*
        ///If specified (non-zero), then we'll first start by sending out
        ///notifications for all added indexes with an add_index greater than this
        ///value. This allows callers to catch up on any events they missed while they
        ///weren't connected to the streaming RPC.
        public fileprivate(set) var addIndex:UInt64! = nil
        public fileprivate(set) var hasAddIndex:Bool = false

        ///*
        ///If specified (non-zero), then we'll first start by sending out
        ///notifications for all settled indexes with an settle_index greater than
        ///this value. This allows callers to catch up on any events they missed while
        ///they weren't connected to the streaming RPC.
        public fileprivate(set) var settleIndex:UInt64! = nil
        public fileprivate(set) var hasSettleIndex:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasAddIndex {
                try codedOutputStream.writeUInt64(fieldNumber: 1, value:addIndex)
            }
            if hasSettleIndex {
                try codedOutputStream.writeUInt64(fieldNumber: 2, value:settleIndex)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasAddIndex {
                serialize_size += addIndex.computeUInt64Size(fieldNumber: 1)
            }
            if hasSettleIndex {
                serialize_size += settleIndex.computeUInt64Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.InvoiceSubscription.Builder {
            return Lnrpc.InvoiceSubscription.classBuilder() as! Lnrpc.InvoiceSubscription.Builder
        }
        public func getBuilder() -> Lnrpc.InvoiceSubscription.Builder {
            return classBuilder() as! Lnrpc.InvoiceSubscription.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.InvoiceSubscription.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.InvoiceSubscription.Builder()
        }
        public func toBuilder() throws -> Lnrpc.InvoiceSubscription.Builder {
            return try Lnrpc.InvoiceSubscription.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.InvoiceSubscription) throws -> Lnrpc.InvoiceSubscription.Builder {
            return try Lnrpc.InvoiceSubscription.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasAddIndex {
                jsonMap["add_index"] = "\(addIndex!)"
            }
            if hasSettleIndex {
                jsonMap["settle_index"] = "\(settleIndex!)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.InvoiceSubscription {
            return try Lnrpc.InvoiceSubscription.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.InvoiceSubscription {
            return try Lnrpc.InvoiceSubscription.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasAddIndex {
                output += "\(indent) addIndex: \(addIndex) \n"
            }
            if hasSettleIndex {
                output += "\(indent) settleIndex: \(settleIndex) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasAddIndex {
                    hashCode = (hashCode &* 31) &+ addIndex.hashValue
                }
                if hasSettleIndex {
                    hashCode = (hashCode &* 31) &+ settleIndex.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.InvoiceSubscription"
        }
        override public func className() -> String {
            return "Lnrpc.InvoiceSubscription"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.InvoiceSubscription = Lnrpc.InvoiceSubscription()
            public func getMessage() -> Lnrpc.InvoiceSubscription {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///*
            ///If specified (non-zero), then we'll first start by sending out
            ///notifications for all added indexes with an add_index greater than this
            ///value. This allows callers to catch up on any events they missed while they
            ///weren't connected to the streaming RPC.
            public var addIndex:UInt64 {
                get {
                    return builderResult.addIndex
                }
                set (value) {
                    builderResult.hasAddIndex = true
                    builderResult.addIndex = value
                }
            }
            public var hasAddIndex:Bool {
                get {
                    return builderResult.hasAddIndex
                }
            }
            @discardableResult
            public func setAddIndex(_ value:UInt64) -> Lnrpc.InvoiceSubscription.Builder {
                self.addIndex = value
                return self
            }
            @discardableResult
            public func clearAddIndex() -> Lnrpc.InvoiceSubscription.Builder{
                builderResult.hasAddIndex = false
                builderResult.addIndex = nil
                return self
            }
            ///*
            ///If specified (non-zero), then we'll first start by sending out
            ///notifications for all settled indexes with an settle_index greater than
            ///this value. This allows callers to catch up on any events they missed while
            ///they weren't connected to the streaming RPC.
            public var settleIndex:UInt64 {
                get {
                    return builderResult.settleIndex
                }
                set (value) {
                    builderResult.hasSettleIndex = true
                    builderResult.settleIndex = value
                }
            }
            public var hasSettleIndex:Bool {
                get {
                    return builderResult.hasSettleIndex
                }
            }
            @discardableResult
            public func setSettleIndex(_ value:UInt64) -> Lnrpc.InvoiceSubscription.Builder {
                self.settleIndex = value
                return self
            }
            @discardableResult
            public func clearSettleIndex() -> Lnrpc.InvoiceSubscription.Builder{
                builderResult.hasSettleIndex = false
                builderResult.settleIndex = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.InvoiceSubscription.Builder {
                builderResult = Lnrpc.InvoiceSubscription()
                return self
            }
            override public func clone() throws -> Lnrpc.InvoiceSubscription.Builder {
                return try Lnrpc.InvoiceSubscription.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.InvoiceSubscription {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.InvoiceSubscription {
                let returnMe:Lnrpc.InvoiceSubscription = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.InvoiceSubscription) throws -> Lnrpc.InvoiceSubscription.Builder {
                if other == Lnrpc.InvoiceSubscription() {
                    return self
                }
                if other.hasAddIndex {
                    addIndex = other.addIndex
                }
                if other.hasSettleIndex {
                    settleIndex = other.settleIndex
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.InvoiceSubscription.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.InvoiceSubscription.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        addIndex = try codedInputStream.readUInt64()

                    case 16:
                        settleIndex = try codedInputStream.readUInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.InvoiceSubscription.Builder {
                let resultDecodedBuilder = Lnrpc.InvoiceSubscription.Builder()
                if let jsonValueAddIndex = jsonMap["add_index"] as? String {
                    resultDecodedBuilder.addIndex = UInt64(jsonValueAddIndex)!
                } else if let jsonValueAddIndex = jsonMap["add_index"] as? UInt {
                    resultDecodedBuilder.addIndex = UInt64(jsonValueAddIndex)
                }
                if let jsonValueSettleIndex = jsonMap["settle_index"] as? String {
                    resultDecodedBuilder.settleIndex = UInt64(jsonValueSettleIndex)!
                } else if let jsonValueSettleIndex = jsonMap["settle_index"] as? UInt {
                    resultDecodedBuilder.settleIndex = UInt64(jsonValueSettleIndex)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.InvoiceSubscription.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.InvoiceSubscription.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class Payment : GeneratedMessage {
        public typealias BuilderType = Lnrpc.Payment.Builder

        public static func == (lhs: Lnrpc.Payment, rhs: Lnrpc.Payment) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasPaymentHash == rhs.hasPaymentHash) && (!lhs.hasPaymentHash || lhs.paymentHash == rhs.paymentHash)
            fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
            fieldCheck = fieldCheck && (lhs.hasCreationDate == rhs.hasCreationDate) && (!lhs.hasCreationDate || lhs.creationDate == rhs.creationDate)
            fieldCheck = fieldCheck && (lhs.path == rhs.path)
            fieldCheck = fieldCheck && (lhs.hasFee == rhs.hasFee) && (!lhs.hasFee || lhs.fee == rhs.fee)
            fieldCheck = fieldCheck && (lhs.hasPaymentPreimage == rhs.hasPaymentPreimage) && (!lhs.hasPaymentPreimage || lhs.paymentPreimage == rhs.paymentPreimage)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// The payment hash
        public fileprivate(set) var paymentHash:String! = nil
        public fileprivate(set) var hasPaymentHash:Bool = false

        //// The value of the payment in satoshis
        public fileprivate(set) var value:Int64! = nil
        public fileprivate(set) var hasValue:Bool = false

        //// The date of this payment
        public fileprivate(set) var creationDate:Int64! = nil
        public fileprivate(set) var hasCreationDate:Bool = false

        //// The path this payment took
        public fileprivate(set) var path:Array<String> = Array<String>()
        //// The fee paid for this payment in satoshis
        public fileprivate(set) var fee:Int64! = nil
        public fileprivate(set) var hasFee:Bool = false

        //// The payment preimage
        public fileprivate(set) var paymentPreimage:String! = nil
        public fileprivate(set) var hasPaymentPreimage:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasPaymentHash {
                try codedOutputStream.writeString(fieldNumber: 1, value:paymentHash)
            }
            if hasValue {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:value)
            }
            if hasCreationDate {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:creationDate)
            }
            if !path.isEmpty {
                for oneValuepath in path {
                    try codedOutputStream.writeString(fieldNumber: 4, value:oneValuepath)
                }
            }
            if hasFee {
                try codedOutputStream.writeInt64(fieldNumber: 5, value:fee)
            }
            if hasPaymentPreimage {
                try codedOutputStream.writeString(fieldNumber: 6, value:paymentPreimage)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasPaymentHash {
                serialize_size += paymentHash.computeStringSize(fieldNumber: 1)
            }
            if hasValue {
                serialize_size += value.computeInt64Size(fieldNumber: 2)
            }
            if hasCreationDate {
                serialize_size += creationDate.computeInt64Size(fieldNumber: 3)
            }
            var dataSizePath:Int32 = 0
            for oneValuepath in path {
                dataSizePath += oneValuepath.computeStringSizeNoTag()
            }
            serialize_size += dataSizePath
            serialize_size += 1 * Int32(path.count)
            if hasFee {
                serialize_size += fee.computeInt64Size(fieldNumber: 5)
            }
            if hasPaymentPreimage {
                serialize_size += paymentPreimage.computeStringSize(fieldNumber: 6)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.Payment.Builder {
            return Lnrpc.Payment.classBuilder() as! Lnrpc.Payment.Builder
        }
        public func getBuilder() -> Lnrpc.Payment.Builder {
            return classBuilder() as! Lnrpc.Payment.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.Payment.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.Payment.Builder()
        }
        public func toBuilder() throws -> Lnrpc.Payment.Builder {
            return try Lnrpc.Payment.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.Payment) throws -> Lnrpc.Payment.Builder {
            return try Lnrpc.Payment.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasPaymentHash {
                jsonMap["payment_hash"] = paymentHash
            }
            if hasValue {
                jsonMap["value"] = "\(value!)"
            }
            if hasCreationDate {
                jsonMap["creation_date"] = "\(creationDate!)"
            }
            if !path.isEmpty {
                var jsonArrayPath:Array<String> = []
                for oneValuePath in path {
                    jsonArrayPath.append(oneValuePath)
                }
                jsonMap["path"] = jsonArrayPath
            }
            if hasFee {
                jsonMap["fee"] = "\(fee!)"
            }
            if hasPaymentPreimage {
                jsonMap["payment_preimage"] = paymentPreimage
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.Payment {
            return try Lnrpc.Payment.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.Payment {
            return try Lnrpc.Payment.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasPaymentHash {
                output += "\(indent) paymentHash: \(paymentHash) \n"
            }
            if hasValue {
                output += "\(indent) value: \(value) \n"
            }
            if hasCreationDate {
                output += "\(indent) creationDate: \(creationDate) \n"
            }
            var pathElementIndex:Int = 0
            for oneValuePath in path  {
                output += "\(indent) path[\(pathElementIndex)]: \(oneValuePath)\n"
                pathElementIndex += 1
            }
            if hasFee {
                output += "\(indent) fee: \(fee) \n"
            }
            if hasPaymentPreimage {
                output += "\(indent) paymentPreimage: \(paymentPreimage) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasPaymentHash {
                    hashCode = (hashCode &* 31) &+ paymentHash.hashValue
                }
                if hasValue {
                    hashCode = (hashCode &* 31) &+ value.hashValue
                }
                if hasCreationDate {
                    hashCode = (hashCode &* 31) &+ creationDate.hashValue
                }
                for oneValuePath in path {
                    hashCode = (hashCode &* 31) &+ oneValuePath.hashValue
                }
                if hasFee {
                    hashCode = (hashCode &* 31) &+ fee.hashValue
                }
                if hasPaymentPreimage {
                    hashCode = (hashCode &* 31) &+ paymentPreimage.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.Payment"
        }
        override public func className() -> String {
            return "Lnrpc.Payment"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.Payment = Lnrpc.Payment()
            public func getMessage() -> Lnrpc.Payment {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The payment hash
            public var paymentHash:String {
                get {
                    return builderResult.paymentHash
                }
                set (value) {
                    builderResult.hasPaymentHash = true
                    builderResult.paymentHash = value
                }
            }
            public var hasPaymentHash:Bool {
                get {
                    return builderResult.hasPaymentHash
                }
            }
            @discardableResult
            public func setPaymentHash(_ value:String) -> Lnrpc.Payment.Builder {
                self.paymentHash = value
                return self
            }
            @discardableResult
            public func clearPaymentHash() -> Lnrpc.Payment.Builder{
                builderResult.hasPaymentHash = false
                builderResult.paymentHash = nil
                return self
            }
            //// The value of the payment in satoshis
            public var value:Int64 {
                get {
                    return builderResult.value
                }
                set (value) {
                    builderResult.hasValue = true
                    builderResult.value = value
                }
            }
            public var hasValue:Bool {
                get {
                    return builderResult.hasValue
                }
            }
            @discardableResult
            public func setValue(_ value:Int64) -> Lnrpc.Payment.Builder {
                self.value = value
                return self
            }
            @discardableResult
            public func clearValue() -> Lnrpc.Payment.Builder{
                builderResult.hasValue = false
                builderResult.value = nil
                return self
            }
            //// The date of this payment
            public var creationDate:Int64 {
                get {
                    return builderResult.creationDate
                }
                set (value) {
                    builderResult.hasCreationDate = true
                    builderResult.creationDate = value
                }
            }
            public var hasCreationDate:Bool {
                get {
                    return builderResult.hasCreationDate
                }
            }
            @discardableResult
            public func setCreationDate(_ value:Int64) -> Lnrpc.Payment.Builder {
                self.creationDate = value
                return self
            }
            @discardableResult
            public func clearCreationDate() -> Lnrpc.Payment.Builder{
                builderResult.hasCreationDate = false
                builderResult.creationDate = nil
                return self
            }
            //// The path this payment took
            public var path:Array<String> {
                get {
                    return builderResult.path
                }
                set (array) {
                    builderResult.path = array
                }
            }
            @discardableResult
            public func setPath(_ value:Array<String>) -> Lnrpc.Payment.Builder {
                self.path = value
                return self
            }
            @discardableResult
            public func clearPath() -> Lnrpc.Payment.Builder {
                builderResult.path.removeAll(keepingCapacity: false)
                return self
            }
            //// The fee paid for this payment in satoshis
            public var fee:Int64 {
                get {
                    return builderResult.fee
                }
                set (value) {
                    builderResult.hasFee = true
                    builderResult.fee = value
                }
            }
            public var hasFee:Bool {
                get {
                    return builderResult.hasFee
                }
            }
            @discardableResult
            public func setFee(_ value:Int64) -> Lnrpc.Payment.Builder {
                self.fee = value
                return self
            }
            @discardableResult
            public func clearFee() -> Lnrpc.Payment.Builder{
                builderResult.hasFee = false
                builderResult.fee = nil
                return self
            }
            //// The payment preimage
            public var paymentPreimage:String {
                get {
                    return builderResult.paymentPreimage
                }
                set (value) {
                    builderResult.hasPaymentPreimage = true
                    builderResult.paymentPreimage = value
                }
            }
            public var hasPaymentPreimage:Bool {
                get {
                    return builderResult.hasPaymentPreimage
                }
            }
            @discardableResult
            public func setPaymentPreimage(_ value:String) -> Lnrpc.Payment.Builder {
                self.paymentPreimage = value
                return self
            }
            @discardableResult
            public func clearPaymentPreimage() -> Lnrpc.Payment.Builder{
                builderResult.hasPaymentPreimage = false
                builderResult.paymentPreimage = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.Payment.Builder {
                builderResult = Lnrpc.Payment()
                return self
            }
            override public func clone() throws -> Lnrpc.Payment.Builder {
                return try Lnrpc.Payment.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.Payment {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.Payment {
                let returnMe:Lnrpc.Payment = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.Payment) throws -> Lnrpc.Payment.Builder {
                if other == Lnrpc.Payment() {
                    return self
                }
                if other.hasPaymentHash {
                    paymentHash = other.paymentHash
                }
                if other.hasValue {
                    value = other.value
                }
                if other.hasCreationDate {
                    creationDate = other.creationDate
                }
                if !other.path.isEmpty {
                    builderResult.path += other.path
                }
                if other.hasFee {
                    fee = other.fee
                }
                if other.hasPaymentPreimage {
                    paymentPreimage = other.paymentPreimage
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.Payment.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Payment.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        paymentHash = try codedInputStream.readString()

                    case 16:
                        value = try codedInputStream.readInt64()

                    case 24:
                        creationDate = try codedInputStream.readInt64()

                    case 34:
                        path += [try codedInputStream.readString()]

                    case 40:
                        fee = try codedInputStream.readInt64()

                    case 50:
                        paymentPreimage = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.Payment.Builder {
                let resultDecodedBuilder = Lnrpc.Payment.Builder()
                if let jsonValuePaymentHash = jsonMap["payment_hash"] as? String {
                    resultDecodedBuilder.paymentHash = jsonValuePaymentHash
                }
                if let jsonValueValue = jsonMap["value"] as? String {
                    resultDecodedBuilder.value = Int64(jsonValueValue)!
                } else if let jsonValueValue = jsonMap["value"] as? Int {
                    resultDecodedBuilder.value = Int64(jsonValueValue)
                }
                if let jsonValueCreationDate = jsonMap["creation_date"] as? String {
                    resultDecodedBuilder.creationDate = Int64(jsonValueCreationDate)!
                } else if let jsonValueCreationDate = jsonMap["creation_date"] as? Int {
                    resultDecodedBuilder.creationDate = Int64(jsonValueCreationDate)
                }
                if let jsonValuePath = jsonMap["path"] as? Array<String> {
                    var jsonArrayPath:Array<String> = []
                    for oneValuePath in jsonValuePath {
                        jsonArrayPath.append(oneValuePath)
                    }
                    resultDecodedBuilder.path = jsonArrayPath
                }
                if let jsonValueFee = jsonMap["fee"] as? String {
                    resultDecodedBuilder.fee = Int64(jsonValueFee)!
                } else if let jsonValueFee = jsonMap["fee"] as? Int {
                    resultDecodedBuilder.fee = Int64(jsonValueFee)
                }
                if let jsonValuePaymentPreimage = jsonMap["payment_preimage"] as? String {
                    resultDecodedBuilder.paymentPreimage = jsonValuePaymentPreimage
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.Payment.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.Payment.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ListPaymentsRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ListPaymentsRequest.Builder

        public static func == (lhs: Lnrpc.ListPaymentsRequest, rhs: Lnrpc.ListPaymentsRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ListPaymentsRequest.Builder {
            return Lnrpc.ListPaymentsRequest.classBuilder() as! Lnrpc.ListPaymentsRequest.Builder
        }
        public func getBuilder() -> Lnrpc.ListPaymentsRequest.Builder {
            return classBuilder() as! Lnrpc.ListPaymentsRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ListPaymentsRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ListPaymentsRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ListPaymentsRequest.Builder {
            return try Lnrpc.ListPaymentsRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ListPaymentsRequest) throws -> Lnrpc.ListPaymentsRequest.Builder {
            return try Lnrpc.ListPaymentsRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ListPaymentsRequest {
            return try Lnrpc.ListPaymentsRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ListPaymentsRequest {
            return try Lnrpc.ListPaymentsRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ListPaymentsRequest"
        }
        override public func className() -> String {
            return "Lnrpc.ListPaymentsRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ListPaymentsRequest = Lnrpc.ListPaymentsRequest()
            public func getMessage() -> Lnrpc.ListPaymentsRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ListPaymentsRequest.Builder {
                builderResult = Lnrpc.ListPaymentsRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.ListPaymentsRequest.Builder {
                return try Lnrpc.ListPaymentsRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ListPaymentsRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ListPaymentsRequest {
                let returnMe:Lnrpc.ListPaymentsRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ListPaymentsRequest) throws -> Lnrpc.ListPaymentsRequest.Builder {
                if other == Lnrpc.ListPaymentsRequest() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ListPaymentsRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListPaymentsRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ListPaymentsRequest.Builder {
                let resultDecodedBuilder = Lnrpc.ListPaymentsRequest.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ListPaymentsRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ListPaymentsRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ListPaymentsResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ListPaymentsResponse.Builder

        public static func == (lhs: Lnrpc.ListPaymentsResponse, rhs: Lnrpc.ListPaymentsResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.payments == rhs.payments)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var payments:Array<Lnrpc.Payment>  = Array<Lnrpc.Payment>()
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementPayments in payments {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementPayments)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementPayments in payments {
                serialize_size += oneElementPayments.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ListPaymentsResponse.Builder {
            return Lnrpc.ListPaymentsResponse.classBuilder() as! Lnrpc.ListPaymentsResponse.Builder
        }
        public func getBuilder() -> Lnrpc.ListPaymentsResponse.Builder {
            return classBuilder() as! Lnrpc.ListPaymentsResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ListPaymentsResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ListPaymentsResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ListPaymentsResponse.Builder {
            return try Lnrpc.ListPaymentsResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ListPaymentsResponse) throws -> Lnrpc.ListPaymentsResponse.Builder {
            return try Lnrpc.ListPaymentsResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !payments.isEmpty {
                var jsonArrayPayments:Array<Dictionary<String,Any>> = []
                for oneValuePayments in payments {
                    let ecodedMessagePayments = try oneValuePayments.encode()
                    jsonArrayPayments.append(ecodedMessagePayments)
                }
                jsonMap["payments"] = jsonArrayPayments
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ListPaymentsResponse {
            return try Lnrpc.ListPaymentsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ListPaymentsResponse {
            return try Lnrpc.ListPaymentsResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var paymentsElementIndex:Int = 0
            for oneElementPayments in payments {
                output += "\(indent) payments[\(paymentsElementIndex)] {\n"
                output += try oneElementPayments.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                paymentsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementPayments in payments {
                    hashCode = (hashCode &* 31) &+ oneElementPayments.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ListPaymentsResponse"
        }
        override public func className() -> String {
            return "Lnrpc.ListPaymentsResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ListPaymentsResponse = Lnrpc.ListPaymentsResponse()
            public func getMessage() -> Lnrpc.ListPaymentsResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The list of payments
            public var payments:Array<Lnrpc.Payment> {
                get {
                    return builderResult.payments
                }
                set (value) {
                    builderResult.payments = value
                }
            }
            @discardableResult
            public func setPayments(_ value:Array<Lnrpc.Payment>) -> Lnrpc.ListPaymentsResponse.Builder {
                self.payments = value
                return self
            }
            @discardableResult
            public func clearPayments() -> Lnrpc.ListPaymentsResponse.Builder {
                builderResult.payments.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ListPaymentsResponse.Builder {
                builderResult = Lnrpc.ListPaymentsResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.ListPaymentsResponse.Builder {
                return try Lnrpc.ListPaymentsResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ListPaymentsResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ListPaymentsResponse {
                let returnMe:Lnrpc.ListPaymentsResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ListPaymentsResponse) throws -> Lnrpc.ListPaymentsResponse.Builder {
                if other == Lnrpc.ListPaymentsResponse() {
                    return self
                }
                if !other.payments.isEmpty  {
                     builderResult.payments += other.payments
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ListPaymentsResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListPaymentsResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Lnrpc.Payment.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        payments.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ListPaymentsResponse.Builder {
                let resultDecodedBuilder = Lnrpc.ListPaymentsResponse.Builder()
                if let jsonValuePayments = jsonMap["payments"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayPayments:Array<Lnrpc.Payment> = []
                    for oneValuePayments in jsonValuePayments {
                        let messageFromStringPayments = try Lnrpc.Payment.Builder.decodeToBuilder(jsonMap:oneValuePayments).build()

                        jsonArrayPayments.append(messageFromStringPayments)
                    }
                    resultDecodedBuilder.payments = jsonArrayPayments
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ListPaymentsResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ListPaymentsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class DeleteAllPaymentsRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.DeleteAllPaymentsRequest.Builder

        public static func == (lhs: Lnrpc.DeleteAllPaymentsRequest, rhs: Lnrpc.DeleteAllPaymentsRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.DeleteAllPaymentsRequest.Builder {
            return Lnrpc.DeleteAllPaymentsRequest.classBuilder() as! Lnrpc.DeleteAllPaymentsRequest.Builder
        }
        public func getBuilder() -> Lnrpc.DeleteAllPaymentsRequest.Builder {
            return classBuilder() as! Lnrpc.DeleteAllPaymentsRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.DeleteAllPaymentsRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.DeleteAllPaymentsRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.DeleteAllPaymentsRequest.Builder {
            return try Lnrpc.DeleteAllPaymentsRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.DeleteAllPaymentsRequest) throws -> Lnrpc.DeleteAllPaymentsRequest.Builder {
            return try Lnrpc.DeleteAllPaymentsRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.DeleteAllPaymentsRequest {
            return try Lnrpc.DeleteAllPaymentsRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.DeleteAllPaymentsRequest {
            return try Lnrpc.DeleteAllPaymentsRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.DeleteAllPaymentsRequest"
        }
        override public func className() -> String {
            return "Lnrpc.DeleteAllPaymentsRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.DeleteAllPaymentsRequest = Lnrpc.DeleteAllPaymentsRequest()
            public func getMessage() -> Lnrpc.DeleteAllPaymentsRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.DeleteAllPaymentsRequest.Builder {
                builderResult = Lnrpc.DeleteAllPaymentsRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.DeleteAllPaymentsRequest.Builder {
                return try Lnrpc.DeleteAllPaymentsRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.DeleteAllPaymentsRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.DeleteAllPaymentsRequest {
                let returnMe:Lnrpc.DeleteAllPaymentsRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.DeleteAllPaymentsRequest) throws -> Lnrpc.DeleteAllPaymentsRequest.Builder {
                if other == Lnrpc.DeleteAllPaymentsRequest() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.DeleteAllPaymentsRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.DeleteAllPaymentsRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.DeleteAllPaymentsRequest.Builder {
                let resultDecodedBuilder = Lnrpc.DeleteAllPaymentsRequest.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.DeleteAllPaymentsRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.DeleteAllPaymentsRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class DeleteAllPaymentsResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.DeleteAllPaymentsResponse.Builder

        public static func == (lhs: Lnrpc.DeleteAllPaymentsResponse, rhs: Lnrpc.DeleteAllPaymentsResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.DeleteAllPaymentsResponse.Builder {
            return Lnrpc.DeleteAllPaymentsResponse.classBuilder() as! Lnrpc.DeleteAllPaymentsResponse.Builder
        }
        public func getBuilder() -> Lnrpc.DeleteAllPaymentsResponse.Builder {
            return classBuilder() as! Lnrpc.DeleteAllPaymentsResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.DeleteAllPaymentsResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.DeleteAllPaymentsResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.DeleteAllPaymentsResponse.Builder {
            return try Lnrpc.DeleteAllPaymentsResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.DeleteAllPaymentsResponse) throws -> Lnrpc.DeleteAllPaymentsResponse.Builder {
            return try Lnrpc.DeleteAllPaymentsResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.DeleteAllPaymentsResponse {
            return try Lnrpc.DeleteAllPaymentsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.DeleteAllPaymentsResponse {
            return try Lnrpc.DeleteAllPaymentsResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.DeleteAllPaymentsResponse"
        }
        override public func className() -> String {
            return "Lnrpc.DeleteAllPaymentsResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.DeleteAllPaymentsResponse = Lnrpc.DeleteAllPaymentsResponse()
            public func getMessage() -> Lnrpc.DeleteAllPaymentsResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.DeleteAllPaymentsResponse.Builder {
                builderResult = Lnrpc.DeleteAllPaymentsResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.DeleteAllPaymentsResponse.Builder {
                return try Lnrpc.DeleteAllPaymentsResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.DeleteAllPaymentsResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.DeleteAllPaymentsResponse {
                let returnMe:Lnrpc.DeleteAllPaymentsResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.DeleteAllPaymentsResponse) throws -> Lnrpc.DeleteAllPaymentsResponse.Builder {
                if other == Lnrpc.DeleteAllPaymentsResponse() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.DeleteAllPaymentsResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.DeleteAllPaymentsResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.DeleteAllPaymentsResponse.Builder {
                let resultDecodedBuilder = Lnrpc.DeleteAllPaymentsResponse.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.DeleteAllPaymentsResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.DeleteAllPaymentsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class DebugLevelRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.DebugLevelRequest.Builder

        public static func == (lhs: Lnrpc.DebugLevelRequest, rhs: Lnrpc.DebugLevelRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasShow == rhs.hasShow) && (!lhs.hasShow || lhs.show == rhs.show)
            fieldCheck = fieldCheck && (lhs.hasLevelSpec == rhs.hasLevelSpec) && (!lhs.hasLevelSpec || lhs.levelSpec == rhs.levelSpec)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var show:Bool! = nil
        public fileprivate(set) var hasShow:Bool = false

        public fileprivate(set) var levelSpec:String! = nil
        public fileprivate(set) var hasLevelSpec:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasShow {
                try codedOutputStream.writeBool(fieldNumber: 1, value:show)
            }
            if hasLevelSpec {
                try codedOutputStream.writeString(fieldNumber: 2, value:levelSpec)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasShow {
                serialize_size += show.computeBoolSize(fieldNumber: 1)
            }
            if hasLevelSpec {
                serialize_size += levelSpec.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.DebugLevelRequest.Builder {
            return Lnrpc.DebugLevelRequest.classBuilder() as! Lnrpc.DebugLevelRequest.Builder
        }
        public func getBuilder() -> Lnrpc.DebugLevelRequest.Builder {
            return classBuilder() as! Lnrpc.DebugLevelRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.DebugLevelRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.DebugLevelRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.DebugLevelRequest.Builder {
            return try Lnrpc.DebugLevelRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.DebugLevelRequest) throws -> Lnrpc.DebugLevelRequest.Builder {
            return try Lnrpc.DebugLevelRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasShow {
                jsonMap["show"] = show
            }
            if hasLevelSpec {
                jsonMap["levelSpec"] = levelSpec
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.DebugLevelRequest {
            return try Lnrpc.DebugLevelRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.DebugLevelRequest {
            return try Lnrpc.DebugLevelRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasShow {
                output += "\(indent) show: \(show) \n"
            }
            if hasLevelSpec {
                output += "\(indent) levelSpec: \(levelSpec) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasShow {
                    hashCode = (hashCode &* 31) &+ show.hashValue
                }
                if hasLevelSpec {
                    hashCode = (hashCode &* 31) &+ levelSpec.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.DebugLevelRequest"
        }
        override public func className() -> String {
            return "Lnrpc.DebugLevelRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.DebugLevelRequest = Lnrpc.DebugLevelRequest()
            public func getMessage() -> Lnrpc.DebugLevelRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var show:Bool {
                get {
                    return builderResult.show
                }
                set (value) {
                    builderResult.hasShow = true
                    builderResult.show = value
                }
            }
            public var hasShow:Bool {
                get {
                    return builderResult.hasShow
                }
            }
            @discardableResult
            public func setShow(_ value:Bool) -> Lnrpc.DebugLevelRequest.Builder {
                self.show = value
                return self
            }
            @discardableResult
            public func clearShow() -> Lnrpc.DebugLevelRequest.Builder{
                builderResult.hasShow = false
                builderResult.show = nil
                return self
            }
            public var levelSpec:String {
                get {
                    return builderResult.levelSpec
                }
                set (value) {
                    builderResult.hasLevelSpec = true
                    builderResult.levelSpec = value
                }
            }
            public var hasLevelSpec:Bool {
                get {
                    return builderResult.hasLevelSpec
                }
            }
            @discardableResult
            public func setLevelSpec(_ value:String) -> Lnrpc.DebugLevelRequest.Builder {
                self.levelSpec = value
                return self
            }
            @discardableResult
            public func clearLevelSpec() -> Lnrpc.DebugLevelRequest.Builder{
                builderResult.hasLevelSpec = false
                builderResult.levelSpec = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.DebugLevelRequest.Builder {
                builderResult = Lnrpc.DebugLevelRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.DebugLevelRequest.Builder {
                return try Lnrpc.DebugLevelRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.DebugLevelRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.DebugLevelRequest {
                let returnMe:Lnrpc.DebugLevelRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.DebugLevelRequest) throws -> Lnrpc.DebugLevelRequest.Builder {
                if other == Lnrpc.DebugLevelRequest() {
                    return self
                }
                if other.hasShow {
                    show = other.show
                }
                if other.hasLevelSpec {
                    levelSpec = other.levelSpec
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.DebugLevelRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.DebugLevelRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        show = try codedInputStream.readBool()

                    case 18:
                        levelSpec = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.DebugLevelRequest.Builder {
                let resultDecodedBuilder = Lnrpc.DebugLevelRequest.Builder()
                if let jsonValueShow = jsonMap["show"] as? Bool {
                    resultDecodedBuilder.show = jsonValueShow
                }
                if let jsonValueLevelSpec = jsonMap["levelSpec"] as? String {
                    resultDecodedBuilder.levelSpec = jsonValueLevelSpec
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.DebugLevelRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.DebugLevelRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class DebugLevelResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.DebugLevelResponse.Builder

        public static func == (lhs: Lnrpc.DebugLevelResponse, rhs: Lnrpc.DebugLevelResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasSubSystems == rhs.hasSubSystems) && (!lhs.hasSubSystems || lhs.subSystems == rhs.subSystems)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var subSystems:String! = nil
        public fileprivate(set) var hasSubSystems:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasSubSystems {
                try codedOutputStream.writeString(fieldNumber: 1, value:subSystems)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasSubSystems {
                serialize_size += subSystems.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.DebugLevelResponse.Builder {
            return Lnrpc.DebugLevelResponse.classBuilder() as! Lnrpc.DebugLevelResponse.Builder
        }
        public func getBuilder() -> Lnrpc.DebugLevelResponse.Builder {
            return classBuilder() as! Lnrpc.DebugLevelResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.DebugLevelResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.DebugLevelResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.DebugLevelResponse.Builder {
            return try Lnrpc.DebugLevelResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.DebugLevelResponse) throws -> Lnrpc.DebugLevelResponse.Builder {
            return try Lnrpc.DebugLevelResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasSubSystems {
                jsonMap["sub_systems"] = subSystems
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.DebugLevelResponse {
            return try Lnrpc.DebugLevelResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.DebugLevelResponse {
            return try Lnrpc.DebugLevelResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasSubSystems {
                output += "\(indent) subSystems: \(subSystems) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasSubSystems {
                    hashCode = (hashCode &* 31) &+ subSystems.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.DebugLevelResponse"
        }
        override public func className() -> String {
            return "Lnrpc.DebugLevelResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.DebugLevelResponse = Lnrpc.DebugLevelResponse()
            public func getMessage() -> Lnrpc.DebugLevelResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var subSystems:String {
                get {
                    return builderResult.subSystems
                }
                set (value) {
                    builderResult.hasSubSystems = true
                    builderResult.subSystems = value
                }
            }
            public var hasSubSystems:Bool {
                get {
                    return builderResult.hasSubSystems
                }
            }
            @discardableResult
            public func setSubSystems(_ value:String) -> Lnrpc.DebugLevelResponse.Builder {
                self.subSystems = value
                return self
            }
            @discardableResult
            public func clearSubSystems() -> Lnrpc.DebugLevelResponse.Builder{
                builderResult.hasSubSystems = false
                builderResult.subSystems = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.DebugLevelResponse.Builder {
                builderResult = Lnrpc.DebugLevelResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.DebugLevelResponse.Builder {
                return try Lnrpc.DebugLevelResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.DebugLevelResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.DebugLevelResponse {
                let returnMe:Lnrpc.DebugLevelResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.DebugLevelResponse) throws -> Lnrpc.DebugLevelResponse.Builder {
                if other == Lnrpc.DebugLevelResponse() {
                    return self
                }
                if other.hasSubSystems {
                    subSystems = other.subSystems
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.DebugLevelResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.DebugLevelResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        subSystems = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.DebugLevelResponse.Builder {
                let resultDecodedBuilder = Lnrpc.DebugLevelResponse.Builder()
                if let jsonValueSubSystems = jsonMap["sub_systems"] as? String {
                    resultDecodedBuilder.subSystems = jsonValueSubSystems
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.DebugLevelResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.DebugLevelResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class PayReqString : GeneratedMessage {
        public typealias BuilderType = Lnrpc.PayReqString.Builder

        public static func == (lhs: Lnrpc.PayReqString, rhs: Lnrpc.PayReqString) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasPayReq == rhs.hasPayReq) && (!lhs.hasPayReq || lhs.payReq == rhs.payReq)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// The payment request string to be decoded
        public fileprivate(set) var payReq:String! = nil
        public fileprivate(set) var hasPayReq:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasPayReq {
                try codedOutputStream.writeString(fieldNumber: 1, value:payReq)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasPayReq {
                serialize_size += payReq.computeStringSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.PayReqString.Builder {
            return Lnrpc.PayReqString.classBuilder() as! Lnrpc.PayReqString.Builder
        }
        public func getBuilder() -> Lnrpc.PayReqString.Builder {
            return classBuilder() as! Lnrpc.PayReqString.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.PayReqString.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.PayReqString.Builder()
        }
        public func toBuilder() throws -> Lnrpc.PayReqString.Builder {
            return try Lnrpc.PayReqString.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.PayReqString) throws -> Lnrpc.PayReqString.Builder {
            return try Lnrpc.PayReqString.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasPayReq {
                jsonMap["payReq"] = payReq
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PayReqString {
            return try Lnrpc.PayReqString.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PayReqString {
            return try Lnrpc.PayReqString.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasPayReq {
                output += "\(indent) payReq: \(payReq) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasPayReq {
                    hashCode = (hashCode &* 31) &+ payReq.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.PayReqString"
        }
        override public func className() -> String {
            return "Lnrpc.PayReqString"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.PayReqString = Lnrpc.PayReqString()
            public func getMessage() -> Lnrpc.PayReqString {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The payment request string to be decoded
            public var payReq:String {
                get {
                    return builderResult.payReq
                }
                set (value) {
                    builderResult.hasPayReq = true
                    builderResult.payReq = value
                }
            }
            public var hasPayReq:Bool {
                get {
                    return builderResult.hasPayReq
                }
            }
            @discardableResult
            public func setPayReq(_ value:String) -> Lnrpc.PayReqString.Builder {
                self.payReq = value
                return self
            }
            @discardableResult
            public func clearPayReq() -> Lnrpc.PayReqString.Builder{
                builderResult.hasPayReq = false
                builderResult.payReq = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.PayReqString.Builder {
                builderResult = Lnrpc.PayReqString()
                return self
            }
            override public func clone() throws -> Lnrpc.PayReqString.Builder {
                return try Lnrpc.PayReqString.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.PayReqString {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.PayReqString {
                let returnMe:Lnrpc.PayReqString = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.PayReqString) throws -> Lnrpc.PayReqString.Builder {
                if other == Lnrpc.PayReqString() {
                    return self
                }
                if other.hasPayReq {
                    payReq = other.payReq
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PayReqString.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PayReqString.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        payReq = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PayReqString.Builder {
                let resultDecodedBuilder = Lnrpc.PayReqString.Builder()
                if let jsonValuePayReq = jsonMap["payReq"] as? String {
                    resultDecodedBuilder.payReq = jsonValuePayReq
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PayReqString.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.PayReqString.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class PayReq : GeneratedMessage {
        public typealias BuilderType = Lnrpc.PayReq.Builder

        public static func == (lhs: Lnrpc.PayReq, rhs: Lnrpc.PayReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasDestination == rhs.hasDestination) && (!lhs.hasDestination || lhs.destination == rhs.destination)
            fieldCheck = fieldCheck && (lhs.hasPaymentHash == rhs.hasPaymentHash) && (!lhs.hasPaymentHash || lhs.paymentHash == rhs.paymentHash)
            fieldCheck = fieldCheck && (lhs.hasNumSatoshis == rhs.hasNumSatoshis) && (!lhs.hasNumSatoshis || lhs.numSatoshis == rhs.numSatoshis)
            fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
            fieldCheck = fieldCheck && (lhs.hasExpiry == rhs.hasExpiry) && (!lhs.hasExpiry || lhs.expiry == rhs.expiry)
            fieldCheck = fieldCheck && (lhs.hasDescription == rhs.hasDescription) && (!lhs.hasDescription || lhs.description_ == rhs.description_)
            fieldCheck = fieldCheck && (lhs.hasDescriptionHash == rhs.hasDescriptionHash) && (!lhs.hasDescriptionHash || lhs.descriptionHash == rhs.descriptionHash)
            fieldCheck = fieldCheck && (lhs.hasFallbackAddr == rhs.hasFallbackAddr) && (!lhs.hasFallbackAddr || lhs.fallbackAddr == rhs.fallbackAddr)
            fieldCheck = fieldCheck && (lhs.hasCltvExpiry == rhs.hasCltvExpiry) && (!lhs.hasCltvExpiry || lhs.cltvExpiry == rhs.cltvExpiry)
            fieldCheck = fieldCheck && (lhs.routeHints == rhs.routeHints)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var destination:String! = nil
        public fileprivate(set) var hasDestination:Bool = false

        public fileprivate(set) var paymentHash:String! = nil
        public fileprivate(set) var hasPaymentHash:Bool = false

        public fileprivate(set) var numSatoshis:Int64! = nil
        public fileprivate(set) var hasNumSatoshis:Bool = false

        public fileprivate(set) var timestamp:Int64! = nil
        public fileprivate(set) var hasTimestamp:Bool = false

        public fileprivate(set) var expiry:Int64! = nil
        public fileprivate(set) var hasExpiry:Bool = false

        public fileprivate(set) var description_:String! = nil
        public fileprivate(set) var hasDescription:Bool = false

        public fileprivate(set) var descriptionHash:String! = nil
        public fileprivate(set) var hasDescriptionHash:Bool = false

        public fileprivate(set) var fallbackAddr:String! = nil
        public fileprivate(set) var hasFallbackAddr:Bool = false

        public fileprivate(set) var cltvExpiry:Int64! = nil
        public fileprivate(set) var hasCltvExpiry:Bool = false

        public fileprivate(set) var routeHints:Array<Lnrpc.RouteHint>  = Array<Lnrpc.RouteHint>()
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasDestination {
                try codedOutputStream.writeString(fieldNumber: 1, value:destination)
            }
            if hasPaymentHash {
                try codedOutputStream.writeString(fieldNumber: 2, value:paymentHash)
            }
            if hasNumSatoshis {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:numSatoshis)
            }
            if hasTimestamp {
                try codedOutputStream.writeInt64(fieldNumber: 4, value:timestamp)
            }
            if hasExpiry {
                try codedOutputStream.writeInt64(fieldNumber: 5, value:expiry)
            }
            if hasDescription {
                try codedOutputStream.writeString(fieldNumber: 6, value:description_)
            }
            if hasDescriptionHash {
                try codedOutputStream.writeString(fieldNumber: 7, value:descriptionHash)
            }
            if hasFallbackAddr {
                try codedOutputStream.writeString(fieldNumber: 8, value:fallbackAddr)
            }
            if hasCltvExpiry {
                try codedOutputStream.writeInt64(fieldNumber: 9, value:cltvExpiry)
            }
            for oneElementRouteHints in routeHints {
                  try codedOutputStream.writeMessage(fieldNumber: 10, value:oneElementRouteHints)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasDestination {
                serialize_size += destination.computeStringSize(fieldNumber: 1)
            }
            if hasPaymentHash {
                serialize_size += paymentHash.computeStringSize(fieldNumber: 2)
            }
            if hasNumSatoshis {
                serialize_size += numSatoshis.computeInt64Size(fieldNumber: 3)
            }
            if hasTimestamp {
                serialize_size += timestamp.computeInt64Size(fieldNumber: 4)
            }
            if hasExpiry {
                serialize_size += expiry.computeInt64Size(fieldNumber: 5)
            }
            if hasDescription {
                serialize_size += description_.computeStringSize(fieldNumber: 6)
            }
            if hasDescriptionHash {
                serialize_size += descriptionHash.computeStringSize(fieldNumber: 7)
            }
            if hasFallbackAddr {
                serialize_size += fallbackAddr.computeStringSize(fieldNumber: 8)
            }
            if hasCltvExpiry {
                serialize_size += cltvExpiry.computeInt64Size(fieldNumber: 9)
            }
            for oneElementRouteHints in routeHints {
                serialize_size += oneElementRouteHints.computeMessageSize(fieldNumber: 10)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.PayReq.Builder {
            return Lnrpc.PayReq.classBuilder() as! Lnrpc.PayReq.Builder
        }
        public func getBuilder() -> Lnrpc.PayReq.Builder {
            return classBuilder() as! Lnrpc.PayReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.PayReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.PayReq.Builder()
        }
        public func toBuilder() throws -> Lnrpc.PayReq.Builder {
            return try Lnrpc.PayReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.PayReq) throws -> Lnrpc.PayReq.Builder {
            return try Lnrpc.PayReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasDestination {
                jsonMap["destination"] = destination
            }
            if hasPaymentHash {
                jsonMap["payment_hash"] = paymentHash
            }
            if hasNumSatoshis {
                jsonMap["num_satoshis"] = "\(numSatoshis!)"
            }
            if hasTimestamp {
                jsonMap["timestamp"] = "\(timestamp!)"
            }
            if hasExpiry {
                jsonMap["expiry"] = "\(expiry!)"
            }
            if hasDescription {
                jsonMap["description"] = description_
            }
            if hasDescriptionHash {
                jsonMap["description_hash"] = descriptionHash
            }
            if hasFallbackAddr {
                jsonMap["fallback_addr"] = fallbackAddr
            }
            if hasCltvExpiry {
                jsonMap["cltv_expiry"] = "\(cltvExpiry!)"
            }
            if !routeHints.isEmpty {
                var jsonArrayRouteHints:Array<Dictionary<String,Any>> = []
                for oneValueRouteHints in routeHints {
                    let ecodedMessageRouteHints = try oneValueRouteHints.encode()
                    jsonArrayRouteHints.append(ecodedMessageRouteHints)
                }
                jsonMap["route_hints"] = jsonArrayRouteHints
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PayReq {
            return try Lnrpc.PayReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PayReq {
            return try Lnrpc.PayReq.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasDestination {
                output += "\(indent) destination: \(destination) \n"
            }
            if hasPaymentHash {
                output += "\(indent) paymentHash: \(paymentHash) \n"
            }
            if hasNumSatoshis {
                output += "\(indent) numSatoshis: \(numSatoshis) \n"
            }
            if hasTimestamp {
                output += "\(indent) timestamp: \(timestamp) \n"
            }
            if hasExpiry {
                output += "\(indent) expiry: \(expiry) \n"
            }
            if hasDescription {
                output += "\(indent) description: \(description_) \n"
            }
            if hasDescriptionHash {
                output += "\(indent) descriptionHash: \(descriptionHash) \n"
            }
            if hasFallbackAddr {
                output += "\(indent) fallbackAddr: \(fallbackAddr) \n"
            }
            if hasCltvExpiry {
                output += "\(indent) cltvExpiry: \(cltvExpiry) \n"
            }
            var routeHintsElementIndex:Int = 0
            for oneElementRouteHints in routeHints {
                output += "\(indent) routeHints[\(routeHintsElementIndex)] {\n"
                output += try oneElementRouteHints.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                routeHintsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasDestination {
                    hashCode = (hashCode &* 31) &+ destination.hashValue
                }
                if hasPaymentHash {
                    hashCode = (hashCode &* 31) &+ paymentHash.hashValue
                }
                if hasNumSatoshis {
                    hashCode = (hashCode &* 31) &+ numSatoshis.hashValue
                }
                if hasTimestamp {
                    hashCode = (hashCode &* 31) &+ timestamp.hashValue
                }
                if hasExpiry {
                    hashCode = (hashCode &* 31) &+ expiry.hashValue
                }
                if hasDescription {
                    hashCode = (hashCode &* 31) &+ description_.hashValue
                }
                if hasDescriptionHash {
                    hashCode = (hashCode &* 31) &+ descriptionHash.hashValue
                }
                if hasFallbackAddr {
                    hashCode = (hashCode &* 31) &+ fallbackAddr.hashValue
                }
                if hasCltvExpiry {
                    hashCode = (hashCode &* 31) &+ cltvExpiry.hashValue
                }
                for oneElementRouteHints in routeHints {
                    hashCode = (hashCode &* 31) &+ oneElementRouteHints.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.PayReq"
        }
        override public func className() -> String {
            return "Lnrpc.PayReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.PayReq = Lnrpc.PayReq()
            public func getMessage() -> Lnrpc.PayReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var destination:String {
                get {
                    return builderResult.destination
                }
                set (value) {
                    builderResult.hasDestination = true
                    builderResult.destination = value
                }
            }
            public var hasDestination:Bool {
                get {
                    return builderResult.hasDestination
                }
            }
            @discardableResult
            public func setDestination(_ value:String) -> Lnrpc.PayReq.Builder {
                self.destination = value
                return self
            }
            @discardableResult
            public func clearDestination() -> Lnrpc.PayReq.Builder{
                builderResult.hasDestination = false
                builderResult.destination = nil
                return self
            }
            public var paymentHash:String {
                get {
                    return builderResult.paymentHash
                }
                set (value) {
                    builderResult.hasPaymentHash = true
                    builderResult.paymentHash = value
                }
            }
            public var hasPaymentHash:Bool {
                get {
                    return builderResult.hasPaymentHash
                }
            }
            @discardableResult
            public func setPaymentHash(_ value:String) -> Lnrpc.PayReq.Builder {
                self.paymentHash = value
                return self
            }
            @discardableResult
            public func clearPaymentHash() -> Lnrpc.PayReq.Builder{
                builderResult.hasPaymentHash = false
                builderResult.paymentHash = nil
                return self
            }
            public var numSatoshis:Int64 {
                get {
                    return builderResult.numSatoshis
                }
                set (value) {
                    builderResult.hasNumSatoshis = true
                    builderResult.numSatoshis = value
                }
            }
            public var hasNumSatoshis:Bool {
                get {
                    return builderResult.hasNumSatoshis
                }
            }
            @discardableResult
            public func setNumSatoshis(_ value:Int64) -> Lnrpc.PayReq.Builder {
                self.numSatoshis = value
                return self
            }
            @discardableResult
            public func clearNumSatoshis() -> Lnrpc.PayReq.Builder{
                builderResult.hasNumSatoshis = false
                builderResult.numSatoshis = nil
                return self
            }
            public var timestamp:Int64 {
                get {
                    return builderResult.timestamp
                }
                set (value) {
                    builderResult.hasTimestamp = true
                    builderResult.timestamp = value
                }
            }
            public var hasTimestamp:Bool {
                get {
                    return builderResult.hasTimestamp
                }
            }
            @discardableResult
            public func setTimestamp(_ value:Int64) -> Lnrpc.PayReq.Builder {
                self.timestamp = value
                return self
            }
            @discardableResult
            public func clearTimestamp() -> Lnrpc.PayReq.Builder{
                builderResult.hasTimestamp = false
                builderResult.timestamp = nil
                return self
            }
            public var expiry:Int64 {
                get {
                    return builderResult.expiry
                }
                set (value) {
                    builderResult.hasExpiry = true
                    builderResult.expiry = value
                }
            }
            public var hasExpiry:Bool {
                get {
                    return builderResult.hasExpiry
                }
            }
            @discardableResult
            public func setExpiry(_ value:Int64) -> Lnrpc.PayReq.Builder {
                self.expiry = value
                return self
            }
            @discardableResult
            public func clearExpiry() -> Lnrpc.PayReq.Builder{
                builderResult.hasExpiry = false
                builderResult.expiry = nil
                return self
            }
            public var description_:String {
                get {
                    return builderResult.description_
                }
                set (value) {
                    builderResult.hasDescription = true
                    builderResult.description_ = value
                }
            }
            public var hasDescription:Bool {
                get {
                    return builderResult.hasDescription
                }
            }
            @discardableResult
            public func setDescription(_ value:String) -> Lnrpc.PayReq.Builder {
                self.description_ = value
                return self
            }
            @discardableResult
            public func clearDescription() -> Lnrpc.PayReq.Builder{
                builderResult.hasDescription = false
                builderResult.description_ = nil
                return self
            }
            public var descriptionHash:String {
                get {
                    return builderResult.descriptionHash
                }
                set (value) {
                    builderResult.hasDescriptionHash = true
                    builderResult.descriptionHash = value
                }
            }
            public var hasDescriptionHash:Bool {
                get {
                    return builderResult.hasDescriptionHash
                }
            }
            @discardableResult
            public func setDescriptionHash(_ value:String) -> Lnrpc.PayReq.Builder {
                self.descriptionHash = value
                return self
            }
            @discardableResult
            public func clearDescriptionHash() -> Lnrpc.PayReq.Builder{
                builderResult.hasDescriptionHash = false
                builderResult.descriptionHash = nil
                return self
            }
            public var fallbackAddr:String {
                get {
                    return builderResult.fallbackAddr
                }
                set (value) {
                    builderResult.hasFallbackAddr = true
                    builderResult.fallbackAddr = value
                }
            }
            public var hasFallbackAddr:Bool {
                get {
                    return builderResult.hasFallbackAddr
                }
            }
            @discardableResult
            public func setFallbackAddr(_ value:String) -> Lnrpc.PayReq.Builder {
                self.fallbackAddr = value
                return self
            }
            @discardableResult
            public func clearFallbackAddr() -> Lnrpc.PayReq.Builder{
                builderResult.hasFallbackAddr = false
                builderResult.fallbackAddr = nil
                return self
            }
            public var cltvExpiry:Int64 {
                get {
                    return builderResult.cltvExpiry
                }
                set (value) {
                    builderResult.hasCltvExpiry = true
                    builderResult.cltvExpiry = value
                }
            }
            public var hasCltvExpiry:Bool {
                get {
                    return builderResult.hasCltvExpiry
                }
            }
            @discardableResult
            public func setCltvExpiry(_ value:Int64) -> Lnrpc.PayReq.Builder {
                self.cltvExpiry = value
                return self
            }
            @discardableResult
            public func clearCltvExpiry() -> Lnrpc.PayReq.Builder{
                builderResult.hasCltvExpiry = false
                builderResult.cltvExpiry = nil
                return self
            }
            public var routeHints:Array<Lnrpc.RouteHint> {
                get {
                    return builderResult.routeHints
                }
                set (value) {
                    builderResult.routeHints = value
                }
            }
            @discardableResult
            public func setRouteHints(_ value:Array<Lnrpc.RouteHint>) -> Lnrpc.PayReq.Builder {
                self.routeHints = value
                return self
            }
            @discardableResult
            public func clearRouteHints() -> Lnrpc.PayReq.Builder {
                builderResult.routeHints.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.PayReq.Builder {
                builderResult = Lnrpc.PayReq()
                return self
            }
            override public func clone() throws -> Lnrpc.PayReq.Builder {
                return try Lnrpc.PayReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.PayReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.PayReq {
                let returnMe:Lnrpc.PayReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.PayReq) throws -> Lnrpc.PayReq.Builder {
                if other == Lnrpc.PayReq() {
                    return self
                }
                if other.hasDestination {
                    destination = other.destination
                }
                if other.hasPaymentHash {
                    paymentHash = other.paymentHash
                }
                if other.hasNumSatoshis {
                    numSatoshis = other.numSatoshis
                }
                if other.hasTimestamp {
                    timestamp = other.timestamp
                }
                if other.hasExpiry {
                    expiry = other.expiry
                }
                if other.hasDescription {
                    description_ = other.description_
                }
                if other.hasDescriptionHash {
                    descriptionHash = other.descriptionHash
                }
                if other.hasFallbackAddr {
                    fallbackAddr = other.fallbackAddr
                }
                if other.hasCltvExpiry {
                    cltvExpiry = other.cltvExpiry
                }
                if !other.routeHints.isEmpty  {
                     builderResult.routeHints += other.routeHints
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PayReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PayReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        destination = try codedInputStream.readString()

                    case 18:
                        paymentHash = try codedInputStream.readString()

                    case 24:
                        numSatoshis = try codedInputStream.readInt64()

                    case 32:
                        timestamp = try codedInputStream.readInt64()

                    case 40:
                        expiry = try codedInputStream.readInt64()

                    case 50:
                        description_ = try codedInputStream.readString()

                    case 58:
                        descriptionHash = try codedInputStream.readString()

                    case 66:
                        fallbackAddr = try codedInputStream.readString()

                    case 72:
                        cltvExpiry = try codedInputStream.readInt64()

                    case 82:
                        let subBuilder = Lnrpc.RouteHint.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        routeHints.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PayReq.Builder {
                let resultDecodedBuilder = Lnrpc.PayReq.Builder()
                if let jsonValueDestination = jsonMap["destination"] as? String {
                    resultDecodedBuilder.destination = jsonValueDestination
                }
                if let jsonValuePaymentHash = jsonMap["payment_hash"] as? String {
                    resultDecodedBuilder.paymentHash = jsonValuePaymentHash
                }
                if let jsonValueNumSatoshis = jsonMap["num_satoshis"] as? String {
                    resultDecodedBuilder.numSatoshis = Int64(jsonValueNumSatoshis)!
                } else if let jsonValueNumSatoshis = jsonMap["num_satoshis"] as? Int {
                    resultDecodedBuilder.numSatoshis = Int64(jsonValueNumSatoshis)
                }
                if let jsonValueTimestamp = jsonMap["timestamp"] as? String {
                    resultDecodedBuilder.timestamp = Int64(jsonValueTimestamp)!
                } else if let jsonValueTimestamp = jsonMap["timestamp"] as? Int {
                    resultDecodedBuilder.timestamp = Int64(jsonValueTimestamp)
                }
                if let jsonValueExpiry = jsonMap["expiry"] as? String {
                    resultDecodedBuilder.expiry = Int64(jsonValueExpiry)!
                } else if let jsonValueExpiry = jsonMap["expiry"] as? Int {
                    resultDecodedBuilder.expiry = Int64(jsonValueExpiry)
                }
                if let jsonValueDescription = jsonMap["description"] as? String {
                    resultDecodedBuilder.description_ = jsonValueDescription
                }
                if let jsonValueDescriptionHash = jsonMap["description_hash"] as? String {
                    resultDecodedBuilder.descriptionHash = jsonValueDescriptionHash
                }
                if let jsonValueFallbackAddr = jsonMap["fallback_addr"] as? String {
                    resultDecodedBuilder.fallbackAddr = jsonValueFallbackAddr
                }
                if let jsonValueCltvExpiry = jsonMap["cltv_expiry"] as? String {
                    resultDecodedBuilder.cltvExpiry = Int64(jsonValueCltvExpiry)!
                } else if let jsonValueCltvExpiry = jsonMap["cltv_expiry"] as? Int {
                    resultDecodedBuilder.cltvExpiry = Int64(jsonValueCltvExpiry)
                }
                if let jsonValueRouteHints = jsonMap["route_hints"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayRouteHints:Array<Lnrpc.RouteHint> = []
                    for oneValueRouteHints in jsonValueRouteHints {
                        let messageFromStringRouteHints = try Lnrpc.RouteHint.Builder.decodeToBuilder(jsonMap:oneValueRouteHints).build()

                        jsonArrayRouteHints.append(messageFromStringRouteHints)
                    }
                    resultDecodedBuilder.routeHints = jsonArrayRouteHints
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PayReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.PayReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class FeeReportRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.FeeReportRequest.Builder

        public static func == (lhs: Lnrpc.FeeReportRequest, rhs: Lnrpc.FeeReportRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.FeeReportRequest.Builder {
            return Lnrpc.FeeReportRequest.classBuilder() as! Lnrpc.FeeReportRequest.Builder
        }
        public func getBuilder() -> Lnrpc.FeeReportRequest.Builder {
            return classBuilder() as! Lnrpc.FeeReportRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.FeeReportRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.FeeReportRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.FeeReportRequest.Builder {
            return try Lnrpc.FeeReportRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.FeeReportRequest) throws -> Lnrpc.FeeReportRequest.Builder {
            return try Lnrpc.FeeReportRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.FeeReportRequest {
            return try Lnrpc.FeeReportRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.FeeReportRequest {
            return try Lnrpc.FeeReportRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.FeeReportRequest"
        }
        override public func className() -> String {
            return "Lnrpc.FeeReportRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.FeeReportRequest = Lnrpc.FeeReportRequest()
            public func getMessage() -> Lnrpc.FeeReportRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.FeeReportRequest.Builder {
                builderResult = Lnrpc.FeeReportRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.FeeReportRequest.Builder {
                return try Lnrpc.FeeReportRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.FeeReportRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.FeeReportRequest {
                let returnMe:Lnrpc.FeeReportRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.FeeReportRequest) throws -> Lnrpc.FeeReportRequest.Builder {
                if other == Lnrpc.FeeReportRequest() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.FeeReportRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.FeeReportRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.FeeReportRequest.Builder {
                let resultDecodedBuilder = Lnrpc.FeeReportRequest.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.FeeReportRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.FeeReportRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ChannelFeeReport : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ChannelFeeReport.Builder

        public static func == (lhs: Lnrpc.ChannelFeeReport, rhs: Lnrpc.ChannelFeeReport) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasChanPoint == rhs.hasChanPoint) && (!lhs.hasChanPoint || lhs.chanPoint == rhs.chanPoint)
            fieldCheck = fieldCheck && (lhs.hasBaseFeeMsat == rhs.hasBaseFeeMsat) && (!lhs.hasBaseFeeMsat || lhs.baseFeeMsat == rhs.baseFeeMsat)
            fieldCheck = fieldCheck && (lhs.hasFeePerMil == rhs.hasFeePerMil) && (!lhs.hasFeePerMil || lhs.feePerMil == rhs.feePerMil)
            fieldCheck = fieldCheck && (lhs.hasFeeRate == rhs.hasFeeRate) && (!lhs.hasFeeRate || lhs.feeRate == rhs.feeRate)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// The channel that this fee report belongs to.
        public fileprivate(set) var chanPoint:String! = nil
        public fileprivate(set) var hasChanPoint:Bool = false

        //// The base fee charged regardless of the number of milli-satoshis sent.
        public fileprivate(set) var baseFeeMsat:Int64! = nil
        public fileprivate(set) var hasBaseFeeMsat:Bool = false

        //// The amount charged per milli-satoshis transferred expressed in millionths of a satoshi.
        public fileprivate(set) var feePerMil:Int64! = nil
        public fileprivate(set) var hasFeePerMil:Bool = false

        //// The effective fee rate in milli-satoshis. Computed by dividing the fee_per_mil value by 1 million.
        public fileprivate(set) var feeRate:Double! = nil
        public fileprivate(set) var hasFeeRate:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasChanPoint {
                try codedOutputStream.writeString(fieldNumber: 1, value:chanPoint)
            }
            if hasBaseFeeMsat {
                try codedOutputStream.writeInt64(fieldNumber: 2, value:baseFeeMsat)
            }
            if hasFeePerMil {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:feePerMil)
            }
            if hasFeeRate {
                try codedOutputStream.writeDouble(fieldNumber: 4, value:feeRate)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasChanPoint {
                serialize_size += chanPoint.computeStringSize(fieldNumber: 1)
            }
            if hasBaseFeeMsat {
                serialize_size += baseFeeMsat.computeInt64Size(fieldNumber: 2)
            }
            if hasFeePerMil {
                serialize_size += feePerMil.computeInt64Size(fieldNumber: 3)
            }
            if hasFeeRate {
                serialize_size += feeRate.computeDoubleSize(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ChannelFeeReport.Builder {
            return Lnrpc.ChannelFeeReport.classBuilder() as! Lnrpc.ChannelFeeReport.Builder
        }
        public func getBuilder() -> Lnrpc.ChannelFeeReport.Builder {
            return classBuilder() as! Lnrpc.ChannelFeeReport.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChannelFeeReport.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ChannelFeeReport.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ChannelFeeReport.Builder {
            return try Lnrpc.ChannelFeeReport.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ChannelFeeReport) throws -> Lnrpc.ChannelFeeReport.Builder {
            return try Lnrpc.ChannelFeeReport.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasChanPoint {
                jsonMap["channel_point"] = chanPoint
            }
            if hasBaseFeeMsat {
                jsonMap["base_fee_msat"] = "\(baseFeeMsat!)"
            }
            if hasFeePerMil {
                jsonMap["fee_per_mil"] = "\(feePerMil!)"
            }
            if hasFeeRate {
                jsonMap["fee_rate"] = Double(feeRate)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChannelFeeReport {
            return try Lnrpc.ChannelFeeReport.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChannelFeeReport {
            return try Lnrpc.ChannelFeeReport.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasChanPoint {
                output += "\(indent) chanPoint: \(chanPoint) \n"
            }
            if hasBaseFeeMsat {
                output += "\(indent) baseFeeMsat: \(baseFeeMsat) \n"
            }
            if hasFeePerMil {
                output += "\(indent) feePerMil: \(feePerMil) \n"
            }
            if hasFeeRate {
                output += "\(indent) feeRate: \(feeRate) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasChanPoint {
                    hashCode = (hashCode &* 31) &+ chanPoint.hashValue
                }
                if hasBaseFeeMsat {
                    hashCode = (hashCode &* 31) &+ baseFeeMsat.hashValue
                }
                if hasFeePerMil {
                    hashCode = (hashCode &* 31) &+ feePerMil.hashValue
                }
                if hasFeeRate {
                    hashCode = (hashCode &* 31) &+ feeRate.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ChannelFeeReport"
        }
        override public func className() -> String {
            return "Lnrpc.ChannelFeeReport"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ChannelFeeReport = Lnrpc.ChannelFeeReport()
            public func getMessage() -> Lnrpc.ChannelFeeReport {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// The channel that this fee report belongs to.
            public var chanPoint:String {
                get {
                    return builderResult.chanPoint
                }
                set (value) {
                    builderResult.hasChanPoint = true
                    builderResult.chanPoint = value
                }
            }
            public var hasChanPoint:Bool {
                get {
                    return builderResult.hasChanPoint
                }
            }
            @discardableResult
            public func setChanPoint(_ value:String) -> Lnrpc.ChannelFeeReport.Builder {
                self.chanPoint = value
                return self
            }
            @discardableResult
            public func clearChanPoint() -> Lnrpc.ChannelFeeReport.Builder{
                builderResult.hasChanPoint = false
                builderResult.chanPoint = nil
                return self
            }
            //// The base fee charged regardless of the number of milli-satoshis sent.
            public var baseFeeMsat:Int64 {
                get {
                    return builderResult.baseFeeMsat
                }
                set (value) {
                    builderResult.hasBaseFeeMsat = true
                    builderResult.baseFeeMsat = value
                }
            }
            public var hasBaseFeeMsat:Bool {
                get {
                    return builderResult.hasBaseFeeMsat
                }
            }
            @discardableResult
            public func setBaseFeeMsat(_ value:Int64) -> Lnrpc.ChannelFeeReport.Builder {
                self.baseFeeMsat = value
                return self
            }
            @discardableResult
            public func clearBaseFeeMsat() -> Lnrpc.ChannelFeeReport.Builder{
                builderResult.hasBaseFeeMsat = false
                builderResult.baseFeeMsat = nil
                return self
            }
            //// The amount charged per milli-satoshis transferred expressed in millionths of a satoshi.
            public var feePerMil:Int64 {
                get {
                    return builderResult.feePerMil
                }
                set (value) {
                    builderResult.hasFeePerMil = true
                    builderResult.feePerMil = value
                }
            }
            public var hasFeePerMil:Bool {
                get {
                    return builderResult.hasFeePerMil
                }
            }
            @discardableResult
            public func setFeePerMil(_ value:Int64) -> Lnrpc.ChannelFeeReport.Builder {
                self.feePerMil = value
                return self
            }
            @discardableResult
            public func clearFeePerMil() -> Lnrpc.ChannelFeeReport.Builder{
                builderResult.hasFeePerMil = false
                builderResult.feePerMil = nil
                return self
            }
            //// The effective fee rate in milli-satoshis. Computed by dividing the fee_per_mil value by 1 million.
            public var feeRate:Double {
                get {
                    return builderResult.feeRate
                }
                set (value) {
                    builderResult.hasFeeRate = true
                    builderResult.feeRate = value
                }
            }
            public var hasFeeRate:Bool {
                get {
                    return builderResult.hasFeeRate
                }
            }
            @discardableResult
            public func setFeeRate(_ value:Double) -> Lnrpc.ChannelFeeReport.Builder {
                self.feeRate = value
                return self
            }
            @discardableResult
            public func clearFeeRate() -> Lnrpc.ChannelFeeReport.Builder{
                builderResult.hasFeeRate = false
                builderResult.feeRate = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ChannelFeeReport.Builder {
                builderResult = Lnrpc.ChannelFeeReport()
                return self
            }
            override public func clone() throws -> Lnrpc.ChannelFeeReport.Builder {
                return try Lnrpc.ChannelFeeReport.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ChannelFeeReport {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ChannelFeeReport {
                let returnMe:Lnrpc.ChannelFeeReport = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ChannelFeeReport) throws -> Lnrpc.ChannelFeeReport.Builder {
                if other == Lnrpc.ChannelFeeReport() {
                    return self
                }
                if other.hasChanPoint {
                    chanPoint = other.chanPoint
                }
                if other.hasBaseFeeMsat {
                    baseFeeMsat = other.baseFeeMsat
                }
                if other.hasFeePerMil {
                    feePerMil = other.feePerMil
                }
                if other.hasFeeRate {
                    feeRate = other.feeRate
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChannelFeeReport.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelFeeReport.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        chanPoint = try codedInputStream.readString()

                    case 16:
                        baseFeeMsat = try codedInputStream.readInt64()

                    case 24:
                        feePerMil = try codedInputStream.readInt64()

                    case 33:
                        feeRate = try codedInputStream.readDouble()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ChannelFeeReport.Builder {
                let resultDecodedBuilder = Lnrpc.ChannelFeeReport.Builder()
                if let jsonValueChanPoint = jsonMap["channel_point"] as? String {
                    resultDecodedBuilder.chanPoint = jsonValueChanPoint
                }
                if let jsonValueBaseFeeMsat = jsonMap["base_fee_msat"] as? String {
                    resultDecodedBuilder.baseFeeMsat = Int64(jsonValueBaseFeeMsat)!
                } else if let jsonValueBaseFeeMsat = jsonMap["base_fee_msat"] as? Int {
                    resultDecodedBuilder.baseFeeMsat = Int64(jsonValueBaseFeeMsat)
                }
                if let jsonValueFeePerMil = jsonMap["fee_per_mil"] as? String {
                    resultDecodedBuilder.feePerMil = Int64(jsonValueFeePerMil)!
                } else if let jsonValueFeePerMil = jsonMap["fee_per_mil"] as? Int {
                    resultDecodedBuilder.feePerMil = Int64(jsonValueFeePerMil)
                }
                if let jsonValueFeeRate = jsonMap["fee_rate"] as? Double {
                    resultDecodedBuilder.feeRate = Double(jsonValueFeeRate)
                } else if let jsonValueFeeRate = jsonMap["fee_rate"] as? String {
                    resultDecodedBuilder.feeRate = Double(jsonValueFeeRate)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ChannelFeeReport.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ChannelFeeReport.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class FeeReportResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.FeeReportResponse.Builder

        public static func == (lhs: Lnrpc.FeeReportResponse, rhs: Lnrpc.FeeReportResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.channelFees == rhs.channelFees)
            fieldCheck = fieldCheck && (lhs.hasDayFeeSum == rhs.hasDayFeeSum) && (!lhs.hasDayFeeSum || lhs.dayFeeSum == rhs.dayFeeSum)
            fieldCheck = fieldCheck && (lhs.hasWeekFeeSum == rhs.hasWeekFeeSum) && (!lhs.hasWeekFeeSum || lhs.weekFeeSum == rhs.weekFeeSum)
            fieldCheck = fieldCheck && (lhs.hasMonthFeeSum == rhs.hasMonthFeeSum) && (!lhs.hasMonthFeeSum || lhs.monthFeeSum == rhs.monthFeeSum)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var channelFees:Array<Lnrpc.ChannelFeeReport>  = Array<Lnrpc.ChannelFeeReport>()
        //// The total amount of fee revenue (in satoshis) the switch has collected over the past 24 hrs.
        public fileprivate(set) var dayFeeSum:UInt64! = nil
        public fileprivate(set) var hasDayFeeSum:Bool = false

        //// The total amount of fee revenue (in satoshis) the switch has collected over the past 1 week.
        public fileprivate(set) var weekFeeSum:UInt64! = nil
        public fileprivate(set) var hasWeekFeeSum:Bool = false

        //// The total amount of fee revenue (in satoshis) the switch has collected over the past 1 month.
        public fileprivate(set) var monthFeeSum:UInt64! = nil
        public fileprivate(set) var hasMonthFeeSum:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementChannelFees in channelFees {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementChannelFees)
            }
            if hasDayFeeSum {
                try codedOutputStream.writeUInt64(fieldNumber: 2, value:dayFeeSum)
            }
            if hasWeekFeeSum {
                try codedOutputStream.writeUInt64(fieldNumber: 3, value:weekFeeSum)
            }
            if hasMonthFeeSum {
                try codedOutputStream.writeUInt64(fieldNumber: 4, value:monthFeeSum)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementChannelFees in channelFees {
                serialize_size += oneElementChannelFees.computeMessageSize(fieldNumber: 1)
            }
            if hasDayFeeSum {
                serialize_size += dayFeeSum.computeUInt64Size(fieldNumber: 2)
            }
            if hasWeekFeeSum {
                serialize_size += weekFeeSum.computeUInt64Size(fieldNumber: 3)
            }
            if hasMonthFeeSum {
                serialize_size += monthFeeSum.computeUInt64Size(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.FeeReportResponse.Builder {
            return Lnrpc.FeeReportResponse.classBuilder() as! Lnrpc.FeeReportResponse.Builder
        }
        public func getBuilder() -> Lnrpc.FeeReportResponse.Builder {
            return classBuilder() as! Lnrpc.FeeReportResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.FeeReportResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.FeeReportResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.FeeReportResponse.Builder {
            return try Lnrpc.FeeReportResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.FeeReportResponse) throws -> Lnrpc.FeeReportResponse.Builder {
            return try Lnrpc.FeeReportResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !channelFees.isEmpty {
                var jsonArrayChannelFees:Array<Dictionary<String,Any>> = []
                for oneValueChannelFees in channelFees {
                    let ecodedMessageChannelFees = try oneValueChannelFees.encode()
                    jsonArrayChannelFees.append(ecodedMessageChannelFees)
                }
                jsonMap["channel_fees"] = jsonArrayChannelFees
            }
            if hasDayFeeSum {
                jsonMap["day_fee_sum"] = "\(dayFeeSum!)"
            }
            if hasWeekFeeSum {
                jsonMap["week_fee_sum"] = "\(weekFeeSum!)"
            }
            if hasMonthFeeSum {
                jsonMap["month_fee_sum"] = "\(monthFeeSum!)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.FeeReportResponse {
            return try Lnrpc.FeeReportResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.FeeReportResponse {
            return try Lnrpc.FeeReportResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var channelFeesElementIndex:Int = 0
            for oneElementChannelFees in channelFees {
                output += "\(indent) channelFees[\(channelFeesElementIndex)] {\n"
                output += try oneElementChannelFees.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                channelFeesElementIndex += 1
            }
            if hasDayFeeSum {
                output += "\(indent) dayFeeSum: \(dayFeeSum) \n"
            }
            if hasWeekFeeSum {
                output += "\(indent) weekFeeSum: \(weekFeeSum) \n"
            }
            if hasMonthFeeSum {
                output += "\(indent) monthFeeSum: \(monthFeeSum) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementChannelFees in channelFees {
                    hashCode = (hashCode &* 31) &+ oneElementChannelFees.hashValue
                }
                if hasDayFeeSum {
                    hashCode = (hashCode &* 31) &+ dayFeeSum.hashValue
                }
                if hasWeekFeeSum {
                    hashCode = (hashCode &* 31) &+ weekFeeSum.hashValue
                }
                if hasMonthFeeSum {
                    hashCode = (hashCode &* 31) &+ monthFeeSum.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.FeeReportResponse"
        }
        override public func className() -> String {
            return "Lnrpc.FeeReportResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.FeeReportResponse = Lnrpc.FeeReportResponse()
            public func getMessage() -> Lnrpc.FeeReportResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// An array of channel fee reports which describes the current fee schedule for each channel.
            public var channelFees:Array<Lnrpc.ChannelFeeReport> {
                get {
                    return builderResult.channelFees
                }
                set (value) {
                    builderResult.channelFees = value
                }
            }
            @discardableResult
            public func setChannelFees(_ value:Array<Lnrpc.ChannelFeeReport>) -> Lnrpc.FeeReportResponse.Builder {
                self.channelFees = value
                return self
            }
            @discardableResult
            public func clearChannelFees() -> Lnrpc.FeeReportResponse.Builder {
                builderResult.channelFees.removeAll(keepingCapacity: false)
                return self
            }
            //// The total amount of fee revenue (in satoshis) the switch has collected over the past 24 hrs.
            public var dayFeeSum:UInt64 {
                get {
                    return builderResult.dayFeeSum
                }
                set (value) {
                    builderResult.hasDayFeeSum = true
                    builderResult.dayFeeSum = value
                }
            }
            public var hasDayFeeSum:Bool {
                get {
                    return builderResult.hasDayFeeSum
                }
            }
            @discardableResult
            public func setDayFeeSum(_ value:UInt64) -> Lnrpc.FeeReportResponse.Builder {
                self.dayFeeSum = value
                return self
            }
            @discardableResult
            public func clearDayFeeSum() -> Lnrpc.FeeReportResponse.Builder{
                builderResult.hasDayFeeSum = false
                builderResult.dayFeeSum = nil
                return self
            }
            //// The total amount of fee revenue (in satoshis) the switch has collected over the past 1 week.
            public var weekFeeSum:UInt64 {
                get {
                    return builderResult.weekFeeSum
                }
                set (value) {
                    builderResult.hasWeekFeeSum = true
                    builderResult.weekFeeSum = value
                }
            }
            public var hasWeekFeeSum:Bool {
                get {
                    return builderResult.hasWeekFeeSum
                }
            }
            @discardableResult
            public func setWeekFeeSum(_ value:UInt64) -> Lnrpc.FeeReportResponse.Builder {
                self.weekFeeSum = value
                return self
            }
            @discardableResult
            public func clearWeekFeeSum() -> Lnrpc.FeeReportResponse.Builder{
                builderResult.hasWeekFeeSum = false
                builderResult.weekFeeSum = nil
                return self
            }
            //// The total amount of fee revenue (in satoshis) the switch has collected over the past 1 month.
            public var monthFeeSum:UInt64 {
                get {
                    return builderResult.monthFeeSum
                }
                set (value) {
                    builderResult.hasMonthFeeSum = true
                    builderResult.monthFeeSum = value
                }
            }
            public var hasMonthFeeSum:Bool {
                get {
                    return builderResult.hasMonthFeeSum
                }
            }
            @discardableResult
            public func setMonthFeeSum(_ value:UInt64) -> Lnrpc.FeeReportResponse.Builder {
                self.monthFeeSum = value
                return self
            }
            @discardableResult
            public func clearMonthFeeSum() -> Lnrpc.FeeReportResponse.Builder{
                builderResult.hasMonthFeeSum = false
                builderResult.monthFeeSum = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.FeeReportResponse.Builder {
                builderResult = Lnrpc.FeeReportResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.FeeReportResponse.Builder {
                return try Lnrpc.FeeReportResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.FeeReportResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.FeeReportResponse {
                let returnMe:Lnrpc.FeeReportResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.FeeReportResponse) throws -> Lnrpc.FeeReportResponse.Builder {
                if other == Lnrpc.FeeReportResponse() {
                    return self
                }
                if !other.channelFees.isEmpty  {
                     builderResult.channelFees += other.channelFees
                }
                if other.hasDayFeeSum {
                    dayFeeSum = other.dayFeeSum
                }
                if other.hasWeekFeeSum {
                    weekFeeSum = other.weekFeeSum
                }
                if other.hasMonthFeeSum {
                    monthFeeSum = other.monthFeeSum
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.FeeReportResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.FeeReportResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Lnrpc.ChannelFeeReport.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        channelFees.append(subBuilder.buildPartial())

                    case 16:
                        dayFeeSum = try codedInputStream.readUInt64()

                    case 24:
                        weekFeeSum = try codedInputStream.readUInt64()

                    case 32:
                        monthFeeSum = try codedInputStream.readUInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.FeeReportResponse.Builder {
                let resultDecodedBuilder = Lnrpc.FeeReportResponse.Builder()
                if let jsonValueChannelFees = jsonMap["channel_fees"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayChannelFees:Array<Lnrpc.ChannelFeeReport> = []
                    for oneValueChannelFees in jsonValueChannelFees {
                        let messageFromStringChannelFees = try Lnrpc.ChannelFeeReport.Builder.decodeToBuilder(jsonMap:oneValueChannelFees).build()

                        jsonArrayChannelFees.append(messageFromStringChannelFees)
                    }
                    resultDecodedBuilder.channelFees = jsonArrayChannelFees
                }
                if let jsonValueDayFeeSum = jsonMap["day_fee_sum"] as? String {
                    resultDecodedBuilder.dayFeeSum = UInt64(jsonValueDayFeeSum)!
                } else if let jsonValueDayFeeSum = jsonMap["day_fee_sum"] as? UInt {
                    resultDecodedBuilder.dayFeeSum = UInt64(jsonValueDayFeeSum)
                }
                if let jsonValueWeekFeeSum = jsonMap["week_fee_sum"] as? String {
                    resultDecodedBuilder.weekFeeSum = UInt64(jsonValueWeekFeeSum)!
                } else if let jsonValueWeekFeeSum = jsonMap["week_fee_sum"] as? UInt {
                    resultDecodedBuilder.weekFeeSum = UInt64(jsonValueWeekFeeSum)
                }
                if let jsonValueMonthFeeSum = jsonMap["month_fee_sum"] as? String {
                    resultDecodedBuilder.monthFeeSum = UInt64(jsonValueMonthFeeSum)!
                } else if let jsonValueMonthFeeSum = jsonMap["month_fee_sum"] as? UInt {
                    resultDecodedBuilder.monthFeeSum = UInt64(jsonValueMonthFeeSum)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.FeeReportResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.FeeReportResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class PolicyUpdateRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.PolicyUpdateRequest.Builder

        public static func == (lhs: Lnrpc.PolicyUpdateRequest, rhs: Lnrpc.PolicyUpdateRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGlobal == rhs.hasGlobal) && (!lhs.hasGlobal || lhs.global == rhs.global)
            fieldCheck = fieldCheck && (lhs.hasChanPoint == rhs.hasChanPoint) && (!lhs.hasChanPoint || lhs.chanPoint == rhs.chanPoint)
            fieldCheck = fieldCheck && (lhs.hasBaseFeeMsat == rhs.hasBaseFeeMsat) && (!lhs.hasBaseFeeMsat || lhs.baseFeeMsat == rhs.baseFeeMsat)
            fieldCheck = fieldCheck && (lhs.hasFeeRate == rhs.hasFeeRate) && (!lhs.hasFeeRate || lhs.feeRate == rhs.feeRate)
            fieldCheck = fieldCheck && (lhs.hasTimeLockDelta == rhs.hasTimeLockDelta) && (!lhs.hasTimeLockDelta || lhs.timeLockDelta == rhs.timeLockDelta)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        public enum Scope {
            case oneOfScopeNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .oneOfScopeNotSet: return false
                default: return true
                }
            }
            case global(Bool)

            public static func getGlobal(_ value:Scope) -> Bool? {
                switch value {
                case .global(let otherValue): return otherValue
                default: return nil
                }
            }
            public func getGlobal() -> Bool? {
                switch self {
                case .global(let otherValue): return otherValue
                default: return nil
                }
            }
            case chanPoint(Lnrpc.ChannelPoint)

            public static func getChanPoint(_ value:Scope) -> Lnrpc.ChannelPoint? {
                switch value {
                case .chanPoint(let messageValue): return messageValue
                default: return nil
                }
            }
            public func getChanPoint() -> Lnrpc.ChannelPoint? {
                switch self {
                case .chanPoint(let messageValue): return messageValue
                default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageScope:PolicyUpdateRequest.Scope =  PolicyUpdateRequest.Scope.oneOfScopeNotSet
        public func getOneOfScope() ->  PolicyUpdateRequest.Scope {
            let copyObjectScope = storageScope
            return copyObjectScope
        }
        //// If set, then this update applies to all currently active channels.
        public fileprivate(set) var global:Bool!{
            get {
                return PolicyUpdateRequest.Scope.getGlobal(storageScope)
            }
            set (newvalue) {
                storageScope = PolicyUpdateRequest.Scope.global(newvalue)
            }
        }
        public fileprivate(set) var hasGlobal:Bool {
            get {
                return PolicyUpdateRequest.Scope.getGlobal(storageScope) != nil
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var chanPoint:Lnrpc.ChannelPoint!{
            get {
                return PolicyUpdateRequest.Scope.getChanPoint(storageScope)
            }
            set (newvalue) {
                storageScope = PolicyUpdateRequest.Scope.chanPoint(newvalue)
            }
        }
        public fileprivate(set) var hasChanPoint:Bool {
            get {
                return PolicyUpdateRequest.Scope.getChanPoint(storageScope) != nil
            }
            set(newValue) {
            }
        }
        //// The base fee charged regardless of the number of milli-satoshis sent.
        public fileprivate(set) var baseFeeMsat:Int64! = nil
        public fileprivate(set) var hasBaseFeeMsat:Bool = false

        //// The effective fee rate in milli-satoshis. The precision of this value goes up to 6 decimal places, so 1e-6.
        public fileprivate(set) var feeRate:Double! = nil
        public fileprivate(set) var hasFeeRate:Bool = false

        //// The required timelock delta for HTLCs forwarded over the channel.
        public fileprivate(set) var timeLockDelta:UInt32! = nil
        public fileprivate(set) var hasTimeLockDelta:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGlobal {
                try codedOutputStream.writeBool(fieldNumber: 1, value:global)
            }
            if hasChanPoint {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:chanPoint)
            }
            if hasBaseFeeMsat {
                try codedOutputStream.writeInt64(fieldNumber: 3, value:baseFeeMsat)
            }
            if hasFeeRate {
                try codedOutputStream.writeDouble(fieldNumber: 4, value:feeRate)
            }
            if hasTimeLockDelta {
                try codedOutputStream.writeUInt32(fieldNumber: 5, value:timeLockDelta)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGlobal {
                serialize_size += global.computeBoolSize(fieldNumber: 1)
            }
            if hasChanPoint {
                if let varSizechanPoint = chanPoint?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizechanPoint
                }
            }
            if hasBaseFeeMsat {
                serialize_size += baseFeeMsat.computeInt64Size(fieldNumber: 3)
            }
            if hasFeeRate {
                serialize_size += feeRate.computeDoubleSize(fieldNumber: 4)
            }
            if hasTimeLockDelta {
                serialize_size += timeLockDelta.computeUInt32Size(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.PolicyUpdateRequest.Builder {
            return Lnrpc.PolicyUpdateRequest.classBuilder() as! Lnrpc.PolicyUpdateRequest.Builder
        }
        public func getBuilder() -> Lnrpc.PolicyUpdateRequest.Builder {
            return classBuilder() as! Lnrpc.PolicyUpdateRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.PolicyUpdateRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.PolicyUpdateRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.PolicyUpdateRequest.Builder {
            return try Lnrpc.PolicyUpdateRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.PolicyUpdateRequest) throws -> Lnrpc.PolicyUpdateRequest.Builder {
            return try Lnrpc.PolicyUpdateRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGlobal {
                jsonMap["global"] = global
            }
            if hasChanPoint {
                jsonMap["chan_point"] = try chanPoint.encode()
            }
            if hasBaseFeeMsat {
                jsonMap["base_fee_msat"] = "\(baseFeeMsat!)"
            }
            if hasFeeRate {
                jsonMap["fee_rate"] = Double(feeRate)
            }
            if hasTimeLockDelta {
                jsonMap["time_lock_delta"] = UInt(timeLockDelta)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PolicyUpdateRequest {
            return try Lnrpc.PolicyUpdateRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PolicyUpdateRequest {
            return try Lnrpc.PolicyUpdateRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGlobal {
                output += "\(indent) global: \(global) \n"
            }
            if hasChanPoint {
                output += "\(indent) chanPoint {\n"
                if let outDescChanPoint = chanPoint {
                    output += try outDescChanPoint.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasBaseFeeMsat {
                output += "\(indent) baseFeeMsat: \(baseFeeMsat) \n"
            }
            if hasFeeRate {
                output += "\(indent) feeRate: \(feeRate) \n"
            }
            if hasTimeLockDelta {
                output += "\(indent) timeLockDelta: \(timeLockDelta) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGlobal {
                    hashCode = (hashCode &* 31) &+ global.hashValue
                }
                if hasChanPoint {
                    if let hashValuechanPoint = chanPoint?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuechanPoint
                    }
                }
                if hasBaseFeeMsat {
                    hashCode = (hashCode &* 31) &+ baseFeeMsat.hashValue
                }
                if hasFeeRate {
                    hashCode = (hashCode &* 31) &+ feeRate.hashValue
                }
                if hasTimeLockDelta {
                    hashCode = (hashCode &* 31) &+ timeLockDelta.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.PolicyUpdateRequest"
        }
        override public func className() -> String {
            return "Lnrpc.PolicyUpdateRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.PolicyUpdateRequest = Lnrpc.PolicyUpdateRequest()
            public func getMessage() -> Lnrpc.PolicyUpdateRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public func setScope(_ oneOf:PolicyUpdateRequest.Scope) ->  Lnrpc.PolicyUpdateRequest.Builder {
                builderResult.storageScope = oneOf
                return self
            }
            //// If set, then this update applies to all currently active channels.
            public var global:Bool {
                get {
                    return builderResult.global
                }
                set (value) {
                    builderResult.hasGlobal = true
                    builderResult.global = value
                }
            }
            public var hasGlobal:Bool {
                get {
                    return builderResult.hasGlobal
                }
            }
            @discardableResult
            public func setGlobal(_ value:Bool) -> Lnrpc.PolicyUpdateRequest.Builder {
                self.global = value
                return self
            }
            @discardableResult
            public func clearGlobal() -> Lnrpc.PolicyUpdateRequest.Builder{
                builderResult.hasGlobal = false
                builderResult.global = nil
                return self
            }
            //// If set, this update will target a specific channel.
            public var chanPoint:Lnrpc.ChannelPoint! {
                get {
                    if chanPointBuilder_ != nil {
                        builderResult.chanPoint = chanPointBuilder_.getMessage()
                    }
                    return builderResult.chanPoint
                }
                set (value) {
                    builderResult.hasChanPoint = value != nil
                    builderResult.chanPoint = value
                }
            }
            public var hasChanPoint:Bool {
                get {
                    return builderResult.hasChanPoint
                }
            }
            fileprivate var chanPointBuilder_:Lnrpc.ChannelPoint.Builder! {
                didSet {
                    builderResult.hasChanPoint = true
                }
            }
            public func getChanPointBuilder() -> Lnrpc.ChannelPoint.Builder {
                if chanPointBuilder_ == nil {
                    chanPointBuilder_ = Lnrpc.ChannelPoint.Builder()
                    builderResult.chanPoint = chanPointBuilder_.getMessage()
                    if chanPoint != nil {
                        try! chanPointBuilder_.mergeFrom(other: chanPoint)
                    }
                }
                return chanPointBuilder_
            }
            @discardableResult
            public func setChanPoint(_ value:Lnrpc.ChannelPoint!) -> Lnrpc.PolicyUpdateRequest.Builder {
                self.chanPoint = value
                return self
            }
            @discardableResult
            public func mergeChanPoint(value:Lnrpc.ChannelPoint) throws -> Lnrpc.PolicyUpdateRequest.Builder {
                if builderResult.hasChanPoint {
                    builderResult.chanPoint = try Lnrpc.ChannelPoint.builderWithPrototype(prototype:builderResult.chanPoint).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.chanPoint = value
                }
                builderResult.hasChanPoint = true
                return self
            }
            @discardableResult
            public func clearChanPoint() -> Lnrpc.PolicyUpdateRequest.Builder {
                chanPointBuilder_ = nil
                builderResult.hasChanPoint = false
                builderResult.chanPoint = nil
                return self
            }
            //// The base fee charged regardless of the number of milli-satoshis sent.
            public var baseFeeMsat:Int64 {
                get {
                    return builderResult.baseFeeMsat
                }
                set (value) {
                    builderResult.hasBaseFeeMsat = true
                    builderResult.baseFeeMsat = value
                }
            }
            public var hasBaseFeeMsat:Bool {
                get {
                    return builderResult.hasBaseFeeMsat
                }
            }
            @discardableResult
            public func setBaseFeeMsat(_ value:Int64) -> Lnrpc.PolicyUpdateRequest.Builder {
                self.baseFeeMsat = value
                return self
            }
            @discardableResult
            public func clearBaseFeeMsat() -> Lnrpc.PolicyUpdateRequest.Builder{
                builderResult.hasBaseFeeMsat = false
                builderResult.baseFeeMsat = nil
                return self
            }
            //// The effective fee rate in milli-satoshis. The precision of this value goes up to 6 decimal places, so 1e-6.
            public var feeRate:Double {
                get {
                    return builderResult.feeRate
                }
                set (value) {
                    builderResult.hasFeeRate = true
                    builderResult.feeRate = value
                }
            }
            public var hasFeeRate:Bool {
                get {
                    return builderResult.hasFeeRate
                }
            }
            @discardableResult
            public func setFeeRate(_ value:Double) -> Lnrpc.PolicyUpdateRequest.Builder {
                self.feeRate = value
                return self
            }
            @discardableResult
            public func clearFeeRate() -> Lnrpc.PolicyUpdateRequest.Builder{
                builderResult.hasFeeRate = false
                builderResult.feeRate = nil
                return self
            }
            //// The required timelock delta for HTLCs forwarded over the channel.
            public var timeLockDelta:UInt32 {
                get {
                    return builderResult.timeLockDelta
                }
                set (value) {
                    builderResult.hasTimeLockDelta = true
                    builderResult.timeLockDelta = value
                }
            }
            public var hasTimeLockDelta:Bool {
                get {
                    return builderResult.hasTimeLockDelta
                }
            }
            @discardableResult
            public func setTimeLockDelta(_ value:UInt32) -> Lnrpc.PolicyUpdateRequest.Builder {
                self.timeLockDelta = value
                return self
            }
            @discardableResult
            public func clearTimeLockDelta() -> Lnrpc.PolicyUpdateRequest.Builder{
                builderResult.hasTimeLockDelta = false
                builderResult.timeLockDelta = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.PolicyUpdateRequest.Builder {
                builderResult = Lnrpc.PolicyUpdateRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.PolicyUpdateRequest.Builder {
                return try Lnrpc.PolicyUpdateRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.PolicyUpdateRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.PolicyUpdateRequest {
                let returnMe:Lnrpc.PolicyUpdateRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.PolicyUpdateRequest) throws -> Lnrpc.PolicyUpdateRequest.Builder {
                if other == Lnrpc.PolicyUpdateRequest() {
                    return self
                }
                if other.hasGlobal {
                    global = other.global
                }
                if (other.hasChanPoint) {
                    try mergeChanPoint(value: other.chanPoint)
                }
                if other.hasBaseFeeMsat {
                    baseFeeMsat = other.baseFeeMsat
                }
                if other.hasFeeRate {
                    feeRate = other.feeRate
                }
                if other.hasTimeLockDelta {
                    timeLockDelta = other.timeLockDelta
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PolicyUpdateRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PolicyUpdateRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        global = try codedInputStream.readBool()

                    case 18:
                        let subBuilder:Lnrpc.ChannelPoint.Builder = Lnrpc.ChannelPoint.Builder()
                        if hasChanPoint {
                            try subBuilder.mergeFrom(other: chanPoint)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        chanPoint = subBuilder.buildPartial()

                    case 24:
                        baseFeeMsat = try codedInputStream.readInt64()

                    case 33:
                        feeRate = try codedInputStream.readDouble()

                    case 40:
                        timeLockDelta = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PolicyUpdateRequest.Builder {
                let resultDecodedBuilder = Lnrpc.PolicyUpdateRequest.Builder()
                if let jsonValueGlobal = jsonMap["global"] as? Bool {
                    resultDecodedBuilder.global = jsonValueGlobal
                }
                if let jsonValueChanPoint = jsonMap["chan_point"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.chanPoint = try Lnrpc.ChannelPoint.Builder.decodeToBuilder(jsonMap:jsonValueChanPoint).build()

                }
                if let jsonValueBaseFeeMsat = jsonMap["base_fee_msat"] as? String {
                    resultDecodedBuilder.baseFeeMsat = Int64(jsonValueBaseFeeMsat)!
                } else if let jsonValueBaseFeeMsat = jsonMap["base_fee_msat"] as? Int {
                    resultDecodedBuilder.baseFeeMsat = Int64(jsonValueBaseFeeMsat)
                }
                if let jsonValueFeeRate = jsonMap["fee_rate"] as? Double {
                    resultDecodedBuilder.feeRate = Double(jsonValueFeeRate)
                } else if let jsonValueFeeRate = jsonMap["fee_rate"] as? String {
                    resultDecodedBuilder.feeRate = Double(jsonValueFeeRate)!
                }
                if let jsonValueTimeLockDelta = jsonMap["time_lock_delta"] as? UInt {
                    resultDecodedBuilder.timeLockDelta = UInt32(jsonValueTimeLockDelta)
                } else if let jsonValueTimeLockDelta = jsonMap["time_lock_delta"] as? String {
                    resultDecodedBuilder.timeLockDelta = UInt32(jsonValueTimeLockDelta)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PolicyUpdateRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.PolicyUpdateRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class PolicyUpdateResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.PolicyUpdateResponse.Builder

        public static func == (lhs: Lnrpc.PolicyUpdateResponse, rhs: Lnrpc.PolicyUpdateResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.PolicyUpdateResponse.Builder {
            return Lnrpc.PolicyUpdateResponse.classBuilder() as! Lnrpc.PolicyUpdateResponse.Builder
        }
        public func getBuilder() -> Lnrpc.PolicyUpdateResponse.Builder {
            return classBuilder() as! Lnrpc.PolicyUpdateResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.PolicyUpdateResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.PolicyUpdateResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.PolicyUpdateResponse.Builder {
            return try Lnrpc.PolicyUpdateResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.PolicyUpdateResponse) throws -> Lnrpc.PolicyUpdateResponse.Builder {
            return try Lnrpc.PolicyUpdateResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PolicyUpdateResponse {
            return try Lnrpc.PolicyUpdateResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PolicyUpdateResponse {
            return try Lnrpc.PolicyUpdateResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.PolicyUpdateResponse"
        }
        override public func className() -> String {
            return "Lnrpc.PolicyUpdateResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.PolicyUpdateResponse = Lnrpc.PolicyUpdateResponse()
            public func getMessage() -> Lnrpc.PolicyUpdateResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.PolicyUpdateResponse.Builder {
                builderResult = Lnrpc.PolicyUpdateResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.PolicyUpdateResponse.Builder {
                return try Lnrpc.PolicyUpdateResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.PolicyUpdateResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.PolicyUpdateResponse {
                let returnMe:Lnrpc.PolicyUpdateResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.PolicyUpdateResponse) throws -> Lnrpc.PolicyUpdateResponse.Builder {
                if other == Lnrpc.PolicyUpdateResponse() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PolicyUpdateResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PolicyUpdateResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.PolicyUpdateResponse.Builder {
                let resultDecodedBuilder = Lnrpc.PolicyUpdateResponse.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.PolicyUpdateResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.PolicyUpdateResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ForwardingHistoryRequest : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ForwardingHistoryRequest.Builder

        public static func == (lhs: Lnrpc.ForwardingHistoryRequest, rhs: Lnrpc.ForwardingHistoryRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasStartTime == rhs.hasStartTime) && (!lhs.hasStartTime || lhs.startTime == rhs.startTime)
            fieldCheck = fieldCheck && (lhs.hasEndTime == rhs.hasEndTime) && (!lhs.hasEndTime || lhs.endTime == rhs.endTime)
            fieldCheck = fieldCheck && (lhs.hasIndexOffset == rhs.hasIndexOffset) && (!lhs.hasIndexOffset || lhs.indexOffset == rhs.indexOffset)
            fieldCheck = fieldCheck && (lhs.hasNumMaxEvents == rhs.hasNumMaxEvents) && (!lhs.hasNumMaxEvents || lhs.numMaxEvents == rhs.numMaxEvents)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// Start time is the starting point of the forwarding history request. All records beyond this point will be included, respecting the end time, and the index offset.
        public fileprivate(set) var startTime:UInt64! = nil
        public fileprivate(set) var hasStartTime:Bool = false

        //// End time is the end point of the forwarding history request. The response will carry at most 50k records between the start time and the end time. The index offset can be used to implement pagination.
        public fileprivate(set) var endTime:UInt64! = nil
        public fileprivate(set) var hasEndTime:Bool = false

        //// Index offset is the offset in the time series to start at. As each response can only contain 50k records, callers can use this to skip around within a packed time series.
        public fileprivate(set) var indexOffset:UInt32! = nil
        public fileprivate(set) var hasIndexOffset:Bool = false

        //// The max number of events to return in the response to this query.
        public fileprivate(set) var numMaxEvents:UInt32! = nil
        public fileprivate(set) var hasNumMaxEvents:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasStartTime {
                try codedOutputStream.writeUInt64(fieldNumber: 1, value:startTime)
            }
            if hasEndTime {
                try codedOutputStream.writeUInt64(fieldNumber: 2, value:endTime)
            }
            if hasIndexOffset {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:indexOffset)
            }
            if hasNumMaxEvents {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:numMaxEvents)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasStartTime {
                serialize_size += startTime.computeUInt64Size(fieldNumber: 1)
            }
            if hasEndTime {
                serialize_size += endTime.computeUInt64Size(fieldNumber: 2)
            }
            if hasIndexOffset {
                serialize_size += indexOffset.computeUInt32Size(fieldNumber: 3)
            }
            if hasNumMaxEvents {
                serialize_size += numMaxEvents.computeUInt32Size(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ForwardingHistoryRequest.Builder {
            return Lnrpc.ForwardingHistoryRequest.classBuilder() as! Lnrpc.ForwardingHistoryRequest.Builder
        }
        public func getBuilder() -> Lnrpc.ForwardingHistoryRequest.Builder {
            return classBuilder() as! Lnrpc.ForwardingHistoryRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ForwardingHistoryRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ForwardingHistoryRequest.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ForwardingHistoryRequest.Builder {
            return try Lnrpc.ForwardingHistoryRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ForwardingHistoryRequest) throws -> Lnrpc.ForwardingHistoryRequest.Builder {
            return try Lnrpc.ForwardingHistoryRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasStartTime {
                jsonMap["start_time"] = "\(startTime!)"
            }
            if hasEndTime {
                jsonMap["end_time"] = "\(endTime!)"
            }
            if hasIndexOffset {
                jsonMap["index_offset"] = UInt(indexOffset)
            }
            if hasNumMaxEvents {
                jsonMap["num_max_events"] = UInt(numMaxEvents)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ForwardingHistoryRequest {
            return try Lnrpc.ForwardingHistoryRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ForwardingHistoryRequest {
            return try Lnrpc.ForwardingHistoryRequest.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasStartTime {
                output += "\(indent) startTime: \(startTime) \n"
            }
            if hasEndTime {
                output += "\(indent) endTime: \(endTime) \n"
            }
            if hasIndexOffset {
                output += "\(indent) indexOffset: \(indexOffset) \n"
            }
            if hasNumMaxEvents {
                output += "\(indent) numMaxEvents: \(numMaxEvents) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStartTime {
                    hashCode = (hashCode &* 31) &+ startTime.hashValue
                }
                if hasEndTime {
                    hashCode = (hashCode &* 31) &+ endTime.hashValue
                }
                if hasIndexOffset {
                    hashCode = (hashCode &* 31) &+ indexOffset.hashValue
                }
                if hasNumMaxEvents {
                    hashCode = (hashCode &* 31) &+ numMaxEvents.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ForwardingHistoryRequest"
        }
        override public func className() -> String {
            return "Lnrpc.ForwardingHistoryRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ForwardingHistoryRequest = Lnrpc.ForwardingHistoryRequest()
            public func getMessage() -> Lnrpc.ForwardingHistoryRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// Start time is the starting point of the forwarding history request. All records beyond this point will be included, respecting the end time, and the index offset.
            public var startTime:UInt64 {
                get {
                    return builderResult.startTime
                }
                set (value) {
                    builderResult.hasStartTime = true
                    builderResult.startTime = value
                }
            }
            public var hasStartTime:Bool {
                get {
                    return builderResult.hasStartTime
                }
            }
            @discardableResult
            public func setStartTime(_ value:UInt64) -> Lnrpc.ForwardingHistoryRequest.Builder {
                self.startTime = value
                return self
            }
            @discardableResult
            public func clearStartTime() -> Lnrpc.ForwardingHistoryRequest.Builder{
                builderResult.hasStartTime = false
                builderResult.startTime = nil
                return self
            }
            //// End time is the end point of the forwarding history request. The response will carry at most 50k records between the start time and the end time. The index offset can be used to implement pagination.
            public var endTime:UInt64 {
                get {
                    return builderResult.endTime
                }
                set (value) {
                    builderResult.hasEndTime = true
                    builderResult.endTime = value
                }
            }
            public var hasEndTime:Bool {
                get {
                    return builderResult.hasEndTime
                }
            }
            @discardableResult
            public func setEndTime(_ value:UInt64) -> Lnrpc.ForwardingHistoryRequest.Builder {
                self.endTime = value
                return self
            }
            @discardableResult
            public func clearEndTime() -> Lnrpc.ForwardingHistoryRequest.Builder{
                builderResult.hasEndTime = false
                builderResult.endTime = nil
                return self
            }
            //// Index offset is the offset in the time series to start at. As each response can only contain 50k records, callers can use this to skip around within a packed time series.
            public var indexOffset:UInt32 {
                get {
                    return builderResult.indexOffset
                }
                set (value) {
                    builderResult.hasIndexOffset = true
                    builderResult.indexOffset = value
                }
            }
            public var hasIndexOffset:Bool {
                get {
                    return builderResult.hasIndexOffset
                }
            }
            @discardableResult
            public func setIndexOffset(_ value:UInt32) -> Lnrpc.ForwardingHistoryRequest.Builder {
                self.indexOffset = value
                return self
            }
            @discardableResult
            public func clearIndexOffset() -> Lnrpc.ForwardingHistoryRequest.Builder{
                builderResult.hasIndexOffset = false
                builderResult.indexOffset = nil
                return self
            }
            //// The max number of events to return in the response to this query.
            public var numMaxEvents:UInt32 {
                get {
                    return builderResult.numMaxEvents
                }
                set (value) {
                    builderResult.hasNumMaxEvents = true
                    builderResult.numMaxEvents = value
                }
            }
            public var hasNumMaxEvents:Bool {
                get {
                    return builderResult.hasNumMaxEvents
                }
            }
            @discardableResult
            public func setNumMaxEvents(_ value:UInt32) -> Lnrpc.ForwardingHistoryRequest.Builder {
                self.numMaxEvents = value
                return self
            }
            @discardableResult
            public func clearNumMaxEvents() -> Lnrpc.ForwardingHistoryRequest.Builder{
                builderResult.hasNumMaxEvents = false
                builderResult.numMaxEvents = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ForwardingHistoryRequest.Builder {
                builderResult = Lnrpc.ForwardingHistoryRequest()
                return self
            }
            override public func clone() throws -> Lnrpc.ForwardingHistoryRequest.Builder {
                return try Lnrpc.ForwardingHistoryRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ForwardingHistoryRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ForwardingHistoryRequest {
                let returnMe:Lnrpc.ForwardingHistoryRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ForwardingHistoryRequest) throws -> Lnrpc.ForwardingHistoryRequest.Builder {
                if other == Lnrpc.ForwardingHistoryRequest() {
                    return self
                }
                if other.hasStartTime {
                    startTime = other.startTime
                }
                if other.hasEndTime {
                    endTime = other.endTime
                }
                if other.hasIndexOffset {
                    indexOffset = other.indexOffset
                }
                if other.hasNumMaxEvents {
                    numMaxEvents = other.numMaxEvents
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ForwardingHistoryRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ForwardingHistoryRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        startTime = try codedInputStream.readUInt64()

                    case 16:
                        endTime = try codedInputStream.readUInt64()

                    case 24:
                        indexOffset = try codedInputStream.readUInt32()

                    case 32:
                        numMaxEvents = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ForwardingHistoryRequest.Builder {
                let resultDecodedBuilder = Lnrpc.ForwardingHistoryRequest.Builder()
                if let jsonValueStartTime = jsonMap["start_time"] as? String {
                    resultDecodedBuilder.startTime = UInt64(jsonValueStartTime)!
                } else if let jsonValueStartTime = jsonMap["start_time"] as? UInt {
                    resultDecodedBuilder.startTime = UInt64(jsonValueStartTime)
                }
                if let jsonValueEndTime = jsonMap["end_time"] as? String {
                    resultDecodedBuilder.endTime = UInt64(jsonValueEndTime)!
                } else if let jsonValueEndTime = jsonMap["end_time"] as? UInt {
                    resultDecodedBuilder.endTime = UInt64(jsonValueEndTime)
                }
                if let jsonValueIndexOffset = jsonMap["index_offset"] as? UInt {
                    resultDecodedBuilder.indexOffset = UInt32(jsonValueIndexOffset)
                } else if let jsonValueIndexOffset = jsonMap["index_offset"] as? String {
                    resultDecodedBuilder.indexOffset = UInt32(jsonValueIndexOffset)!
                }
                if let jsonValueNumMaxEvents = jsonMap["num_max_events"] as? UInt {
                    resultDecodedBuilder.numMaxEvents = UInt32(jsonValueNumMaxEvents)
                } else if let jsonValueNumMaxEvents = jsonMap["num_max_events"] as? String {
                    resultDecodedBuilder.numMaxEvents = UInt32(jsonValueNumMaxEvents)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ForwardingHistoryRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ForwardingHistoryRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ForwardingEvent : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ForwardingEvent.Builder

        public static func == (lhs: Lnrpc.ForwardingEvent, rhs: Lnrpc.ForwardingEvent) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
            fieldCheck = fieldCheck && (lhs.hasChanIdIn == rhs.hasChanIdIn) && (!lhs.hasChanIdIn || lhs.chanIdIn == rhs.chanIdIn)
            fieldCheck = fieldCheck && (lhs.hasChanIdOut == rhs.hasChanIdOut) && (!lhs.hasChanIdOut || lhs.chanIdOut == rhs.chanIdOut)
            fieldCheck = fieldCheck && (lhs.hasAmtIn == rhs.hasAmtIn) && (!lhs.hasAmtIn || lhs.amtIn == rhs.amtIn)
            fieldCheck = fieldCheck && (lhs.hasAmtOut == rhs.hasAmtOut) && (!lhs.hasAmtOut || lhs.amtOut == rhs.amtOut)
            fieldCheck = fieldCheck && (lhs.hasFee == rhs.hasFee) && (!lhs.hasFee || lhs.fee == rhs.fee)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        //// Timestamp is the time (unix epoch offset) that this circuit was completed.
        public fileprivate(set) var timestamp:UInt64! = nil
        public fileprivate(set) var hasTimestamp:Bool = false

        //// The incoming channel ID that carried the HTLC that created the circuit.
        public fileprivate(set) var chanIdIn:UInt64! = nil
        public fileprivate(set) var hasChanIdIn:Bool = false

        //// The outgoing channel ID that carried the preimage that completed the circuit.
        public fileprivate(set) var chanIdOut:UInt64! = nil
        public fileprivate(set) var hasChanIdOut:Bool = false

        //// The total amount of the incoming HTLC that created half the circuit.
        public fileprivate(set) var amtIn:UInt64! = nil
        public fileprivate(set) var hasAmtIn:Bool = false

        //// The total amount of the outgoign HTLC that created the second half of the circuit.
        public fileprivate(set) var amtOut:UInt64! = nil
        public fileprivate(set) var hasAmtOut:Bool = false

        //// The total fee that this payment circuit carried.
        public fileprivate(set) var fee:UInt64! = nil
        public fileprivate(set) var hasFee:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTimestamp {
                try codedOutputStream.writeUInt64(fieldNumber: 1, value:timestamp)
            }
            if hasChanIdIn {
                try codedOutputStream.writeUInt64(fieldNumber: 2, value:chanIdIn)
            }
            if hasChanIdOut {
                try codedOutputStream.writeUInt64(fieldNumber: 4, value:chanIdOut)
            }
            if hasAmtIn {
                try codedOutputStream.writeUInt64(fieldNumber: 5, value:amtIn)
            }
            if hasAmtOut {
                try codedOutputStream.writeUInt64(fieldNumber: 6, value:amtOut)
            }
            if hasFee {
                try codedOutputStream.writeUInt64(fieldNumber: 7, value:fee)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTimestamp {
                serialize_size += timestamp.computeUInt64Size(fieldNumber: 1)
            }
            if hasChanIdIn {
                serialize_size += chanIdIn.computeUInt64Size(fieldNumber: 2)
            }
            if hasChanIdOut {
                serialize_size += chanIdOut.computeUInt64Size(fieldNumber: 4)
            }
            if hasAmtIn {
                serialize_size += amtIn.computeUInt64Size(fieldNumber: 5)
            }
            if hasAmtOut {
                serialize_size += amtOut.computeUInt64Size(fieldNumber: 6)
            }
            if hasFee {
                serialize_size += fee.computeUInt64Size(fieldNumber: 7)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ForwardingEvent.Builder {
            return Lnrpc.ForwardingEvent.classBuilder() as! Lnrpc.ForwardingEvent.Builder
        }
        public func getBuilder() -> Lnrpc.ForwardingEvent.Builder {
            return classBuilder() as! Lnrpc.ForwardingEvent.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ForwardingEvent.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ForwardingEvent.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ForwardingEvent.Builder {
            return try Lnrpc.ForwardingEvent.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ForwardingEvent) throws -> Lnrpc.ForwardingEvent.Builder {
            return try Lnrpc.ForwardingEvent.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTimestamp {
                jsonMap["timestamp"] = "\(timestamp!)"
            }
            if hasChanIdIn {
                jsonMap["chan_id_in"] = "\(chanIdIn!)"
            }
            if hasChanIdOut {
                jsonMap["chan_id_out"] = "\(chanIdOut!)"
            }
            if hasAmtIn {
                jsonMap["amt_in"] = "\(amtIn!)"
            }
            if hasAmtOut {
                jsonMap["amt_out"] = "\(amtOut!)"
            }
            if hasFee {
                jsonMap["fee"] = "\(fee!)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ForwardingEvent {
            return try Lnrpc.ForwardingEvent.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ForwardingEvent {
            return try Lnrpc.ForwardingEvent.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTimestamp {
                output += "\(indent) timestamp: \(timestamp) \n"
            }
            if hasChanIdIn {
                output += "\(indent) chanIdIn: \(chanIdIn) \n"
            }
            if hasChanIdOut {
                output += "\(indent) chanIdOut: \(chanIdOut) \n"
            }
            if hasAmtIn {
                output += "\(indent) amtIn: \(amtIn) \n"
            }
            if hasAmtOut {
                output += "\(indent) amtOut: \(amtOut) \n"
            }
            if hasFee {
                output += "\(indent) fee: \(fee) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTimestamp {
                    hashCode = (hashCode &* 31) &+ timestamp.hashValue
                }
                if hasChanIdIn {
                    hashCode = (hashCode &* 31) &+ chanIdIn.hashValue
                }
                if hasChanIdOut {
                    hashCode = (hashCode &* 31) &+ chanIdOut.hashValue
                }
                if hasAmtIn {
                    hashCode = (hashCode &* 31) &+ amtIn.hashValue
                }
                if hasAmtOut {
                    hashCode = (hashCode &* 31) &+ amtOut.hashValue
                }
                if hasFee {
                    hashCode = (hashCode &* 31) &+ fee.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ForwardingEvent"
        }
        override public func className() -> String {
            return "Lnrpc.ForwardingEvent"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ForwardingEvent = Lnrpc.ForwardingEvent()
            public func getMessage() -> Lnrpc.ForwardingEvent {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// Timestamp is the time (unix epoch offset) that this circuit was completed.
            public var timestamp:UInt64 {
                get {
                    return builderResult.timestamp
                }
                set (value) {
                    builderResult.hasTimestamp = true
                    builderResult.timestamp = value
                }
            }
            public var hasTimestamp:Bool {
                get {
                    return builderResult.hasTimestamp
                }
            }
            @discardableResult
            public func setTimestamp(_ value:UInt64) -> Lnrpc.ForwardingEvent.Builder {
                self.timestamp = value
                return self
            }
            @discardableResult
            public func clearTimestamp() -> Lnrpc.ForwardingEvent.Builder{
                builderResult.hasTimestamp = false
                builderResult.timestamp = nil
                return self
            }
            //// The incoming channel ID that carried the HTLC that created the circuit.
            public var chanIdIn:UInt64 {
                get {
                    return builderResult.chanIdIn
                }
                set (value) {
                    builderResult.hasChanIdIn = true
                    builderResult.chanIdIn = value
                }
            }
            public var hasChanIdIn:Bool {
                get {
                    return builderResult.hasChanIdIn
                }
            }
            @discardableResult
            public func setChanIdIn(_ value:UInt64) -> Lnrpc.ForwardingEvent.Builder {
                self.chanIdIn = value
                return self
            }
            @discardableResult
            public func clearChanIdIn() -> Lnrpc.ForwardingEvent.Builder{
                builderResult.hasChanIdIn = false
                builderResult.chanIdIn = nil
                return self
            }
            //// The outgoing channel ID that carried the preimage that completed the circuit.
            public var chanIdOut:UInt64 {
                get {
                    return builderResult.chanIdOut
                }
                set (value) {
                    builderResult.hasChanIdOut = true
                    builderResult.chanIdOut = value
                }
            }
            public var hasChanIdOut:Bool {
                get {
                    return builderResult.hasChanIdOut
                }
            }
            @discardableResult
            public func setChanIdOut(_ value:UInt64) -> Lnrpc.ForwardingEvent.Builder {
                self.chanIdOut = value
                return self
            }
            @discardableResult
            public func clearChanIdOut() -> Lnrpc.ForwardingEvent.Builder{
                builderResult.hasChanIdOut = false
                builderResult.chanIdOut = nil
                return self
            }
            //// The total amount of the incoming HTLC that created half the circuit.
            public var amtIn:UInt64 {
                get {
                    return builderResult.amtIn
                }
                set (value) {
                    builderResult.hasAmtIn = true
                    builderResult.amtIn = value
                }
            }
            public var hasAmtIn:Bool {
                get {
                    return builderResult.hasAmtIn
                }
            }
            @discardableResult
            public func setAmtIn(_ value:UInt64) -> Lnrpc.ForwardingEvent.Builder {
                self.amtIn = value
                return self
            }
            @discardableResult
            public func clearAmtIn() -> Lnrpc.ForwardingEvent.Builder{
                builderResult.hasAmtIn = false
                builderResult.amtIn = nil
                return self
            }
            //// The total amount of the outgoign HTLC that created the second half of the circuit.
            public var amtOut:UInt64 {
                get {
                    return builderResult.amtOut
                }
                set (value) {
                    builderResult.hasAmtOut = true
                    builderResult.amtOut = value
                }
            }
            public var hasAmtOut:Bool {
                get {
                    return builderResult.hasAmtOut
                }
            }
            @discardableResult
            public func setAmtOut(_ value:UInt64) -> Lnrpc.ForwardingEvent.Builder {
                self.amtOut = value
                return self
            }
            @discardableResult
            public func clearAmtOut() -> Lnrpc.ForwardingEvent.Builder{
                builderResult.hasAmtOut = false
                builderResult.amtOut = nil
                return self
            }
            //// The total fee that this payment circuit carried.
            public var fee:UInt64 {
                get {
                    return builderResult.fee
                }
                set (value) {
                    builderResult.hasFee = true
                    builderResult.fee = value
                }
            }
            public var hasFee:Bool {
                get {
                    return builderResult.hasFee
                }
            }
            @discardableResult
            public func setFee(_ value:UInt64) -> Lnrpc.ForwardingEvent.Builder {
                self.fee = value
                return self
            }
            @discardableResult
            public func clearFee() -> Lnrpc.ForwardingEvent.Builder{
                builderResult.hasFee = false
                builderResult.fee = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ForwardingEvent.Builder {
                builderResult = Lnrpc.ForwardingEvent()
                return self
            }
            override public func clone() throws -> Lnrpc.ForwardingEvent.Builder {
                return try Lnrpc.ForwardingEvent.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ForwardingEvent {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ForwardingEvent {
                let returnMe:Lnrpc.ForwardingEvent = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ForwardingEvent) throws -> Lnrpc.ForwardingEvent.Builder {
                if other == Lnrpc.ForwardingEvent() {
                    return self
                }
                if other.hasTimestamp {
                    timestamp = other.timestamp
                }
                if other.hasChanIdIn {
                    chanIdIn = other.chanIdIn
                }
                if other.hasChanIdOut {
                    chanIdOut = other.chanIdOut
                }
                if other.hasAmtIn {
                    amtIn = other.amtIn
                }
                if other.hasAmtOut {
                    amtOut = other.amtOut
                }
                if other.hasFee {
                    fee = other.fee
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ForwardingEvent.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ForwardingEvent.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        timestamp = try codedInputStream.readUInt64()

                    case 16:
                        chanIdIn = try codedInputStream.readUInt64()

                    case 32:
                        chanIdOut = try codedInputStream.readUInt64()

                    case 40:
                        amtIn = try codedInputStream.readUInt64()

                    case 48:
                        amtOut = try codedInputStream.readUInt64()

                    case 56:
                        fee = try codedInputStream.readUInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ForwardingEvent.Builder {
                let resultDecodedBuilder = Lnrpc.ForwardingEvent.Builder()
                if let jsonValueTimestamp = jsonMap["timestamp"] as? String {
                    resultDecodedBuilder.timestamp = UInt64(jsonValueTimestamp)!
                } else if let jsonValueTimestamp = jsonMap["timestamp"] as? UInt {
                    resultDecodedBuilder.timestamp = UInt64(jsonValueTimestamp)
                }
                if let jsonValueChanIdIn = jsonMap["chan_id_in"] as? String {
                    resultDecodedBuilder.chanIdIn = UInt64(jsonValueChanIdIn)!
                } else if let jsonValueChanIdIn = jsonMap["chan_id_in"] as? UInt {
                    resultDecodedBuilder.chanIdIn = UInt64(jsonValueChanIdIn)
                }
                if let jsonValueChanIdOut = jsonMap["chan_id_out"] as? String {
                    resultDecodedBuilder.chanIdOut = UInt64(jsonValueChanIdOut)!
                } else if let jsonValueChanIdOut = jsonMap["chan_id_out"] as? UInt {
                    resultDecodedBuilder.chanIdOut = UInt64(jsonValueChanIdOut)
                }
                if let jsonValueAmtIn = jsonMap["amt_in"] as? String {
                    resultDecodedBuilder.amtIn = UInt64(jsonValueAmtIn)!
                } else if let jsonValueAmtIn = jsonMap["amt_in"] as? UInt {
                    resultDecodedBuilder.amtIn = UInt64(jsonValueAmtIn)
                }
                if let jsonValueAmtOut = jsonMap["amt_out"] as? String {
                    resultDecodedBuilder.amtOut = UInt64(jsonValueAmtOut)!
                } else if let jsonValueAmtOut = jsonMap["amt_out"] as? UInt {
                    resultDecodedBuilder.amtOut = UInt64(jsonValueAmtOut)
                }
                if let jsonValueFee = jsonMap["fee"] as? String {
                    resultDecodedBuilder.fee = UInt64(jsonValueFee)!
                } else if let jsonValueFee = jsonMap["fee"] as? UInt {
                    resultDecodedBuilder.fee = UInt64(jsonValueFee)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ForwardingEvent.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ForwardingEvent.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ForwardingHistoryResponse : GeneratedMessage {
        public typealias BuilderType = Lnrpc.ForwardingHistoryResponse.Builder

        public static func == (lhs: Lnrpc.ForwardingHistoryResponse, rhs: Lnrpc.ForwardingHistoryResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.forwardingEvents == rhs.forwardingEvents)
            fieldCheck = fieldCheck && (lhs.hasLastOffsetIndex == rhs.hasLastOffsetIndex) && (!lhs.hasLastOffsetIndex || lhs.lastOffsetIndex == rhs.lastOffsetIndex)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var forwardingEvents:Array<Lnrpc.ForwardingEvent>  = Array<Lnrpc.ForwardingEvent>()
        //// The index of the last time in the set of returned forwarding events. Can be used to seek further, pagination style.
        public fileprivate(set) var lastOffsetIndex:UInt32! = nil
        public fileprivate(set) var hasLastOffsetIndex:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementForwardingEvents in forwardingEvents {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementForwardingEvents)
            }
            if hasLastOffsetIndex {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:lastOffsetIndex)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementForwardingEvents in forwardingEvents {
                serialize_size += oneElementForwardingEvents.computeMessageSize(fieldNumber: 1)
            }
            if hasLastOffsetIndex {
                serialize_size += lastOffsetIndex.computeUInt32Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Lnrpc.ForwardingHistoryResponse.Builder {
            return Lnrpc.ForwardingHistoryResponse.classBuilder() as! Lnrpc.ForwardingHistoryResponse.Builder
        }
        public func getBuilder() -> Lnrpc.ForwardingHistoryResponse.Builder {
            return classBuilder() as! Lnrpc.ForwardingHistoryResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ForwardingHistoryResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Lnrpc.ForwardingHistoryResponse.Builder()
        }
        public func toBuilder() throws -> Lnrpc.ForwardingHistoryResponse.Builder {
            return try Lnrpc.ForwardingHistoryResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Lnrpc.ForwardingHistoryResponse) throws -> Lnrpc.ForwardingHistoryResponse.Builder {
            return try Lnrpc.ForwardingHistoryResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !forwardingEvents.isEmpty {
                var jsonArrayForwardingEvents:Array<Dictionary<String,Any>> = []
                for oneValueForwardingEvents in forwardingEvents {
                    let ecodedMessageForwardingEvents = try oneValueForwardingEvents.encode()
                    jsonArrayForwardingEvents.append(ecodedMessageForwardingEvents)
                }
                jsonMap["forwarding_events"] = jsonArrayForwardingEvents
            }
            if hasLastOffsetIndex {
                jsonMap["last_offset_index"] = UInt(lastOffsetIndex)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ForwardingHistoryResponse {
            return try Lnrpc.ForwardingHistoryResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ForwardingHistoryResponse {
            return try Lnrpc.ForwardingHistoryResponse.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var forwardingEventsElementIndex:Int = 0
            for oneElementForwardingEvents in forwardingEvents {
                output += "\(indent) forwardingEvents[\(forwardingEventsElementIndex)] {\n"
                output += try oneElementForwardingEvents.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                forwardingEventsElementIndex += 1
            }
            if hasLastOffsetIndex {
                output += "\(indent) lastOffsetIndex: \(lastOffsetIndex) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementForwardingEvents in forwardingEvents {
                    hashCode = (hashCode &* 31) &+ oneElementForwardingEvents.hashValue
                }
                if hasLastOffsetIndex {
                    hashCode = (hashCode &* 31) &+ lastOffsetIndex.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Lnrpc.ForwardingHistoryResponse"
        }
        override public func className() -> String {
            return "Lnrpc.ForwardingHistoryResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Lnrpc.ForwardingHistoryResponse = Lnrpc.ForwardingHistoryResponse()
            public func getMessage() -> Lnrpc.ForwardingHistoryResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// A list of forwarding events from the time slice of the time series specified in the request.
            public var forwardingEvents:Array<Lnrpc.ForwardingEvent> {
                get {
                    return builderResult.forwardingEvents
                }
                set (value) {
                    builderResult.forwardingEvents = value
                }
            }
            @discardableResult
            public func setForwardingEvents(_ value:Array<Lnrpc.ForwardingEvent>) -> Lnrpc.ForwardingHistoryResponse.Builder {
                self.forwardingEvents = value
                return self
            }
            @discardableResult
            public func clearForwardingEvents() -> Lnrpc.ForwardingHistoryResponse.Builder {
                builderResult.forwardingEvents.removeAll(keepingCapacity: false)
                return self
            }
            //// The index of the last time in the set of returned forwarding events. Can be used to seek further, pagination style.
            public var lastOffsetIndex:UInt32 {
                get {
                    return builderResult.lastOffsetIndex
                }
                set (value) {
                    builderResult.hasLastOffsetIndex = true
                    builderResult.lastOffsetIndex = value
                }
            }
            public var hasLastOffsetIndex:Bool {
                get {
                    return builderResult.hasLastOffsetIndex
                }
            }
            @discardableResult
            public func setLastOffsetIndex(_ value:UInt32) -> Lnrpc.ForwardingHistoryResponse.Builder {
                self.lastOffsetIndex = value
                return self
            }
            @discardableResult
            public func clearLastOffsetIndex() -> Lnrpc.ForwardingHistoryResponse.Builder{
                builderResult.hasLastOffsetIndex = false
                builderResult.lastOffsetIndex = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Lnrpc.ForwardingHistoryResponse.Builder {
                builderResult = Lnrpc.ForwardingHistoryResponse()
                return self
            }
            override public func clone() throws -> Lnrpc.ForwardingHistoryResponse.Builder {
                return try Lnrpc.ForwardingHistoryResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Lnrpc.ForwardingHistoryResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Lnrpc.ForwardingHistoryResponse {
                let returnMe:Lnrpc.ForwardingHistoryResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Lnrpc.ForwardingHistoryResponse) throws -> Lnrpc.ForwardingHistoryResponse.Builder {
                if other == Lnrpc.ForwardingHistoryResponse() {
                    return self
                }
                if !other.forwardingEvents.isEmpty  {
                     builderResult.forwardingEvents += other.forwardingEvents
                }
                if other.hasLastOffsetIndex {
                    lastOffsetIndex = other.lastOffsetIndex
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ForwardingHistoryResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ForwardingHistoryResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Lnrpc.ForwardingEvent.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        forwardingEvents.append(subBuilder.buildPartial())

                    case 16:
                        lastOffsetIndex = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Lnrpc.ForwardingHistoryResponse.Builder {
                let resultDecodedBuilder = Lnrpc.ForwardingHistoryResponse.Builder()
                if let jsonValueForwardingEvents = jsonMap["forwarding_events"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayForwardingEvents:Array<Lnrpc.ForwardingEvent> = []
                    for oneValueForwardingEvents in jsonValueForwardingEvents {
                        let messageFromStringForwardingEvents = try Lnrpc.ForwardingEvent.Builder.decodeToBuilder(jsonMap:oneValueForwardingEvents).build()

                        jsonArrayForwardingEvents.append(messageFromStringForwardingEvents)
                    }
                    resultDecodedBuilder.forwardingEvents = jsonArrayForwardingEvents
                }
                if let jsonValueLastOffsetIndex = jsonMap["last_offset_index"] as? UInt {
                    resultDecodedBuilder.lastOffsetIndex = UInt32(jsonValueLastOffsetIndex)
                } else if let jsonValueLastOffsetIndex = jsonMap["last_offset_index"] as? String {
                    resultDecodedBuilder.lastOffsetIndex = UInt32(jsonValueLastOffsetIndex)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Lnrpc.ForwardingHistoryResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Lnrpc.ForwardingHistoryResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Lnrpc.GenSeedRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.GenSeedRequest> {
        var mergedArray = Array<Lnrpc.GenSeedRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.GenSeedRequest? {
        return try Lnrpc.GenSeedRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.GenSeedRequest {
        return try Lnrpc.GenSeedRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GenSeedRequest {
        return try Lnrpc.GenSeedRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.GenSeedRequest {
        return try Lnrpc.GenSeedRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GenSeedRequest {
        return try Lnrpc.GenSeedRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.GenSeedRequest {
        return try Lnrpc.GenSeedRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GenSeedRequest {
        return try Lnrpc.GenSeedRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "aezeedPassphrase": return self.aezeedPassphrase
        case "seedEntropy": return self.seedEntropy
        default: return nil
        }
    }
}
extension Lnrpc.GenSeedRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.GenSeedRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "aezeedPassphrase": return self.aezeedPassphrase
            case "seedEntropy": return self.seedEntropy
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "aezeedPassphrase":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.aezeedPassphrase = newSubscriptValue
            case "seedEntropy":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.seedEntropy = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.GenSeedResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.GenSeedResponse> {
        var mergedArray = Array<Lnrpc.GenSeedResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.GenSeedResponse? {
        return try Lnrpc.GenSeedResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.GenSeedResponse {
        return try Lnrpc.GenSeedResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GenSeedResponse {
        return try Lnrpc.GenSeedResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.GenSeedResponse {
        return try Lnrpc.GenSeedResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GenSeedResponse {
        return try Lnrpc.GenSeedResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.GenSeedResponse {
        return try Lnrpc.GenSeedResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GenSeedResponse {
        return try Lnrpc.GenSeedResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "cipherSeedMnemonic": return self.cipherSeedMnemonic
        case "encipheredSeed": return self.encipheredSeed
        default: return nil
        }
    }
}
extension Lnrpc.GenSeedResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.GenSeedResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "cipherSeedMnemonic": return self.cipherSeedMnemonic
            case "encipheredSeed": return self.encipheredSeed
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "cipherSeedMnemonic":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.cipherSeedMnemonic = newSubscriptValue
            case "encipheredSeed":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.encipheredSeed = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.InitWalletRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.InitWalletRequest> {
        var mergedArray = Array<Lnrpc.InitWalletRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.InitWalletRequest? {
        return try Lnrpc.InitWalletRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.InitWalletRequest {
        return try Lnrpc.InitWalletRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.InitWalletRequest {
        return try Lnrpc.InitWalletRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.InitWalletRequest {
        return try Lnrpc.InitWalletRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.InitWalletRequest {
        return try Lnrpc.InitWalletRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.InitWalletRequest {
        return try Lnrpc.InitWalletRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.InitWalletRequest {
        return try Lnrpc.InitWalletRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "walletPassword": return self.walletPassword
        case "cipherSeedMnemonic": return self.cipherSeedMnemonic
        case "aezeedPassphrase": return self.aezeedPassphrase
        case "recoveryWindow": return self.recoveryWindow
        default: return nil
        }
    }
}
extension Lnrpc.InitWalletRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.InitWalletRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "walletPassword": return self.walletPassword
            case "cipherSeedMnemonic": return self.cipherSeedMnemonic
            case "aezeedPassphrase": return self.aezeedPassphrase
            case "recoveryWindow": return self.recoveryWindow
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "walletPassword":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.walletPassword = newSubscriptValue
            case "cipherSeedMnemonic":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.cipherSeedMnemonic = newSubscriptValue
            case "aezeedPassphrase":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.aezeedPassphrase = newSubscriptValue
            case "recoveryWindow":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.recoveryWindow = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.InitWalletResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.InitWalletResponse> {
        var mergedArray = Array<Lnrpc.InitWalletResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.InitWalletResponse? {
        return try Lnrpc.InitWalletResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.InitWalletResponse {
        return try Lnrpc.InitWalletResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.InitWalletResponse {
        return try Lnrpc.InitWalletResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.InitWalletResponse {
        return try Lnrpc.InitWalletResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.InitWalletResponse {
        return try Lnrpc.InitWalletResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.InitWalletResponse {
        return try Lnrpc.InitWalletResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.InitWalletResponse {
        return try Lnrpc.InitWalletResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Lnrpc.InitWalletResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.InitWalletResponse
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Lnrpc.UnlockWalletRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.UnlockWalletRequest> {
        var mergedArray = Array<Lnrpc.UnlockWalletRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.UnlockWalletRequest? {
        return try Lnrpc.UnlockWalletRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.UnlockWalletRequest {
        return try Lnrpc.UnlockWalletRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.UnlockWalletRequest {
        return try Lnrpc.UnlockWalletRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.UnlockWalletRequest {
        return try Lnrpc.UnlockWalletRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.UnlockWalletRequest {
        return try Lnrpc.UnlockWalletRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.UnlockWalletRequest {
        return try Lnrpc.UnlockWalletRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.UnlockWalletRequest {
        return try Lnrpc.UnlockWalletRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "walletPassword": return self.walletPassword
        case "recoveryWindow": return self.recoveryWindow
        default: return nil
        }
    }
}
extension Lnrpc.UnlockWalletRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.UnlockWalletRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "walletPassword": return self.walletPassword
            case "recoveryWindow": return self.recoveryWindow
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "walletPassword":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.walletPassword = newSubscriptValue
            case "recoveryWindow":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.recoveryWindow = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.UnlockWalletResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.UnlockWalletResponse> {
        var mergedArray = Array<Lnrpc.UnlockWalletResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.UnlockWalletResponse? {
        return try Lnrpc.UnlockWalletResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.UnlockWalletResponse {
        return try Lnrpc.UnlockWalletResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.UnlockWalletResponse {
        return try Lnrpc.UnlockWalletResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.UnlockWalletResponse {
        return try Lnrpc.UnlockWalletResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.UnlockWalletResponse {
        return try Lnrpc.UnlockWalletResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.UnlockWalletResponse {
        return try Lnrpc.UnlockWalletResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.UnlockWalletResponse {
        return try Lnrpc.UnlockWalletResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Lnrpc.UnlockWalletResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.UnlockWalletResponse
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Lnrpc.ChangePasswordRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ChangePasswordRequest> {
        var mergedArray = Array<Lnrpc.ChangePasswordRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ChangePasswordRequest? {
        return try Lnrpc.ChangePasswordRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ChangePasswordRequest {
        return try Lnrpc.ChangePasswordRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChangePasswordRequest {
        return try Lnrpc.ChangePasswordRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ChangePasswordRequest {
        return try Lnrpc.ChangePasswordRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChangePasswordRequest {
        return try Lnrpc.ChangePasswordRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChangePasswordRequest {
        return try Lnrpc.ChangePasswordRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChangePasswordRequest {
        return try Lnrpc.ChangePasswordRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "currentPassword": return self.currentPassword
        case "newPassword": return self.newPassword
        default: return nil
        }
    }
}
extension Lnrpc.ChangePasswordRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ChangePasswordRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "currentPassword": return self.currentPassword
            case "newPassword": return self.newPassword
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "currentPassword":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.currentPassword = newSubscriptValue
            case "newPassword":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.newPassword = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.ChangePasswordResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ChangePasswordResponse> {
        var mergedArray = Array<Lnrpc.ChangePasswordResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ChangePasswordResponse? {
        return try Lnrpc.ChangePasswordResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ChangePasswordResponse {
        return try Lnrpc.ChangePasswordResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChangePasswordResponse {
        return try Lnrpc.ChangePasswordResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ChangePasswordResponse {
        return try Lnrpc.ChangePasswordResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChangePasswordResponse {
        return try Lnrpc.ChangePasswordResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChangePasswordResponse {
        return try Lnrpc.ChangePasswordResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChangePasswordResponse {
        return try Lnrpc.ChangePasswordResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Lnrpc.ChangePasswordResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ChangePasswordResponse
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Lnrpc.Transaction: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.Transaction> {
        var mergedArray = Array<Lnrpc.Transaction>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.Transaction? {
        return try Lnrpc.Transaction.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.Transaction {
        return try Lnrpc.Transaction.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Transaction {
        return try Lnrpc.Transaction.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.Transaction {
        return try Lnrpc.Transaction.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Transaction {
        return try Lnrpc.Transaction.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.Transaction {
        return try Lnrpc.Transaction.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Transaction {
        return try Lnrpc.Transaction.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "txHash": return self.txHash
        case "amount": return self.amount
        case "numConfirmations": return self.numConfirmations
        case "blockHash": return self.blockHash
        case "blockHeight": return self.blockHeight
        case "timeStamp": return self.timeStamp
        case "totalFees": return self.totalFees
        case "destAddresses": return self.destAddresses
        default: return nil
        }
    }
}
extension Lnrpc.Transaction.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.Transaction
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "txHash": return self.txHash
            case "amount": return self.amount
            case "numConfirmations": return self.numConfirmations
            case "blockHash": return self.blockHash
            case "blockHeight": return self.blockHeight
            case "timeStamp": return self.timeStamp
            case "totalFees": return self.totalFees
            case "destAddresses": return self.destAddresses
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "txHash":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.txHash = newSubscriptValue
            case "amount":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.amount = newSubscriptValue
            case "numConfirmations":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.numConfirmations = newSubscriptValue
            case "blockHash":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.blockHash = newSubscriptValue
            case "blockHeight":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.blockHeight = newSubscriptValue
            case "timeStamp":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.timeStamp = newSubscriptValue
            case "totalFees":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.totalFees = newSubscriptValue
            case "destAddresses":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.destAddresses = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.GetTransactionsRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.GetTransactionsRequest> {
        var mergedArray = Array<Lnrpc.GetTransactionsRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.GetTransactionsRequest? {
        return try Lnrpc.GetTransactionsRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.GetTransactionsRequest {
        return try Lnrpc.GetTransactionsRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GetTransactionsRequest {
        return try Lnrpc.GetTransactionsRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.GetTransactionsRequest {
        return try Lnrpc.GetTransactionsRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GetTransactionsRequest {
        return try Lnrpc.GetTransactionsRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.GetTransactionsRequest {
        return try Lnrpc.GetTransactionsRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GetTransactionsRequest {
        return try Lnrpc.GetTransactionsRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Lnrpc.GetTransactionsRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.GetTransactionsRequest
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Lnrpc.TransactionDetails: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.TransactionDetails> {
        var mergedArray = Array<Lnrpc.TransactionDetails>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.TransactionDetails? {
        return try Lnrpc.TransactionDetails.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.TransactionDetails {
        return try Lnrpc.TransactionDetails.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.TransactionDetails {
        return try Lnrpc.TransactionDetails.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.TransactionDetails {
        return try Lnrpc.TransactionDetails.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.TransactionDetails {
        return try Lnrpc.TransactionDetails.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.TransactionDetails {
        return try Lnrpc.TransactionDetails.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.TransactionDetails {
        return try Lnrpc.TransactionDetails.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "transactions": return self.transactions
        default: return nil
        }
    }
}
extension Lnrpc.TransactionDetails.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.TransactionDetails
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "transactions": return self.transactions
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "transactions":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.Transaction> else {
                    return
                }
                self.transactions = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.FeeLimit: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.FeeLimit> {
        var mergedArray = Array<Lnrpc.FeeLimit>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.FeeLimit? {
        return try Lnrpc.FeeLimit.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.FeeLimit {
        return try Lnrpc.FeeLimit.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.FeeLimit {
        return try Lnrpc.FeeLimit.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.FeeLimit {
        return try Lnrpc.FeeLimit.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.FeeLimit {
        return try Lnrpc.FeeLimit.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.FeeLimit {
        return try Lnrpc.FeeLimit.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.FeeLimit {
        return try Lnrpc.FeeLimit.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "fixed": return self.fixed
        case "percent": return self.percent
        default: return nil
        }
    }
}
extension Lnrpc.FeeLimit.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.FeeLimit
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "fixed": return self.fixed
            case "percent": return self.percent
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "fixed":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.fixed = newSubscriptValue
            case "percent":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.percent = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.SendRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.SendRequest> {
        var mergedArray = Array<Lnrpc.SendRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.SendRequest? {
        return try Lnrpc.SendRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.SendRequest {
        return try Lnrpc.SendRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendRequest {
        return try Lnrpc.SendRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.SendRequest {
        return try Lnrpc.SendRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendRequest {
        return try Lnrpc.SendRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.SendRequest {
        return try Lnrpc.SendRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendRequest {
        return try Lnrpc.SendRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "dest": return self.dest
        case "destString": return self.destString
        case "amt": return self.amt
        case "paymentHash": return self.paymentHash
        case "paymentHashString": return self.paymentHashString
        case "paymentRequest": return self.paymentRequest
        case "finalCltvDelta": return self.finalCltvDelta
        case "feeLimit": return self.feeLimit
        default: return nil
        }
    }
}
extension Lnrpc.SendRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.SendRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "dest": return self.dest
            case "destString": return self.destString
            case "amt": return self.amt
            case "paymentHash": return self.paymentHash
            case "paymentHashString": return self.paymentHashString
            case "paymentRequest": return self.paymentRequest
            case "finalCltvDelta": return self.finalCltvDelta
            case "feeLimit": return self.feeLimit
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "dest":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.dest = newSubscriptValue
            case "destString":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.destString = newSubscriptValue
            case "amt":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.amt = newSubscriptValue
            case "paymentHash":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.paymentHash = newSubscriptValue
            case "paymentHashString":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.paymentHashString = newSubscriptValue
            case "paymentRequest":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.paymentRequest = newSubscriptValue
            case "finalCltvDelta":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.finalCltvDelta = newSubscriptValue
            case "feeLimit":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.FeeLimit else {
                    return
                }
                self.feeLimit = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.SendResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.SendResponse> {
        var mergedArray = Array<Lnrpc.SendResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.SendResponse? {
        return try Lnrpc.SendResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.SendResponse {
        return try Lnrpc.SendResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendResponse {
        return try Lnrpc.SendResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.SendResponse {
        return try Lnrpc.SendResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendResponse {
        return try Lnrpc.SendResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.SendResponse {
        return try Lnrpc.SendResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendResponse {
        return try Lnrpc.SendResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "paymentError": return self.paymentError
        case "paymentPreimage": return self.paymentPreimage
        case "paymentRoute": return self.paymentRoute
        default: return nil
        }
    }
}
extension Lnrpc.SendResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.SendResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "paymentError": return self.paymentError
            case "paymentPreimage": return self.paymentPreimage
            case "paymentRoute": return self.paymentRoute
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "paymentError":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.paymentError = newSubscriptValue
            case "paymentPreimage":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.paymentPreimage = newSubscriptValue
            case "paymentRoute":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.Route else {
                    return
                }
                self.paymentRoute = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.SendToRouteRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.SendToRouteRequest> {
        var mergedArray = Array<Lnrpc.SendToRouteRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.SendToRouteRequest? {
        return try Lnrpc.SendToRouteRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.SendToRouteRequest {
        return try Lnrpc.SendToRouteRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendToRouteRequest {
        return try Lnrpc.SendToRouteRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.SendToRouteRequest {
        return try Lnrpc.SendToRouteRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendToRouteRequest {
        return try Lnrpc.SendToRouteRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.SendToRouteRequest {
        return try Lnrpc.SendToRouteRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendToRouteRequest {
        return try Lnrpc.SendToRouteRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "paymentHash": return self.paymentHash
        case "paymentHashString": return self.paymentHashString
        case "routes": return self.routes
        default: return nil
        }
    }
}
extension Lnrpc.SendToRouteRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.SendToRouteRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "paymentHash": return self.paymentHash
            case "paymentHashString": return self.paymentHashString
            case "routes": return self.routes
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "paymentHash":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.paymentHash = newSubscriptValue
            case "paymentHashString":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.paymentHashString = newSubscriptValue
            case "routes":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.Route> else {
                    return
                }
                self.routes = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.ChannelPoint: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ChannelPoint> {
        var mergedArray = Array<Lnrpc.ChannelPoint>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ChannelPoint? {
        return try Lnrpc.ChannelPoint.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ChannelPoint {
        return try Lnrpc.ChannelPoint.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelPoint {
        return try Lnrpc.ChannelPoint.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ChannelPoint {
        return try Lnrpc.ChannelPoint.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelPoint {
        return try Lnrpc.ChannelPoint.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChannelPoint {
        return try Lnrpc.ChannelPoint.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelPoint {
        return try Lnrpc.ChannelPoint.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "fundingTxidBytes": return self.fundingTxidBytes
        case "fundingTxidStr": return self.fundingTxidStr
        case "outputIndex": return self.outputIndex
        default: return nil
        }
    }
}
extension Lnrpc.ChannelPoint.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ChannelPoint
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "fundingTxidBytes": return self.fundingTxidBytes
            case "fundingTxidStr": return self.fundingTxidStr
            case "outputIndex": return self.outputIndex
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "fundingTxidBytes":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.fundingTxidBytes = newSubscriptValue
            case "fundingTxidStr":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.fundingTxidStr = newSubscriptValue
            case "outputIndex":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.outputIndex = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.LightningAddress: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.LightningAddress> {
        var mergedArray = Array<Lnrpc.LightningAddress>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.LightningAddress? {
        return try Lnrpc.LightningAddress.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.LightningAddress {
        return try Lnrpc.LightningAddress.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.LightningAddress {
        return try Lnrpc.LightningAddress.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.LightningAddress {
        return try Lnrpc.LightningAddress.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.LightningAddress {
        return try Lnrpc.LightningAddress.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.LightningAddress {
        return try Lnrpc.LightningAddress.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.LightningAddress {
        return try Lnrpc.LightningAddress.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "pubkey": return self.pubkey
        case "host": return self.host
        default: return nil
        }
    }
}
extension Lnrpc.LightningAddress.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.LightningAddress
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "pubkey": return self.pubkey
            case "host": return self.host
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "pubkey":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.pubkey = newSubscriptValue
            case "host":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.host = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.SendManyRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.SendManyRequest> {
        var mergedArray = Array<Lnrpc.SendManyRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.SendManyRequest? {
        return try Lnrpc.SendManyRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.SendManyRequest {
        return try Lnrpc.SendManyRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendManyRequest {
        return try Lnrpc.SendManyRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.SendManyRequest {
        return try Lnrpc.SendManyRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendManyRequest {
        return try Lnrpc.SendManyRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.SendManyRequest {
        return try Lnrpc.SendManyRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendManyRequest {
        return try Lnrpc.SendManyRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "addrToAmount": return self.addrToAmount
        case "targetConf": return self.targetConf
        case "satPerByte": return self.satPerByte
        default: return nil
        }
    }
}
extension Lnrpc.SendManyRequest.AddrToAmountEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.SendManyRequest.AddrToAmountEntry> {
        var mergedArray = Array<Lnrpc.SendManyRequest.AddrToAmountEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.SendManyRequest.AddrToAmountEntry? {
        return try Lnrpc.SendManyRequest.AddrToAmountEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.SendManyRequest.AddrToAmountEntry {
        return try Lnrpc.SendManyRequest.AddrToAmountEntry.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendManyRequest.AddrToAmountEntry {
        return try Lnrpc.SendManyRequest.AddrToAmountEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.SendManyRequest.AddrToAmountEntry {
        return try Lnrpc.SendManyRequest.AddrToAmountEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendManyRequest.AddrToAmountEntry {
        return try Lnrpc.SendManyRequest.AddrToAmountEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.SendManyRequest.AddrToAmountEntry {
        return try Lnrpc.SendManyRequest.AddrToAmountEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendManyRequest.AddrToAmountEntry {
        return try Lnrpc.SendManyRequest.AddrToAmountEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Lnrpc.SendManyRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.SendManyRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "addrToAmount": return self.addrToAmount
            case "targetConf": return self.targetConf
            case "satPerByte": return self.satPerByte
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "addrToAmount":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,Int64> else {
                    return
                }
                self.addrToAmount = newSubscriptValue
            case "targetConf":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.targetConf = newSubscriptValue
            case "satPerByte":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.satPerByte = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.SendManyRequest.AddrToAmountEntry.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.SendManyRequest.AddrToAmountEntry
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.SendManyResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.SendManyResponse> {
        var mergedArray = Array<Lnrpc.SendManyResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.SendManyResponse? {
        return try Lnrpc.SendManyResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.SendManyResponse {
        return try Lnrpc.SendManyResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendManyResponse {
        return try Lnrpc.SendManyResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.SendManyResponse {
        return try Lnrpc.SendManyResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendManyResponse {
        return try Lnrpc.SendManyResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.SendManyResponse {
        return try Lnrpc.SendManyResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendManyResponse {
        return try Lnrpc.SendManyResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "txid": return self.txid
        default: return nil
        }
    }
}
extension Lnrpc.SendManyResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.SendManyResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "txid": return self.txid
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "txid":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.txid = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.SendCoinsRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.SendCoinsRequest> {
        var mergedArray = Array<Lnrpc.SendCoinsRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.SendCoinsRequest? {
        return try Lnrpc.SendCoinsRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.SendCoinsRequest {
        return try Lnrpc.SendCoinsRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendCoinsRequest {
        return try Lnrpc.SendCoinsRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.SendCoinsRequest {
        return try Lnrpc.SendCoinsRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendCoinsRequest {
        return try Lnrpc.SendCoinsRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.SendCoinsRequest {
        return try Lnrpc.SendCoinsRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendCoinsRequest {
        return try Lnrpc.SendCoinsRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "addr": return self.addr
        case "amount": return self.amount
        case "targetConf": return self.targetConf
        case "satPerByte": return self.satPerByte
        default: return nil
        }
    }
}
extension Lnrpc.SendCoinsRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.SendCoinsRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "addr": return self.addr
            case "amount": return self.amount
            case "targetConf": return self.targetConf
            case "satPerByte": return self.satPerByte
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "addr":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.addr = newSubscriptValue
            case "amount":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.amount = newSubscriptValue
            case "targetConf":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.targetConf = newSubscriptValue
            case "satPerByte":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.satPerByte = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.SendCoinsResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.SendCoinsResponse> {
        var mergedArray = Array<Lnrpc.SendCoinsResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.SendCoinsResponse? {
        return try Lnrpc.SendCoinsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.SendCoinsResponse {
        return try Lnrpc.SendCoinsResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendCoinsResponse {
        return try Lnrpc.SendCoinsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.SendCoinsResponse {
        return try Lnrpc.SendCoinsResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendCoinsResponse {
        return try Lnrpc.SendCoinsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.SendCoinsResponse {
        return try Lnrpc.SendCoinsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SendCoinsResponse {
        return try Lnrpc.SendCoinsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "txid": return self.txid
        default: return nil
        }
    }
}
extension Lnrpc.SendCoinsResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.SendCoinsResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "txid": return self.txid
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "txid":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.txid = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.NewAddressRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.NewAddressRequest> {
        var mergedArray = Array<Lnrpc.NewAddressRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.NewAddressRequest? {
        return try Lnrpc.NewAddressRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.NewAddressRequest {
        return try Lnrpc.NewAddressRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NewAddressRequest {
        return try Lnrpc.NewAddressRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.NewAddressRequest {
        return try Lnrpc.NewAddressRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NewAddressRequest {
        return try Lnrpc.NewAddressRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.NewAddressRequest {
        return try Lnrpc.NewAddressRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NewAddressRequest {
        return try Lnrpc.NewAddressRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "type": return self.type
        default: return nil
        }
    }
}
extension Lnrpc.NewAddressRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.NewAddressRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "type": return self.type
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "type":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.NewAddressRequest.AddressType else {
                    return
                }
                self.type = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.NewWitnessAddressRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.NewWitnessAddressRequest> {
        var mergedArray = Array<Lnrpc.NewWitnessAddressRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.NewWitnessAddressRequest? {
        return try Lnrpc.NewWitnessAddressRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.NewWitnessAddressRequest {
        return try Lnrpc.NewWitnessAddressRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NewWitnessAddressRequest {
        return try Lnrpc.NewWitnessAddressRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.NewWitnessAddressRequest {
        return try Lnrpc.NewWitnessAddressRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NewWitnessAddressRequest {
        return try Lnrpc.NewWitnessAddressRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.NewWitnessAddressRequest {
        return try Lnrpc.NewWitnessAddressRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NewWitnessAddressRequest {
        return try Lnrpc.NewWitnessAddressRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Lnrpc.NewWitnessAddressRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.NewWitnessAddressRequest
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Lnrpc.NewAddressResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.NewAddressResponse> {
        var mergedArray = Array<Lnrpc.NewAddressResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.NewAddressResponse? {
        return try Lnrpc.NewAddressResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.NewAddressResponse {
        return try Lnrpc.NewAddressResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NewAddressResponse {
        return try Lnrpc.NewAddressResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.NewAddressResponse {
        return try Lnrpc.NewAddressResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NewAddressResponse {
        return try Lnrpc.NewAddressResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.NewAddressResponse {
        return try Lnrpc.NewAddressResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NewAddressResponse {
        return try Lnrpc.NewAddressResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "address": return self.address
        default: return nil
        }
    }
}
extension Lnrpc.NewAddressResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.NewAddressResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "address": return self.address
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "address":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.address = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.SignMessageRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.SignMessageRequest> {
        var mergedArray = Array<Lnrpc.SignMessageRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.SignMessageRequest? {
        return try Lnrpc.SignMessageRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.SignMessageRequest {
        return try Lnrpc.SignMessageRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SignMessageRequest {
        return try Lnrpc.SignMessageRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.SignMessageRequest {
        return try Lnrpc.SignMessageRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SignMessageRequest {
        return try Lnrpc.SignMessageRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.SignMessageRequest {
        return try Lnrpc.SignMessageRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SignMessageRequest {
        return try Lnrpc.SignMessageRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "msg": return self.msg
        default: return nil
        }
    }
}
extension Lnrpc.SignMessageRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.SignMessageRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "msg": return self.msg
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "msg":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.msg = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.SignMessageResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.SignMessageResponse> {
        var mergedArray = Array<Lnrpc.SignMessageResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.SignMessageResponse? {
        return try Lnrpc.SignMessageResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.SignMessageResponse {
        return try Lnrpc.SignMessageResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SignMessageResponse {
        return try Lnrpc.SignMessageResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.SignMessageResponse {
        return try Lnrpc.SignMessageResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SignMessageResponse {
        return try Lnrpc.SignMessageResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.SignMessageResponse {
        return try Lnrpc.SignMessageResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.SignMessageResponse {
        return try Lnrpc.SignMessageResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "signature": return self.signature
        default: return nil
        }
    }
}
extension Lnrpc.SignMessageResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.SignMessageResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "signature": return self.signature
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "signature":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.signature = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.VerifyMessageRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.VerifyMessageRequest> {
        var mergedArray = Array<Lnrpc.VerifyMessageRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.VerifyMessageRequest? {
        return try Lnrpc.VerifyMessageRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.VerifyMessageRequest {
        return try Lnrpc.VerifyMessageRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.VerifyMessageRequest {
        return try Lnrpc.VerifyMessageRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.VerifyMessageRequest {
        return try Lnrpc.VerifyMessageRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.VerifyMessageRequest {
        return try Lnrpc.VerifyMessageRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.VerifyMessageRequest {
        return try Lnrpc.VerifyMessageRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.VerifyMessageRequest {
        return try Lnrpc.VerifyMessageRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "msg": return self.msg
        case "signature": return self.signature
        default: return nil
        }
    }
}
extension Lnrpc.VerifyMessageRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.VerifyMessageRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "msg": return self.msg
            case "signature": return self.signature
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "msg":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.msg = newSubscriptValue
            case "signature":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.signature = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.VerifyMessageResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.VerifyMessageResponse> {
        var mergedArray = Array<Lnrpc.VerifyMessageResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.VerifyMessageResponse? {
        return try Lnrpc.VerifyMessageResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.VerifyMessageResponse {
        return try Lnrpc.VerifyMessageResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.VerifyMessageResponse {
        return try Lnrpc.VerifyMessageResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.VerifyMessageResponse {
        return try Lnrpc.VerifyMessageResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.VerifyMessageResponse {
        return try Lnrpc.VerifyMessageResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.VerifyMessageResponse {
        return try Lnrpc.VerifyMessageResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.VerifyMessageResponse {
        return try Lnrpc.VerifyMessageResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "valid": return self.valid
        case "pubkey": return self.pubkey
        default: return nil
        }
    }
}
extension Lnrpc.VerifyMessageResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.VerifyMessageResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "valid": return self.valid
            case "pubkey": return self.pubkey
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "valid":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.valid = newSubscriptValue
            case "pubkey":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.pubkey = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.ConnectPeerRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ConnectPeerRequest> {
        var mergedArray = Array<Lnrpc.ConnectPeerRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ConnectPeerRequest? {
        return try Lnrpc.ConnectPeerRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ConnectPeerRequest {
        return try Lnrpc.ConnectPeerRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ConnectPeerRequest {
        return try Lnrpc.ConnectPeerRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ConnectPeerRequest {
        return try Lnrpc.ConnectPeerRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ConnectPeerRequest {
        return try Lnrpc.ConnectPeerRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ConnectPeerRequest {
        return try Lnrpc.ConnectPeerRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ConnectPeerRequest {
        return try Lnrpc.ConnectPeerRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "addr": return self.addr
        case "perm": return self.perm
        default: return nil
        }
    }
}
extension Lnrpc.ConnectPeerRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ConnectPeerRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "addr": return self.addr
            case "perm": return self.perm
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "addr":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.LightningAddress else {
                    return
                }
                self.addr = newSubscriptValue
            case "perm":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.perm = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.ConnectPeerResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ConnectPeerResponse> {
        var mergedArray = Array<Lnrpc.ConnectPeerResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ConnectPeerResponse? {
        return try Lnrpc.ConnectPeerResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ConnectPeerResponse {
        return try Lnrpc.ConnectPeerResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ConnectPeerResponse {
        return try Lnrpc.ConnectPeerResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ConnectPeerResponse {
        return try Lnrpc.ConnectPeerResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ConnectPeerResponse {
        return try Lnrpc.ConnectPeerResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ConnectPeerResponse {
        return try Lnrpc.ConnectPeerResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ConnectPeerResponse {
        return try Lnrpc.ConnectPeerResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Lnrpc.ConnectPeerResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ConnectPeerResponse
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Lnrpc.DisconnectPeerRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.DisconnectPeerRequest> {
        var mergedArray = Array<Lnrpc.DisconnectPeerRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.DisconnectPeerRequest? {
        return try Lnrpc.DisconnectPeerRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.DisconnectPeerRequest {
        return try Lnrpc.DisconnectPeerRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.DisconnectPeerRequest {
        return try Lnrpc.DisconnectPeerRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.DisconnectPeerRequest {
        return try Lnrpc.DisconnectPeerRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.DisconnectPeerRequest {
        return try Lnrpc.DisconnectPeerRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.DisconnectPeerRequest {
        return try Lnrpc.DisconnectPeerRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.DisconnectPeerRequest {
        return try Lnrpc.DisconnectPeerRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "pubKey": return self.pubKey
        default: return nil
        }
    }
}
extension Lnrpc.DisconnectPeerRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.DisconnectPeerRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "pubKey": return self.pubKey
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "pubKey":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.pubKey = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.DisconnectPeerResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.DisconnectPeerResponse> {
        var mergedArray = Array<Lnrpc.DisconnectPeerResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.DisconnectPeerResponse? {
        return try Lnrpc.DisconnectPeerResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.DisconnectPeerResponse {
        return try Lnrpc.DisconnectPeerResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.DisconnectPeerResponse {
        return try Lnrpc.DisconnectPeerResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.DisconnectPeerResponse {
        return try Lnrpc.DisconnectPeerResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.DisconnectPeerResponse {
        return try Lnrpc.DisconnectPeerResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.DisconnectPeerResponse {
        return try Lnrpc.DisconnectPeerResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.DisconnectPeerResponse {
        return try Lnrpc.DisconnectPeerResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Lnrpc.DisconnectPeerResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.DisconnectPeerResponse
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Lnrpc.Htlc: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.Htlc> {
        var mergedArray = Array<Lnrpc.Htlc>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.Htlc? {
        return try Lnrpc.Htlc.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.Htlc {
        return try Lnrpc.Htlc.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Htlc {
        return try Lnrpc.Htlc.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.Htlc {
        return try Lnrpc.Htlc.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Htlc {
        return try Lnrpc.Htlc.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.Htlc {
        return try Lnrpc.Htlc.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Htlc {
        return try Lnrpc.Htlc.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "incoming": return self.incoming
        case "amount": return self.amount
        case "hashLock": return self.hashLock
        case "expirationHeight": return self.expirationHeight
        default: return nil
        }
    }
}
extension Lnrpc.Htlc.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.Htlc
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "incoming": return self.incoming
            case "amount": return self.amount
            case "hashLock": return self.hashLock
            case "expirationHeight": return self.expirationHeight
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "incoming":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.incoming = newSubscriptValue
            case "amount":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.amount = newSubscriptValue
            case "hashLock":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.hashLock = newSubscriptValue
            case "expirationHeight":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.expirationHeight = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.Channel: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.Channel> {
        var mergedArray = Array<Lnrpc.Channel>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.Channel? {
        return try Lnrpc.Channel.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.Channel {
        return try Lnrpc.Channel.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Channel {
        return try Lnrpc.Channel.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.Channel {
        return try Lnrpc.Channel.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Channel {
        return try Lnrpc.Channel.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.Channel {
        return try Lnrpc.Channel.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Channel {
        return try Lnrpc.Channel.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "active": return self.active
        case "remotePubkey": return self.remotePubkey
        case "channelPoint": return self.channelPoint
        case "chanId": return self.chanId
        case "capacity": return self.capacity
        case "localBalance": return self.localBalance
        case "remoteBalance": return self.remoteBalance
        case "commitFee": return self.commitFee
        case "commitWeight": return self.commitWeight
        case "feePerKw": return self.feePerKw
        case "unsettledBalance": return self.unsettledBalance
        case "totalSatoshisSent": return self.totalSatoshisSent
        case "totalSatoshisReceived": return self.totalSatoshisReceived
        case "numUpdates": return self.numUpdates
        case "pendingHtlcs": return self.pendingHtlcs
        case "csvDelay": return self.csvDelay
        case "private": return self.private
        default: return nil
        }
    }
}
extension Lnrpc.Channel.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.Channel
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "active": return self.active
            case "remotePubkey": return self.remotePubkey
            case "channelPoint": return self.channelPoint
            case "chanId": return self.chanId
            case "capacity": return self.capacity
            case "localBalance": return self.localBalance
            case "remoteBalance": return self.remoteBalance
            case "commitFee": return self.commitFee
            case "commitWeight": return self.commitWeight
            case "feePerKw": return self.feePerKw
            case "unsettledBalance": return self.unsettledBalance
            case "totalSatoshisSent": return self.totalSatoshisSent
            case "totalSatoshisReceived": return self.totalSatoshisReceived
            case "numUpdates": return self.numUpdates
            case "pendingHtlcs": return self.pendingHtlcs
            case "csvDelay": return self.csvDelay
            case "private": return self.private
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "active":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.active = newSubscriptValue
            case "remotePubkey":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.remotePubkey = newSubscriptValue
            case "channelPoint":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.channelPoint = newSubscriptValue
            case "chanId":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.chanId = newSubscriptValue
            case "capacity":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.capacity = newSubscriptValue
            case "localBalance":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.localBalance = newSubscriptValue
            case "remoteBalance":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.remoteBalance = newSubscriptValue
            case "commitFee":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.commitFee = newSubscriptValue
            case "commitWeight":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.commitWeight = newSubscriptValue
            case "feePerKw":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.feePerKw = newSubscriptValue
            case "unsettledBalance":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.unsettledBalance = newSubscriptValue
            case "totalSatoshisSent":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.totalSatoshisSent = newSubscriptValue
            case "totalSatoshisReceived":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.totalSatoshisReceived = newSubscriptValue
            case "numUpdates":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.numUpdates = newSubscriptValue
            case "pendingHtlcs":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.Htlc> else {
                    return
                }
                self.pendingHtlcs = newSubscriptValue
            case "csvDelay":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.csvDelay = newSubscriptValue
            case "private":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.private = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.ListChannelsRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ListChannelsRequest> {
        var mergedArray = Array<Lnrpc.ListChannelsRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ListChannelsRequest? {
        return try Lnrpc.ListChannelsRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ListChannelsRequest {
        return try Lnrpc.ListChannelsRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListChannelsRequest {
        return try Lnrpc.ListChannelsRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ListChannelsRequest {
        return try Lnrpc.ListChannelsRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListChannelsRequest {
        return try Lnrpc.ListChannelsRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ListChannelsRequest {
        return try Lnrpc.ListChannelsRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListChannelsRequest {
        return try Lnrpc.ListChannelsRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "activeOnly": return self.activeOnly
        case "inactiveOnly": return self.inactiveOnly
        case "publicOnly": return self.publicOnly
        case "privateOnly": return self.privateOnly
        default: return nil
        }
    }
}
extension Lnrpc.ListChannelsRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ListChannelsRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "activeOnly": return self.activeOnly
            case "inactiveOnly": return self.inactiveOnly
            case "publicOnly": return self.publicOnly
            case "privateOnly": return self.privateOnly
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "activeOnly":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.activeOnly = newSubscriptValue
            case "inactiveOnly":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.inactiveOnly = newSubscriptValue
            case "publicOnly":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.publicOnly = newSubscriptValue
            case "privateOnly":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.privateOnly = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.ListChannelsResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ListChannelsResponse> {
        var mergedArray = Array<Lnrpc.ListChannelsResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ListChannelsResponse? {
        return try Lnrpc.ListChannelsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ListChannelsResponse {
        return try Lnrpc.ListChannelsResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListChannelsResponse {
        return try Lnrpc.ListChannelsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ListChannelsResponse {
        return try Lnrpc.ListChannelsResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListChannelsResponse {
        return try Lnrpc.ListChannelsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ListChannelsResponse {
        return try Lnrpc.ListChannelsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListChannelsResponse {
        return try Lnrpc.ListChannelsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "channels": return self.channels
        default: return nil
        }
    }
}
extension Lnrpc.ListChannelsResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ListChannelsResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "channels": return self.channels
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "channels":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.Channel> else {
                    return
                }
                self.channels = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.ChannelCloseSummary: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ChannelCloseSummary> {
        var mergedArray = Array<Lnrpc.ChannelCloseSummary>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ChannelCloseSummary? {
        return try Lnrpc.ChannelCloseSummary.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ChannelCloseSummary {
        return try Lnrpc.ChannelCloseSummary.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelCloseSummary {
        return try Lnrpc.ChannelCloseSummary.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ChannelCloseSummary {
        return try Lnrpc.ChannelCloseSummary.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelCloseSummary {
        return try Lnrpc.ChannelCloseSummary.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChannelCloseSummary {
        return try Lnrpc.ChannelCloseSummary.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelCloseSummary {
        return try Lnrpc.ChannelCloseSummary.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "channelPoint": return self.channelPoint
        case "chanId": return self.chanId
        case "chainHash": return self.chainHash
        case "closingTxHash": return self.closingTxHash
        case "remotePubkey": return self.remotePubkey
        case "capacity": return self.capacity
        case "closeHeight": return self.closeHeight
        case "settledBalance": return self.settledBalance
        case "timeLockedBalance": return self.timeLockedBalance
        case "closeType": return self.closeType
        default: return nil
        }
    }
}
extension Lnrpc.ChannelCloseSummary.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ChannelCloseSummary
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "channelPoint": return self.channelPoint
            case "chanId": return self.chanId
            case "chainHash": return self.chainHash
            case "closingTxHash": return self.closingTxHash
            case "remotePubkey": return self.remotePubkey
            case "capacity": return self.capacity
            case "closeHeight": return self.closeHeight
            case "settledBalance": return self.settledBalance
            case "timeLockedBalance": return self.timeLockedBalance
            case "closeType": return self.closeType
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "channelPoint":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.channelPoint = newSubscriptValue
            case "chanId":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.chanId = newSubscriptValue
            case "chainHash":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.chainHash = newSubscriptValue
            case "closingTxHash":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.closingTxHash = newSubscriptValue
            case "remotePubkey":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.remotePubkey = newSubscriptValue
            case "capacity":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.capacity = newSubscriptValue
            case "closeHeight":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.closeHeight = newSubscriptValue
            case "settledBalance":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.settledBalance = newSubscriptValue
            case "timeLockedBalance":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.timeLockedBalance = newSubscriptValue
            case "closeType":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.ChannelCloseSummary.ClosureType else {
                    return
                }
                self.closeType = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.ClosedChannelsRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ClosedChannelsRequest> {
        var mergedArray = Array<Lnrpc.ClosedChannelsRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ClosedChannelsRequest? {
        return try Lnrpc.ClosedChannelsRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ClosedChannelsRequest {
        return try Lnrpc.ClosedChannelsRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ClosedChannelsRequest {
        return try Lnrpc.ClosedChannelsRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ClosedChannelsRequest {
        return try Lnrpc.ClosedChannelsRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ClosedChannelsRequest {
        return try Lnrpc.ClosedChannelsRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ClosedChannelsRequest {
        return try Lnrpc.ClosedChannelsRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ClosedChannelsRequest {
        return try Lnrpc.ClosedChannelsRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "cooperative": return self.cooperative
        case "localForce": return self.localForce
        case "remoteForce": return self.remoteForce
        case "breach": return self.breach
        case "fundingCanceled": return self.fundingCanceled
        default: return nil
        }
    }
}
extension Lnrpc.ClosedChannelsRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ClosedChannelsRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "cooperative": return self.cooperative
            case "localForce": return self.localForce
            case "remoteForce": return self.remoteForce
            case "breach": return self.breach
            case "fundingCanceled": return self.fundingCanceled
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "cooperative":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.cooperative = newSubscriptValue
            case "localForce":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.localForce = newSubscriptValue
            case "remoteForce":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.remoteForce = newSubscriptValue
            case "breach":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.breach = newSubscriptValue
            case "fundingCanceled":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.fundingCanceled = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.ClosedChannelsResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ClosedChannelsResponse> {
        var mergedArray = Array<Lnrpc.ClosedChannelsResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ClosedChannelsResponse? {
        return try Lnrpc.ClosedChannelsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ClosedChannelsResponse {
        return try Lnrpc.ClosedChannelsResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ClosedChannelsResponse {
        return try Lnrpc.ClosedChannelsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ClosedChannelsResponse {
        return try Lnrpc.ClosedChannelsResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ClosedChannelsResponse {
        return try Lnrpc.ClosedChannelsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ClosedChannelsResponse {
        return try Lnrpc.ClosedChannelsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ClosedChannelsResponse {
        return try Lnrpc.ClosedChannelsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "channels": return self.channels
        default: return nil
        }
    }
}
extension Lnrpc.ClosedChannelsResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ClosedChannelsResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "channels": return self.channels
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "channels":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.ChannelCloseSummary> else {
                    return
                }
                self.channels = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.Peer: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.Peer> {
        var mergedArray = Array<Lnrpc.Peer>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.Peer? {
        return try Lnrpc.Peer.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.Peer {
        return try Lnrpc.Peer.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Peer {
        return try Lnrpc.Peer.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.Peer {
        return try Lnrpc.Peer.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Peer {
        return try Lnrpc.Peer.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.Peer {
        return try Lnrpc.Peer.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Peer {
        return try Lnrpc.Peer.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "pubKey": return self.pubKey
        case "address": return self.address
        case "bytesSent": return self.bytesSent
        case "bytesRecv": return self.bytesRecv
        case "satSent": return self.satSent
        case "satRecv": return self.satRecv
        case "inbound": return self.inbound
        case "pingTime": return self.pingTime
        default: return nil
        }
    }
}
extension Lnrpc.Peer.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.Peer
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "pubKey": return self.pubKey
            case "address": return self.address
            case "bytesSent": return self.bytesSent
            case "bytesRecv": return self.bytesRecv
            case "satSent": return self.satSent
            case "satRecv": return self.satRecv
            case "inbound": return self.inbound
            case "pingTime": return self.pingTime
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "pubKey":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.pubKey = newSubscriptValue
            case "address":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.address = newSubscriptValue
            case "bytesSent":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.bytesSent = newSubscriptValue
            case "bytesRecv":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.bytesRecv = newSubscriptValue
            case "satSent":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.satSent = newSubscriptValue
            case "satRecv":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.satRecv = newSubscriptValue
            case "inbound":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.inbound = newSubscriptValue
            case "pingTime":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.pingTime = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.ListPeersRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ListPeersRequest> {
        var mergedArray = Array<Lnrpc.ListPeersRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ListPeersRequest? {
        return try Lnrpc.ListPeersRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ListPeersRequest {
        return try Lnrpc.ListPeersRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListPeersRequest {
        return try Lnrpc.ListPeersRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ListPeersRequest {
        return try Lnrpc.ListPeersRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListPeersRequest {
        return try Lnrpc.ListPeersRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ListPeersRequest {
        return try Lnrpc.ListPeersRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListPeersRequest {
        return try Lnrpc.ListPeersRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Lnrpc.ListPeersRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ListPeersRequest
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Lnrpc.ListPeersResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ListPeersResponse> {
        var mergedArray = Array<Lnrpc.ListPeersResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ListPeersResponse? {
        return try Lnrpc.ListPeersResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ListPeersResponse {
        return try Lnrpc.ListPeersResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListPeersResponse {
        return try Lnrpc.ListPeersResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ListPeersResponse {
        return try Lnrpc.ListPeersResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListPeersResponse {
        return try Lnrpc.ListPeersResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ListPeersResponse {
        return try Lnrpc.ListPeersResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListPeersResponse {
        return try Lnrpc.ListPeersResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "peers": return self.peers
        default: return nil
        }
    }
}
extension Lnrpc.ListPeersResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ListPeersResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "peers": return self.peers
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "peers":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.Peer> else {
                    return
                }
                self.peers = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.GetInfoRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.GetInfoRequest> {
        var mergedArray = Array<Lnrpc.GetInfoRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.GetInfoRequest? {
        return try Lnrpc.GetInfoRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.GetInfoRequest {
        return try Lnrpc.GetInfoRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GetInfoRequest {
        return try Lnrpc.GetInfoRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.GetInfoRequest {
        return try Lnrpc.GetInfoRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GetInfoRequest {
        return try Lnrpc.GetInfoRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.GetInfoRequest {
        return try Lnrpc.GetInfoRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GetInfoRequest {
        return try Lnrpc.GetInfoRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Lnrpc.GetInfoRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.GetInfoRequest
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Lnrpc.GetInfoResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.GetInfoResponse> {
        var mergedArray = Array<Lnrpc.GetInfoResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.GetInfoResponse? {
        return try Lnrpc.GetInfoResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.GetInfoResponse {
        return try Lnrpc.GetInfoResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GetInfoResponse {
        return try Lnrpc.GetInfoResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.GetInfoResponse {
        return try Lnrpc.GetInfoResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GetInfoResponse {
        return try Lnrpc.GetInfoResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.GetInfoResponse {
        return try Lnrpc.GetInfoResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GetInfoResponse {
        return try Lnrpc.GetInfoResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "identityPubkey": return self.identityPubkey
        case "alias": return self.alias
        case "numPendingChannels": return self.numPendingChannels
        case "numActiveChannels": return self.numActiveChannels
        case "numPeers": return self.numPeers
        case "blockHeight": return self.blockHeight
        case "blockHash": return self.blockHash
        case "syncedToChain": return self.syncedToChain
        case "testnet": return self.testnet
        case "chains": return self.chains
        case "uris": return self.uris
        case "bestHeaderTimestamp": return self.bestHeaderTimestamp
        case "version": return self.version
        default: return nil
        }
    }
}
extension Lnrpc.GetInfoResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.GetInfoResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "identityPubkey": return self.identityPubkey
            case "alias": return self.alias
            case "numPendingChannels": return self.numPendingChannels
            case "numActiveChannels": return self.numActiveChannels
            case "numPeers": return self.numPeers
            case "blockHeight": return self.blockHeight
            case "blockHash": return self.blockHash
            case "syncedToChain": return self.syncedToChain
            case "testnet": return self.testnet
            case "chains": return self.chains
            case "uris": return self.uris
            case "bestHeaderTimestamp": return self.bestHeaderTimestamp
            case "version": return self.version
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "identityPubkey":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.identityPubkey = newSubscriptValue
            case "alias":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.alias = newSubscriptValue
            case "numPendingChannels":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.numPendingChannels = newSubscriptValue
            case "numActiveChannels":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.numActiveChannels = newSubscriptValue
            case "numPeers":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.numPeers = newSubscriptValue
            case "blockHeight":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.blockHeight = newSubscriptValue
            case "blockHash":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.blockHash = newSubscriptValue
            case "syncedToChain":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.syncedToChain = newSubscriptValue
            case "testnet":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.testnet = newSubscriptValue
            case "chains":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.chains = newSubscriptValue
            case "uris":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.uris = newSubscriptValue
            case "bestHeaderTimestamp":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.bestHeaderTimestamp = newSubscriptValue
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.version = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.ConfirmationUpdate: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ConfirmationUpdate> {
        var mergedArray = Array<Lnrpc.ConfirmationUpdate>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ConfirmationUpdate? {
        return try Lnrpc.ConfirmationUpdate.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ConfirmationUpdate {
        return try Lnrpc.ConfirmationUpdate.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ConfirmationUpdate {
        return try Lnrpc.ConfirmationUpdate.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ConfirmationUpdate {
        return try Lnrpc.ConfirmationUpdate.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ConfirmationUpdate {
        return try Lnrpc.ConfirmationUpdate.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ConfirmationUpdate {
        return try Lnrpc.ConfirmationUpdate.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ConfirmationUpdate {
        return try Lnrpc.ConfirmationUpdate.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "blockSha": return self.blockSha
        case "blockHeight": return self.blockHeight
        case "numConfsLeft": return self.numConfsLeft
        default: return nil
        }
    }
}
extension Lnrpc.ConfirmationUpdate.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ConfirmationUpdate
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "blockSha": return self.blockSha
            case "blockHeight": return self.blockHeight
            case "numConfsLeft": return self.numConfsLeft
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "blockSha":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.blockSha = newSubscriptValue
            case "blockHeight":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.blockHeight = newSubscriptValue
            case "numConfsLeft":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.numConfsLeft = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.ChannelOpenUpdate: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ChannelOpenUpdate> {
        var mergedArray = Array<Lnrpc.ChannelOpenUpdate>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ChannelOpenUpdate? {
        return try Lnrpc.ChannelOpenUpdate.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ChannelOpenUpdate {
        return try Lnrpc.ChannelOpenUpdate.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelOpenUpdate {
        return try Lnrpc.ChannelOpenUpdate.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ChannelOpenUpdate {
        return try Lnrpc.ChannelOpenUpdate.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelOpenUpdate {
        return try Lnrpc.ChannelOpenUpdate.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChannelOpenUpdate {
        return try Lnrpc.ChannelOpenUpdate.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelOpenUpdate {
        return try Lnrpc.ChannelOpenUpdate.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "channelPoint": return self.channelPoint
        default: return nil
        }
    }
}
extension Lnrpc.ChannelOpenUpdate.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ChannelOpenUpdate
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "channelPoint": return self.channelPoint
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "channelPoint":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.ChannelPoint else {
                    return
                }
                self.channelPoint = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.ChannelCloseUpdate: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ChannelCloseUpdate> {
        var mergedArray = Array<Lnrpc.ChannelCloseUpdate>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ChannelCloseUpdate? {
        return try Lnrpc.ChannelCloseUpdate.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ChannelCloseUpdate {
        return try Lnrpc.ChannelCloseUpdate.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelCloseUpdate {
        return try Lnrpc.ChannelCloseUpdate.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ChannelCloseUpdate {
        return try Lnrpc.ChannelCloseUpdate.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelCloseUpdate {
        return try Lnrpc.ChannelCloseUpdate.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChannelCloseUpdate {
        return try Lnrpc.ChannelCloseUpdate.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelCloseUpdate {
        return try Lnrpc.ChannelCloseUpdate.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "closingTxid": return self.closingTxid
        case "success": return self.success
        default: return nil
        }
    }
}
extension Lnrpc.ChannelCloseUpdate.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ChannelCloseUpdate
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "closingTxid": return self.closingTxid
            case "success": return self.success
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "closingTxid":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.closingTxid = newSubscriptValue
            case "success":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.success = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.CloseChannelRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.CloseChannelRequest> {
        var mergedArray = Array<Lnrpc.CloseChannelRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.CloseChannelRequest? {
        return try Lnrpc.CloseChannelRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.CloseChannelRequest {
        return try Lnrpc.CloseChannelRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.CloseChannelRequest {
        return try Lnrpc.CloseChannelRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.CloseChannelRequest {
        return try Lnrpc.CloseChannelRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.CloseChannelRequest {
        return try Lnrpc.CloseChannelRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.CloseChannelRequest {
        return try Lnrpc.CloseChannelRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.CloseChannelRequest {
        return try Lnrpc.CloseChannelRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "channelPoint": return self.channelPoint
        case "force": return self.force
        case "targetConf": return self.targetConf
        case "satPerByte": return self.satPerByte
        default: return nil
        }
    }
}
extension Lnrpc.CloseChannelRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.CloseChannelRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "channelPoint": return self.channelPoint
            case "force": return self.force
            case "targetConf": return self.targetConf
            case "satPerByte": return self.satPerByte
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "channelPoint":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.ChannelPoint else {
                    return
                }
                self.channelPoint = newSubscriptValue
            case "force":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.force = newSubscriptValue
            case "targetConf":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.targetConf = newSubscriptValue
            case "satPerByte":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.satPerByte = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.CloseStatusUpdate: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.CloseStatusUpdate> {
        var mergedArray = Array<Lnrpc.CloseStatusUpdate>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.CloseStatusUpdate? {
        return try Lnrpc.CloseStatusUpdate.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.CloseStatusUpdate {
        return try Lnrpc.CloseStatusUpdate.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.CloseStatusUpdate {
        return try Lnrpc.CloseStatusUpdate.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.CloseStatusUpdate {
        return try Lnrpc.CloseStatusUpdate.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.CloseStatusUpdate {
        return try Lnrpc.CloseStatusUpdate.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.CloseStatusUpdate {
        return try Lnrpc.CloseStatusUpdate.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.CloseStatusUpdate {
        return try Lnrpc.CloseStatusUpdate.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "closePending": return self.closePending
        case "confirmation": return self.confirmation
        case "chanClose": return self.chanClose
        default: return nil
        }
    }
}
extension Lnrpc.CloseStatusUpdate.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.CloseStatusUpdate
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "closePending": return self.closePending
            case "confirmation": return self.confirmation
            case "chanClose": return self.chanClose
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "closePending":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.PendingUpdate else {
                    return
                }
                self.closePending = newSubscriptValue
            case "confirmation":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.ConfirmationUpdate else {
                    return
                }
                self.confirmation = newSubscriptValue
            case "chanClose":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.ChannelCloseUpdate else {
                    return
                }
                self.chanClose = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.PendingUpdate: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.PendingUpdate> {
        var mergedArray = Array<Lnrpc.PendingUpdate>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.PendingUpdate? {
        return try Lnrpc.PendingUpdate.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.PendingUpdate {
        return try Lnrpc.PendingUpdate.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingUpdate {
        return try Lnrpc.PendingUpdate.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.PendingUpdate {
        return try Lnrpc.PendingUpdate.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingUpdate {
        return try Lnrpc.PendingUpdate.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PendingUpdate {
        return try Lnrpc.PendingUpdate.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingUpdate {
        return try Lnrpc.PendingUpdate.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "txid": return self.txid
        case "outputIndex": return self.outputIndex
        default: return nil
        }
    }
}
extension Lnrpc.PendingUpdate.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.PendingUpdate
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "txid": return self.txid
            case "outputIndex": return self.outputIndex
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "txid":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.txid = newSubscriptValue
            case "outputIndex":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.outputIndex = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.OpenChannelRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.OpenChannelRequest> {
        var mergedArray = Array<Lnrpc.OpenChannelRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.OpenChannelRequest? {
        return try Lnrpc.OpenChannelRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.OpenChannelRequest {
        return try Lnrpc.OpenChannelRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.OpenChannelRequest {
        return try Lnrpc.OpenChannelRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.OpenChannelRequest {
        return try Lnrpc.OpenChannelRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.OpenChannelRequest {
        return try Lnrpc.OpenChannelRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.OpenChannelRequest {
        return try Lnrpc.OpenChannelRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.OpenChannelRequest {
        return try Lnrpc.OpenChannelRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "nodePubkey": return self.nodePubkey
        case "nodePubkeyString": return self.nodePubkeyString
        case "localFundingAmount": return self.localFundingAmount
        case "pushSat": return self.pushSat
        case "targetConf": return self.targetConf
        case "satPerByte": return self.satPerByte
        case "private": return self.private
        case "minHtlcMsat": return self.minHtlcMsat
        case "remoteCsvDelay": return self.remoteCsvDelay
        case "minConfs": return self.minConfs
        default: return nil
        }
    }
}
extension Lnrpc.OpenChannelRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.OpenChannelRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "nodePubkey": return self.nodePubkey
            case "nodePubkeyString": return self.nodePubkeyString
            case "localFundingAmount": return self.localFundingAmount
            case "pushSat": return self.pushSat
            case "targetConf": return self.targetConf
            case "satPerByte": return self.satPerByte
            case "private": return self.private
            case "minHtlcMsat": return self.minHtlcMsat
            case "remoteCsvDelay": return self.remoteCsvDelay
            case "minConfs": return self.minConfs
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "nodePubkey":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.nodePubkey = newSubscriptValue
            case "nodePubkeyString":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.nodePubkeyString = newSubscriptValue
            case "localFundingAmount":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.localFundingAmount = newSubscriptValue
            case "pushSat":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.pushSat = newSubscriptValue
            case "targetConf":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.targetConf = newSubscriptValue
            case "satPerByte":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.satPerByte = newSubscriptValue
            case "private":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.private = newSubscriptValue
            case "minHtlcMsat":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.minHtlcMsat = newSubscriptValue
            case "remoteCsvDelay":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.remoteCsvDelay = newSubscriptValue
            case "minConfs":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.minConfs = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.OpenStatusUpdate: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.OpenStatusUpdate> {
        var mergedArray = Array<Lnrpc.OpenStatusUpdate>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.OpenStatusUpdate? {
        return try Lnrpc.OpenStatusUpdate.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.OpenStatusUpdate {
        return try Lnrpc.OpenStatusUpdate.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.OpenStatusUpdate {
        return try Lnrpc.OpenStatusUpdate.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.OpenStatusUpdate {
        return try Lnrpc.OpenStatusUpdate.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.OpenStatusUpdate {
        return try Lnrpc.OpenStatusUpdate.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.OpenStatusUpdate {
        return try Lnrpc.OpenStatusUpdate.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.OpenStatusUpdate {
        return try Lnrpc.OpenStatusUpdate.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "chanPending": return self.chanPending
        case "confirmation": return self.confirmation
        case "chanOpen": return self.chanOpen
        default: return nil
        }
    }
}
extension Lnrpc.OpenStatusUpdate.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.OpenStatusUpdate
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "chanPending": return self.chanPending
            case "confirmation": return self.confirmation
            case "chanOpen": return self.chanOpen
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "chanPending":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.PendingUpdate else {
                    return
                }
                self.chanPending = newSubscriptValue
            case "confirmation":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.ConfirmationUpdate else {
                    return
                }
                self.confirmation = newSubscriptValue
            case "chanOpen":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.ChannelOpenUpdate else {
                    return
                }
                self.chanOpen = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.PendingHtlc: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.PendingHtlc> {
        var mergedArray = Array<Lnrpc.PendingHtlc>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.PendingHtlc? {
        return try Lnrpc.PendingHtlc.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.PendingHtlc {
        return try Lnrpc.PendingHtlc.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingHtlc {
        return try Lnrpc.PendingHtlc.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.PendingHtlc {
        return try Lnrpc.PendingHtlc.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingHtlc {
        return try Lnrpc.PendingHtlc.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PendingHtlc {
        return try Lnrpc.PendingHtlc.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingHtlc {
        return try Lnrpc.PendingHtlc.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "incoming": return self.incoming
        case "amount": return self.amount
        case "outpoint": return self.outpoint
        case "maturityHeight": return self.maturityHeight
        case "blocksTilMaturity": return self.blocksTilMaturity
        case "stage": return self.stage
        default: return nil
        }
    }
}
extension Lnrpc.PendingHtlc.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.PendingHtlc
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "incoming": return self.incoming
            case "amount": return self.amount
            case "outpoint": return self.outpoint
            case "maturityHeight": return self.maturityHeight
            case "blocksTilMaturity": return self.blocksTilMaturity
            case "stage": return self.stage
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "incoming":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.incoming = newSubscriptValue
            case "amount":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.amount = newSubscriptValue
            case "outpoint":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.outpoint = newSubscriptValue
            case "maturityHeight":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.maturityHeight = newSubscriptValue
            case "blocksTilMaturity":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.blocksTilMaturity = newSubscriptValue
            case "stage":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.stage = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.PendingChannelsRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.PendingChannelsRequest> {
        var mergedArray = Array<Lnrpc.PendingChannelsRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.PendingChannelsRequest? {
        return try Lnrpc.PendingChannelsRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.PendingChannelsRequest {
        return try Lnrpc.PendingChannelsRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsRequest {
        return try Lnrpc.PendingChannelsRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.PendingChannelsRequest {
        return try Lnrpc.PendingChannelsRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsRequest {
        return try Lnrpc.PendingChannelsRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PendingChannelsRequest {
        return try Lnrpc.PendingChannelsRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsRequest {
        return try Lnrpc.PendingChannelsRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Lnrpc.PendingChannelsRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.PendingChannelsRequest
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Lnrpc.PendingChannelsResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.PendingChannelsResponse> {
        var mergedArray = Array<Lnrpc.PendingChannelsResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.PendingChannelsResponse? {
        return try Lnrpc.PendingChannelsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.PendingChannelsResponse {
        return try Lnrpc.PendingChannelsResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsResponse {
        return try Lnrpc.PendingChannelsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.PendingChannelsResponse {
        return try Lnrpc.PendingChannelsResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsResponse {
        return try Lnrpc.PendingChannelsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PendingChannelsResponse {
        return try Lnrpc.PendingChannelsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsResponse {
        return try Lnrpc.PendingChannelsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "totalLimboBalance": return self.totalLimboBalance
        case "pendingOpenChannels": return self.pendingOpenChannels
        case "pendingClosingChannels": return self.pendingClosingChannels
        case "pendingForceClosingChannels": return self.pendingForceClosingChannels
        case "waitingCloseChannels": return self.waitingCloseChannels
        default: return nil
        }
    }
}
extension Lnrpc.PendingChannelsResponse.PendingChannel: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.PendingChannelsResponse.PendingChannel> {
        var mergedArray = Array<Lnrpc.PendingChannelsResponse.PendingChannel>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.PendingChannelsResponse.PendingChannel? {
        return try Lnrpc.PendingChannelsResponse.PendingChannel.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.PendingChannelsResponse.PendingChannel {
        return try Lnrpc.PendingChannelsResponse.PendingChannel.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsResponse.PendingChannel {
        return try Lnrpc.PendingChannelsResponse.PendingChannel.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.PendingChannelsResponse.PendingChannel {
        return try Lnrpc.PendingChannelsResponse.PendingChannel.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsResponse.PendingChannel {
        return try Lnrpc.PendingChannelsResponse.PendingChannel.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PendingChannelsResponse.PendingChannel {
        return try Lnrpc.PendingChannelsResponse.PendingChannel.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsResponse.PendingChannel {
        return try Lnrpc.PendingChannelsResponse.PendingChannel.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "remoteNodePub": return self.remoteNodePub
        case "channelPoint": return self.channelPoint
        case "capacity": return self.capacity
        case "localBalance": return self.localBalance
        case "remoteBalance": return self.remoteBalance
        default: return nil
        }
    }
}
extension Lnrpc.PendingChannelsResponse.PendingOpenChannel: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.PendingChannelsResponse.PendingOpenChannel> {
        var mergedArray = Array<Lnrpc.PendingChannelsResponse.PendingOpenChannel>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.PendingChannelsResponse.PendingOpenChannel? {
        return try Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.PendingChannelsResponse.PendingOpenChannel {
        return try Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsResponse.PendingOpenChannel {
        return try Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.PendingChannelsResponse.PendingOpenChannel {
        return try Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsResponse.PendingOpenChannel {
        return try Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PendingChannelsResponse.PendingOpenChannel {
        return try Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsResponse.PendingOpenChannel {
        return try Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "channel": return self.channel
        case "confirmationHeight": return self.confirmationHeight
        case "commitFee": return self.commitFee
        case "commitWeight": return self.commitWeight
        case "feePerKw": return self.feePerKw
        default: return nil
        }
    }
}
extension Lnrpc.PendingChannelsResponse.WaitingCloseChannel: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.PendingChannelsResponse.WaitingCloseChannel> {
        var mergedArray = Array<Lnrpc.PendingChannelsResponse.WaitingCloseChannel>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel? {
        return try Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel {
        return try Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel {
        return try Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel {
        return try Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel {
        return try Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel {
        return try Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsResponse.WaitingCloseChannel {
        return try Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "channel": return self.channel
        case "limboBalance": return self.limboBalance
        default: return nil
        }
    }
}
extension Lnrpc.PendingChannelsResponse.ClosedChannel: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.PendingChannelsResponse.ClosedChannel> {
        var mergedArray = Array<Lnrpc.PendingChannelsResponse.ClosedChannel>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.PendingChannelsResponse.ClosedChannel? {
        return try Lnrpc.PendingChannelsResponse.ClosedChannel.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.PendingChannelsResponse.ClosedChannel {
        return try Lnrpc.PendingChannelsResponse.ClosedChannel.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsResponse.ClosedChannel {
        return try Lnrpc.PendingChannelsResponse.ClosedChannel.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.PendingChannelsResponse.ClosedChannel {
        return try Lnrpc.PendingChannelsResponse.ClosedChannel.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsResponse.ClosedChannel {
        return try Lnrpc.PendingChannelsResponse.ClosedChannel.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PendingChannelsResponse.ClosedChannel {
        return try Lnrpc.PendingChannelsResponse.ClosedChannel.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsResponse.ClosedChannel {
        return try Lnrpc.PendingChannelsResponse.ClosedChannel.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "channel": return self.channel
        case "closingTxid": return self.closingTxid
        default: return nil
        }
    }
}
extension Lnrpc.PendingChannelsResponse.ForceClosedChannel: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.PendingChannelsResponse.ForceClosedChannel> {
        var mergedArray = Array<Lnrpc.PendingChannelsResponse.ForceClosedChannel>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.PendingChannelsResponse.ForceClosedChannel? {
        return try Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.PendingChannelsResponse.ForceClosedChannel {
        return try Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsResponse.ForceClosedChannel {
        return try Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.PendingChannelsResponse.ForceClosedChannel {
        return try Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsResponse.ForceClosedChannel {
        return try Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PendingChannelsResponse.ForceClosedChannel {
        return try Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PendingChannelsResponse.ForceClosedChannel {
        return try Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "channel": return self.channel
        case "closingTxid": return self.closingTxid
        case "limboBalance": return self.limboBalance
        case "maturityHeight": return self.maturityHeight
        case "blocksTilMaturity": return self.blocksTilMaturity
        case "recoveredBalance": return self.recoveredBalance
        case "pendingHtlcs": return self.pendingHtlcs
        default: return nil
        }
    }
}
extension Lnrpc.PendingChannelsResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.PendingChannelsResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "totalLimboBalance": return self.totalLimboBalance
            case "pendingOpenChannels": return self.pendingOpenChannels
            case "pendingClosingChannels": return self.pendingClosingChannels
            case "pendingForceClosingChannels": return self.pendingForceClosingChannels
            case "waitingCloseChannels": return self.waitingCloseChannels
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "totalLimboBalance":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.totalLimboBalance = newSubscriptValue
            case "pendingOpenChannels":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.PendingChannelsResponse.PendingOpenChannel> else {
                    return
                }
                self.pendingOpenChannels = newSubscriptValue
            case "pendingClosingChannels":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.PendingChannelsResponse.ClosedChannel> else {
                    return
                }
                self.pendingClosingChannels = newSubscriptValue
            case "pendingForceClosingChannels":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.PendingChannelsResponse.ForceClosedChannel> else {
                    return
                }
                self.pendingForceClosingChannels = newSubscriptValue
            case "waitingCloseChannels":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.PendingChannelsResponse.WaitingCloseChannel> else {
                    return
                }
                self.waitingCloseChannels = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.PendingChannelsResponse.PendingChannel.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.PendingChannelsResponse.PendingChannel
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "remoteNodePub": return self.remoteNodePub
            case "channelPoint": return self.channelPoint
            case "capacity": return self.capacity
            case "localBalance": return self.localBalance
            case "remoteBalance": return self.remoteBalance
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "remoteNodePub":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.remoteNodePub = newSubscriptValue
            case "channelPoint":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.channelPoint = newSubscriptValue
            case "capacity":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.capacity = newSubscriptValue
            case "localBalance":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.localBalance = newSubscriptValue
            case "remoteBalance":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.remoteBalance = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.PendingChannelsResponse.PendingOpenChannel.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.PendingChannelsResponse.PendingOpenChannel
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "channel": return self.channel
            case "confirmationHeight": return self.confirmationHeight
            case "commitFee": return self.commitFee
            case "commitWeight": return self.commitWeight
            case "feePerKw": return self.feePerKw
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "channel":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.PendingChannelsResponse.PendingChannel else {
                    return
                }
                self.channel = newSubscriptValue
            case "confirmationHeight":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.confirmationHeight = newSubscriptValue
            case "commitFee":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.commitFee = newSubscriptValue
            case "commitWeight":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.commitWeight = newSubscriptValue
            case "feePerKw":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.feePerKw = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.PendingChannelsResponse.WaitingCloseChannel.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.PendingChannelsResponse.WaitingCloseChannel
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "channel": return self.channel
            case "limboBalance": return self.limboBalance
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "channel":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.PendingChannelsResponse.PendingChannel else {
                    return
                }
                self.channel = newSubscriptValue
            case "limboBalance":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.limboBalance = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.PendingChannelsResponse.ClosedChannel.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.PendingChannelsResponse.ClosedChannel
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "channel": return self.channel
            case "closingTxid": return self.closingTxid
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "channel":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.PendingChannelsResponse.PendingChannel else {
                    return
                }
                self.channel = newSubscriptValue
            case "closingTxid":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.closingTxid = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.PendingChannelsResponse.ForceClosedChannel.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.PendingChannelsResponse.ForceClosedChannel
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "channel": return self.channel
            case "closingTxid": return self.closingTxid
            case "limboBalance": return self.limboBalance
            case "maturityHeight": return self.maturityHeight
            case "blocksTilMaturity": return self.blocksTilMaturity
            case "recoveredBalance": return self.recoveredBalance
            case "pendingHtlcs": return self.pendingHtlcs
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "channel":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.PendingChannelsResponse.PendingChannel else {
                    return
                }
                self.channel = newSubscriptValue
            case "closingTxid":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.closingTxid = newSubscriptValue
            case "limboBalance":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.limboBalance = newSubscriptValue
            case "maturityHeight":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.maturityHeight = newSubscriptValue
            case "blocksTilMaturity":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.blocksTilMaturity = newSubscriptValue
            case "recoveredBalance":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.recoveredBalance = newSubscriptValue
            case "pendingHtlcs":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.PendingHtlc> else {
                    return
                }
                self.pendingHtlcs = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.WalletBalanceRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.WalletBalanceRequest> {
        var mergedArray = Array<Lnrpc.WalletBalanceRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.WalletBalanceRequest? {
        return try Lnrpc.WalletBalanceRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.WalletBalanceRequest {
        return try Lnrpc.WalletBalanceRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.WalletBalanceRequest {
        return try Lnrpc.WalletBalanceRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.WalletBalanceRequest {
        return try Lnrpc.WalletBalanceRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.WalletBalanceRequest {
        return try Lnrpc.WalletBalanceRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.WalletBalanceRequest {
        return try Lnrpc.WalletBalanceRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.WalletBalanceRequest {
        return try Lnrpc.WalletBalanceRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Lnrpc.WalletBalanceRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.WalletBalanceRequest
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Lnrpc.WalletBalanceResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.WalletBalanceResponse> {
        var mergedArray = Array<Lnrpc.WalletBalanceResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.WalletBalanceResponse? {
        return try Lnrpc.WalletBalanceResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.WalletBalanceResponse {
        return try Lnrpc.WalletBalanceResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.WalletBalanceResponse {
        return try Lnrpc.WalletBalanceResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.WalletBalanceResponse {
        return try Lnrpc.WalletBalanceResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.WalletBalanceResponse {
        return try Lnrpc.WalletBalanceResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.WalletBalanceResponse {
        return try Lnrpc.WalletBalanceResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.WalletBalanceResponse {
        return try Lnrpc.WalletBalanceResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "totalBalance": return self.totalBalance
        case "confirmedBalance": return self.confirmedBalance
        case "unconfirmedBalance": return self.unconfirmedBalance
        default: return nil
        }
    }
}
extension Lnrpc.WalletBalanceResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.WalletBalanceResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "totalBalance": return self.totalBalance
            case "confirmedBalance": return self.confirmedBalance
            case "unconfirmedBalance": return self.unconfirmedBalance
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "totalBalance":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.totalBalance = newSubscriptValue
            case "confirmedBalance":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.confirmedBalance = newSubscriptValue
            case "unconfirmedBalance":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.unconfirmedBalance = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.ChannelBalanceRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ChannelBalanceRequest> {
        var mergedArray = Array<Lnrpc.ChannelBalanceRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ChannelBalanceRequest? {
        return try Lnrpc.ChannelBalanceRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ChannelBalanceRequest {
        return try Lnrpc.ChannelBalanceRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelBalanceRequest {
        return try Lnrpc.ChannelBalanceRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ChannelBalanceRequest {
        return try Lnrpc.ChannelBalanceRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelBalanceRequest {
        return try Lnrpc.ChannelBalanceRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChannelBalanceRequest {
        return try Lnrpc.ChannelBalanceRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelBalanceRequest {
        return try Lnrpc.ChannelBalanceRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Lnrpc.ChannelBalanceRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ChannelBalanceRequest
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Lnrpc.ChannelBalanceResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ChannelBalanceResponse> {
        var mergedArray = Array<Lnrpc.ChannelBalanceResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ChannelBalanceResponse? {
        return try Lnrpc.ChannelBalanceResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ChannelBalanceResponse {
        return try Lnrpc.ChannelBalanceResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelBalanceResponse {
        return try Lnrpc.ChannelBalanceResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ChannelBalanceResponse {
        return try Lnrpc.ChannelBalanceResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelBalanceResponse {
        return try Lnrpc.ChannelBalanceResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChannelBalanceResponse {
        return try Lnrpc.ChannelBalanceResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelBalanceResponse {
        return try Lnrpc.ChannelBalanceResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "balance": return self.balance
        case "pendingOpenBalance": return self.pendingOpenBalance
        default: return nil
        }
    }
}
extension Lnrpc.ChannelBalanceResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ChannelBalanceResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "balance": return self.balance
            case "pendingOpenBalance": return self.pendingOpenBalance
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "balance":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.balance = newSubscriptValue
            case "pendingOpenBalance":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.pendingOpenBalance = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.QueryRoutesRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.QueryRoutesRequest> {
        var mergedArray = Array<Lnrpc.QueryRoutesRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.QueryRoutesRequest? {
        return try Lnrpc.QueryRoutesRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.QueryRoutesRequest {
        return try Lnrpc.QueryRoutesRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.QueryRoutesRequest {
        return try Lnrpc.QueryRoutesRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.QueryRoutesRequest {
        return try Lnrpc.QueryRoutesRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.QueryRoutesRequest {
        return try Lnrpc.QueryRoutesRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.QueryRoutesRequest {
        return try Lnrpc.QueryRoutesRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.QueryRoutesRequest {
        return try Lnrpc.QueryRoutesRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "pubKey": return self.pubKey
        case "amt": return self.amt
        case "numRoutes": return self.numRoutes
        case "finalCltvDelta": return self.finalCltvDelta
        case "feeLimit": return self.feeLimit
        default: return nil
        }
    }
}
extension Lnrpc.QueryRoutesRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.QueryRoutesRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "pubKey": return self.pubKey
            case "amt": return self.amt
            case "numRoutes": return self.numRoutes
            case "finalCltvDelta": return self.finalCltvDelta
            case "feeLimit": return self.feeLimit
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "pubKey":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.pubKey = newSubscriptValue
            case "amt":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.amt = newSubscriptValue
            case "numRoutes":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.numRoutes = newSubscriptValue
            case "finalCltvDelta":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.finalCltvDelta = newSubscriptValue
            case "feeLimit":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.FeeLimit else {
                    return
                }
                self.feeLimit = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.QueryRoutesResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.QueryRoutesResponse> {
        var mergedArray = Array<Lnrpc.QueryRoutesResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.QueryRoutesResponse? {
        return try Lnrpc.QueryRoutesResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.QueryRoutesResponse {
        return try Lnrpc.QueryRoutesResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.QueryRoutesResponse {
        return try Lnrpc.QueryRoutesResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.QueryRoutesResponse {
        return try Lnrpc.QueryRoutesResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.QueryRoutesResponse {
        return try Lnrpc.QueryRoutesResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.QueryRoutesResponse {
        return try Lnrpc.QueryRoutesResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.QueryRoutesResponse {
        return try Lnrpc.QueryRoutesResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "routes": return self.routes
        default: return nil
        }
    }
}
extension Lnrpc.QueryRoutesResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.QueryRoutesResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "routes": return self.routes
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "routes":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.Route> else {
                    return
                }
                self.routes = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.Hop: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.Hop> {
        var mergedArray = Array<Lnrpc.Hop>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.Hop? {
        return try Lnrpc.Hop.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.Hop {
        return try Lnrpc.Hop.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Hop {
        return try Lnrpc.Hop.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.Hop {
        return try Lnrpc.Hop.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Hop {
        return try Lnrpc.Hop.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.Hop {
        return try Lnrpc.Hop.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Hop {
        return try Lnrpc.Hop.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "chanId": return self.chanId
        case "chanCapacity": return self.chanCapacity
        case "amtToForward": return self.amtToForward
        case "fee": return self.fee
        case "expiry": return self.expiry
        case "amtToForwardMsat": return self.amtToForwardMsat
        case "feeMsat": return self.feeMsat
        default: return nil
        }
    }
}
extension Lnrpc.Hop.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.Hop
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "chanId": return self.chanId
            case "chanCapacity": return self.chanCapacity
            case "amtToForward": return self.amtToForward
            case "fee": return self.fee
            case "expiry": return self.expiry
            case "amtToForwardMsat": return self.amtToForwardMsat
            case "feeMsat": return self.feeMsat
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "chanId":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.chanId = newSubscriptValue
            case "chanCapacity":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.chanCapacity = newSubscriptValue
            case "amtToForward":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.amtToForward = newSubscriptValue
            case "fee":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.fee = newSubscriptValue
            case "expiry":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.expiry = newSubscriptValue
            case "amtToForwardMsat":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.amtToForwardMsat = newSubscriptValue
            case "feeMsat":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.feeMsat = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.Route: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.Route> {
        var mergedArray = Array<Lnrpc.Route>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.Route? {
        return try Lnrpc.Route.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.Route {
        return try Lnrpc.Route.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Route {
        return try Lnrpc.Route.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.Route {
        return try Lnrpc.Route.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Route {
        return try Lnrpc.Route.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.Route {
        return try Lnrpc.Route.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Route {
        return try Lnrpc.Route.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "totalTimeLock": return self.totalTimeLock
        case "totalFees": return self.totalFees
        case "totalAmt": return self.totalAmt
        case "hops": return self.hops
        case "totalFeesMsat": return self.totalFeesMsat
        case "totalAmtMsat": return self.totalAmtMsat
        default: return nil
        }
    }
}
extension Lnrpc.Route.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.Route
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "totalTimeLock": return self.totalTimeLock
            case "totalFees": return self.totalFees
            case "totalAmt": return self.totalAmt
            case "hops": return self.hops
            case "totalFeesMsat": return self.totalFeesMsat
            case "totalAmtMsat": return self.totalAmtMsat
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "totalTimeLock":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.totalTimeLock = newSubscriptValue
            case "totalFees":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.totalFees = newSubscriptValue
            case "totalAmt":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.totalAmt = newSubscriptValue
            case "hops":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.Hop> else {
                    return
                }
                self.hops = newSubscriptValue
            case "totalFeesMsat":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.totalFeesMsat = newSubscriptValue
            case "totalAmtMsat":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.totalAmtMsat = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.NodeInfoRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.NodeInfoRequest> {
        var mergedArray = Array<Lnrpc.NodeInfoRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.NodeInfoRequest? {
        return try Lnrpc.NodeInfoRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.NodeInfoRequest {
        return try Lnrpc.NodeInfoRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NodeInfoRequest {
        return try Lnrpc.NodeInfoRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.NodeInfoRequest {
        return try Lnrpc.NodeInfoRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NodeInfoRequest {
        return try Lnrpc.NodeInfoRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.NodeInfoRequest {
        return try Lnrpc.NodeInfoRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NodeInfoRequest {
        return try Lnrpc.NodeInfoRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "pubKey": return self.pubKey
        default: return nil
        }
    }
}
extension Lnrpc.NodeInfoRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.NodeInfoRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "pubKey": return self.pubKey
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "pubKey":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.pubKey = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.NodeInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.NodeInfo> {
        var mergedArray = Array<Lnrpc.NodeInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.NodeInfo? {
        return try Lnrpc.NodeInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.NodeInfo {
        return try Lnrpc.NodeInfo.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NodeInfo {
        return try Lnrpc.NodeInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.NodeInfo {
        return try Lnrpc.NodeInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NodeInfo {
        return try Lnrpc.NodeInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.NodeInfo {
        return try Lnrpc.NodeInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NodeInfo {
        return try Lnrpc.NodeInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "node": return self.node
        case "numChannels": return self.numChannels
        case "totalCapacity": return self.totalCapacity
        default: return nil
        }
    }
}
extension Lnrpc.NodeInfo.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.NodeInfo
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "node": return self.node
            case "numChannels": return self.numChannels
            case "totalCapacity": return self.totalCapacity
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "node":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.LightningNode else {
                    return
                }
                self.node = newSubscriptValue
            case "numChannels":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.numChannels = newSubscriptValue
            case "totalCapacity":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.totalCapacity = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.LightningNode: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.LightningNode> {
        var mergedArray = Array<Lnrpc.LightningNode>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.LightningNode? {
        return try Lnrpc.LightningNode.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.LightningNode {
        return try Lnrpc.LightningNode.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.LightningNode {
        return try Lnrpc.LightningNode.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.LightningNode {
        return try Lnrpc.LightningNode.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.LightningNode {
        return try Lnrpc.LightningNode.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.LightningNode {
        return try Lnrpc.LightningNode.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.LightningNode {
        return try Lnrpc.LightningNode.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "lastUpdate": return self.lastUpdate
        case "pubKey": return self.pubKey
        case "alias": return self.alias
        case "addresses": return self.addresses
        case "color": return self.color
        default: return nil
        }
    }
}
extension Lnrpc.LightningNode.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.LightningNode
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "lastUpdate": return self.lastUpdate
            case "pubKey": return self.pubKey
            case "alias": return self.alias
            case "addresses": return self.addresses
            case "color": return self.color
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "lastUpdate":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.lastUpdate = newSubscriptValue
            case "pubKey":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.pubKey = newSubscriptValue
            case "alias":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.alias = newSubscriptValue
            case "addresses":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.NodeAddress> else {
                    return
                }
                self.addresses = newSubscriptValue
            case "color":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.color = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.NodeAddress: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.NodeAddress> {
        var mergedArray = Array<Lnrpc.NodeAddress>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.NodeAddress? {
        return try Lnrpc.NodeAddress.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.NodeAddress {
        return try Lnrpc.NodeAddress.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NodeAddress {
        return try Lnrpc.NodeAddress.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.NodeAddress {
        return try Lnrpc.NodeAddress.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NodeAddress {
        return try Lnrpc.NodeAddress.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.NodeAddress {
        return try Lnrpc.NodeAddress.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NodeAddress {
        return try Lnrpc.NodeAddress.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "network": return self.network
        case "addr": return self.addr
        default: return nil
        }
    }
}
extension Lnrpc.NodeAddress.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.NodeAddress
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "network": return self.network
            case "addr": return self.addr
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "network":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.network = newSubscriptValue
            case "addr":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.addr = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.RoutingPolicy: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.RoutingPolicy> {
        var mergedArray = Array<Lnrpc.RoutingPolicy>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.RoutingPolicy? {
        return try Lnrpc.RoutingPolicy.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.RoutingPolicy {
        return try Lnrpc.RoutingPolicy.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.RoutingPolicy {
        return try Lnrpc.RoutingPolicy.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.RoutingPolicy {
        return try Lnrpc.RoutingPolicy.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.RoutingPolicy {
        return try Lnrpc.RoutingPolicy.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.RoutingPolicy {
        return try Lnrpc.RoutingPolicy.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.RoutingPolicy {
        return try Lnrpc.RoutingPolicy.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "timeLockDelta": return self.timeLockDelta
        case "minHtlc": return self.minHtlc
        case "feeBaseMsat": return self.feeBaseMsat
        case "feeRateMilliMsat": return self.feeRateMilliMsat
        case "disabled": return self.disabled
        default: return nil
        }
    }
}
extension Lnrpc.RoutingPolicy.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.RoutingPolicy
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "timeLockDelta": return self.timeLockDelta
            case "minHtlc": return self.minHtlc
            case "feeBaseMsat": return self.feeBaseMsat
            case "feeRateMilliMsat": return self.feeRateMilliMsat
            case "disabled": return self.disabled
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "timeLockDelta":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.timeLockDelta = newSubscriptValue
            case "minHtlc":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.minHtlc = newSubscriptValue
            case "feeBaseMsat":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.feeBaseMsat = newSubscriptValue
            case "feeRateMilliMsat":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.feeRateMilliMsat = newSubscriptValue
            case "disabled":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.disabled = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.ChannelEdge: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ChannelEdge> {
        var mergedArray = Array<Lnrpc.ChannelEdge>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ChannelEdge? {
        return try Lnrpc.ChannelEdge.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ChannelEdge {
        return try Lnrpc.ChannelEdge.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelEdge {
        return try Lnrpc.ChannelEdge.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ChannelEdge {
        return try Lnrpc.ChannelEdge.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelEdge {
        return try Lnrpc.ChannelEdge.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChannelEdge {
        return try Lnrpc.ChannelEdge.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelEdge {
        return try Lnrpc.ChannelEdge.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "channelId": return self.channelId
        case "chanPoint": return self.chanPoint
        case "lastUpdate": return self.lastUpdate
        case "node1Pub": return self.node1Pub
        case "node2Pub": return self.node2Pub
        case "capacity": return self.capacity
        case "node1Policy": return self.node1Policy
        case "node2Policy": return self.node2Policy
        default: return nil
        }
    }
}
extension Lnrpc.ChannelEdge.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ChannelEdge
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "channelId": return self.channelId
            case "chanPoint": return self.chanPoint
            case "lastUpdate": return self.lastUpdate
            case "node1Pub": return self.node1Pub
            case "node2Pub": return self.node2Pub
            case "capacity": return self.capacity
            case "node1Policy": return self.node1Policy
            case "node2Policy": return self.node2Policy
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "channelId":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.channelId = newSubscriptValue
            case "chanPoint":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.chanPoint = newSubscriptValue
            case "lastUpdate":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.lastUpdate = newSubscriptValue
            case "node1Pub":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.node1Pub = newSubscriptValue
            case "node2Pub":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.node2Pub = newSubscriptValue
            case "capacity":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.capacity = newSubscriptValue
            case "node1Policy":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.RoutingPolicy else {
                    return
                }
                self.node1Policy = newSubscriptValue
            case "node2Policy":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.RoutingPolicy else {
                    return
                }
                self.node2Policy = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.ChannelGraphRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ChannelGraphRequest> {
        var mergedArray = Array<Lnrpc.ChannelGraphRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ChannelGraphRequest? {
        return try Lnrpc.ChannelGraphRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ChannelGraphRequest {
        return try Lnrpc.ChannelGraphRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelGraphRequest {
        return try Lnrpc.ChannelGraphRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ChannelGraphRequest {
        return try Lnrpc.ChannelGraphRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelGraphRequest {
        return try Lnrpc.ChannelGraphRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChannelGraphRequest {
        return try Lnrpc.ChannelGraphRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelGraphRequest {
        return try Lnrpc.ChannelGraphRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Lnrpc.ChannelGraphRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ChannelGraphRequest
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Lnrpc.ChannelGraph: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ChannelGraph> {
        var mergedArray = Array<Lnrpc.ChannelGraph>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ChannelGraph? {
        return try Lnrpc.ChannelGraph.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ChannelGraph {
        return try Lnrpc.ChannelGraph.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelGraph {
        return try Lnrpc.ChannelGraph.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ChannelGraph {
        return try Lnrpc.ChannelGraph.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelGraph {
        return try Lnrpc.ChannelGraph.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChannelGraph {
        return try Lnrpc.ChannelGraph.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelGraph {
        return try Lnrpc.ChannelGraph.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "nodes": return self.nodes
        case "edges": return self.edges
        default: return nil
        }
    }
}
extension Lnrpc.ChannelGraph.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ChannelGraph
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "nodes": return self.nodes
            case "edges": return self.edges
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "nodes":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.LightningNode> else {
                    return
                }
                self.nodes = newSubscriptValue
            case "edges":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.ChannelEdge> else {
                    return
                }
                self.edges = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.ChanInfoRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ChanInfoRequest> {
        var mergedArray = Array<Lnrpc.ChanInfoRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ChanInfoRequest? {
        return try Lnrpc.ChanInfoRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ChanInfoRequest {
        return try Lnrpc.ChanInfoRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChanInfoRequest {
        return try Lnrpc.ChanInfoRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ChanInfoRequest {
        return try Lnrpc.ChanInfoRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChanInfoRequest {
        return try Lnrpc.ChanInfoRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChanInfoRequest {
        return try Lnrpc.ChanInfoRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChanInfoRequest {
        return try Lnrpc.ChanInfoRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "chanId": return self.chanId
        default: return nil
        }
    }
}
extension Lnrpc.ChanInfoRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ChanInfoRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "chanId": return self.chanId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "chanId":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.chanId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.NetworkInfoRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.NetworkInfoRequest> {
        var mergedArray = Array<Lnrpc.NetworkInfoRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.NetworkInfoRequest? {
        return try Lnrpc.NetworkInfoRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.NetworkInfoRequest {
        return try Lnrpc.NetworkInfoRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NetworkInfoRequest {
        return try Lnrpc.NetworkInfoRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.NetworkInfoRequest {
        return try Lnrpc.NetworkInfoRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NetworkInfoRequest {
        return try Lnrpc.NetworkInfoRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.NetworkInfoRequest {
        return try Lnrpc.NetworkInfoRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NetworkInfoRequest {
        return try Lnrpc.NetworkInfoRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Lnrpc.NetworkInfoRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.NetworkInfoRequest
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Lnrpc.NetworkInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.NetworkInfo> {
        var mergedArray = Array<Lnrpc.NetworkInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.NetworkInfo? {
        return try Lnrpc.NetworkInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.NetworkInfo {
        return try Lnrpc.NetworkInfo.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NetworkInfo {
        return try Lnrpc.NetworkInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.NetworkInfo {
        return try Lnrpc.NetworkInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NetworkInfo {
        return try Lnrpc.NetworkInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.NetworkInfo {
        return try Lnrpc.NetworkInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NetworkInfo {
        return try Lnrpc.NetworkInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "graphDiameter": return self.graphDiameter
        case "avgOutDegree": return self.avgOutDegree
        case "maxOutDegree": return self.maxOutDegree
        case "numNodes": return self.numNodes
        case "numChannels": return self.numChannels
        case "totalNetworkCapacity": return self.totalNetworkCapacity
        case "avgChannelSize": return self.avgChannelSize
        case "minChannelSize": return self.minChannelSize
        case "maxChannelSize": return self.maxChannelSize
        default: return nil
        }
    }
}
extension Lnrpc.NetworkInfo.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.NetworkInfo
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "graphDiameter": return self.graphDiameter
            case "avgOutDegree": return self.avgOutDegree
            case "maxOutDegree": return self.maxOutDegree
            case "numNodes": return self.numNodes
            case "numChannels": return self.numChannels
            case "totalNetworkCapacity": return self.totalNetworkCapacity
            case "avgChannelSize": return self.avgChannelSize
            case "minChannelSize": return self.minChannelSize
            case "maxChannelSize": return self.maxChannelSize
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "graphDiameter":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.graphDiameter = newSubscriptValue
            case "avgOutDegree":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.avgOutDegree = newSubscriptValue
            case "maxOutDegree":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.maxOutDegree = newSubscriptValue
            case "numNodes":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.numNodes = newSubscriptValue
            case "numChannels":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.numChannels = newSubscriptValue
            case "totalNetworkCapacity":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.totalNetworkCapacity = newSubscriptValue
            case "avgChannelSize":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.avgChannelSize = newSubscriptValue
            case "minChannelSize":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.minChannelSize = newSubscriptValue
            case "maxChannelSize":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.maxChannelSize = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.StopRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.StopRequest> {
        var mergedArray = Array<Lnrpc.StopRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.StopRequest? {
        return try Lnrpc.StopRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.StopRequest {
        return try Lnrpc.StopRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.StopRequest {
        return try Lnrpc.StopRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.StopRequest {
        return try Lnrpc.StopRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.StopRequest {
        return try Lnrpc.StopRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.StopRequest {
        return try Lnrpc.StopRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.StopRequest {
        return try Lnrpc.StopRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Lnrpc.StopRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.StopRequest
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Lnrpc.StopResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.StopResponse> {
        var mergedArray = Array<Lnrpc.StopResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.StopResponse? {
        return try Lnrpc.StopResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.StopResponse {
        return try Lnrpc.StopResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.StopResponse {
        return try Lnrpc.StopResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.StopResponse {
        return try Lnrpc.StopResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.StopResponse {
        return try Lnrpc.StopResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.StopResponse {
        return try Lnrpc.StopResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.StopResponse {
        return try Lnrpc.StopResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Lnrpc.StopResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.StopResponse
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Lnrpc.GraphTopologySubscription: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.GraphTopologySubscription> {
        var mergedArray = Array<Lnrpc.GraphTopologySubscription>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.GraphTopologySubscription? {
        return try Lnrpc.GraphTopologySubscription.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.GraphTopologySubscription {
        return try Lnrpc.GraphTopologySubscription.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GraphTopologySubscription {
        return try Lnrpc.GraphTopologySubscription.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.GraphTopologySubscription {
        return try Lnrpc.GraphTopologySubscription.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GraphTopologySubscription {
        return try Lnrpc.GraphTopologySubscription.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.GraphTopologySubscription {
        return try Lnrpc.GraphTopologySubscription.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GraphTopologySubscription {
        return try Lnrpc.GraphTopologySubscription.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Lnrpc.GraphTopologySubscription.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.GraphTopologySubscription
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Lnrpc.GraphTopologyUpdate: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.GraphTopologyUpdate> {
        var mergedArray = Array<Lnrpc.GraphTopologyUpdate>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.GraphTopologyUpdate? {
        return try Lnrpc.GraphTopologyUpdate.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.GraphTopologyUpdate {
        return try Lnrpc.GraphTopologyUpdate.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GraphTopologyUpdate {
        return try Lnrpc.GraphTopologyUpdate.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.GraphTopologyUpdate {
        return try Lnrpc.GraphTopologyUpdate.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GraphTopologyUpdate {
        return try Lnrpc.GraphTopologyUpdate.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.GraphTopologyUpdate {
        return try Lnrpc.GraphTopologyUpdate.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.GraphTopologyUpdate {
        return try Lnrpc.GraphTopologyUpdate.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "nodeUpdates": return self.nodeUpdates
        case "channelUpdates": return self.channelUpdates
        case "closedChans": return self.closedChans
        default: return nil
        }
    }
}
extension Lnrpc.GraphTopologyUpdate.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.GraphTopologyUpdate
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "nodeUpdates": return self.nodeUpdates
            case "channelUpdates": return self.channelUpdates
            case "closedChans": return self.closedChans
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "nodeUpdates":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.NodeUpdate> else {
                    return
                }
                self.nodeUpdates = newSubscriptValue
            case "channelUpdates":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.ChannelEdgeUpdate> else {
                    return
                }
                self.channelUpdates = newSubscriptValue
            case "closedChans":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.ClosedChannelUpdate> else {
                    return
                }
                self.closedChans = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.NodeUpdate: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.NodeUpdate> {
        var mergedArray = Array<Lnrpc.NodeUpdate>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.NodeUpdate? {
        return try Lnrpc.NodeUpdate.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.NodeUpdate {
        return try Lnrpc.NodeUpdate.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NodeUpdate {
        return try Lnrpc.NodeUpdate.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.NodeUpdate {
        return try Lnrpc.NodeUpdate.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NodeUpdate {
        return try Lnrpc.NodeUpdate.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.NodeUpdate {
        return try Lnrpc.NodeUpdate.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.NodeUpdate {
        return try Lnrpc.NodeUpdate.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "addresses": return self.addresses
        case "identityKey": return self.identityKey
        case "globalFeatures": return self.globalFeatures
        case "alias": return self.alias
        default: return nil
        }
    }
}
extension Lnrpc.NodeUpdate.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.NodeUpdate
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "addresses": return self.addresses
            case "identityKey": return self.identityKey
            case "globalFeatures": return self.globalFeatures
            case "alias": return self.alias
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "addresses":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.addresses = newSubscriptValue
            case "identityKey":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.identityKey = newSubscriptValue
            case "globalFeatures":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.globalFeatures = newSubscriptValue
            case "alias":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.alias = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.ChannelEdgeUpdate: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ChannelEdgeUpdate> {
        var mergedArray = Array<Lnrpc.ChannelEdgeUpdate>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ChannelEdgeUpdate? {
        return try Lnrpc.ChannelEdgeUpdate.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ChannelEdgeUpdate {
        return try Lnrpc.ChannelEdgeUpdate.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelEdgeUpdate {
        return try Lnrpc.ChannelEdgeUpdate.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ChannelEdgeUpdate {
        return try Lnrpc.ChannelEdgeUpdate.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelEdgeUpdate {
        return try Lnrpc.ChannelEdgeUpdate.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChannelEdgeUpdate {
        return try Lnrpc.ChannelEdgeUpdate.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelEdgeUpdate {
        return try Lnrpc.ChannelEdgeUpdate.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "chanId": return self.chanId
        case "chanPoint": return self.chanPoint
        case "capacity": return self.capacity
        case "routingPolicy": return self.routingPolicy
        case "advertisingNode": return self.advertisingNode
        case "connectingNode": return self.connectingNode
        default: return nil
        }
    }
}
extension Lnrpc.ChannelEdgeUpdate.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ChannelEdgeUpdate
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "chanId": return self.chanId
            case "chanPoint": return self.chanPoint
            case "capacity": return self.capacity
            case "routingPolicy": return self.routingPolicy
            case "advertisingNode": return self.advertisingNode
            case "connectingNode": return self.connectingNode
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "chanId":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.chanId = newSubscriptValue
            case "chanPoint":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.ChannelPoint else {
                    return
                }
                self.chanPoint = newSubscriptValue
            case "capacity":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.capacity = newSubscriptValue
            case "routingPolicy":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.RoutingPolicy else {
                    return
                }
                self.routingPolicy = newSubscriptValue
            case "advertisingNode":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.advertisingNode = newSubscriptValue
            case "connectingNode":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.connectingNode = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.ClosedChannelUpdate: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ClosedChannelUpdate> {
        var mergedArray = Array<Lnrpc.ClosedChannelUpdate>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ClosedChannelUpdate? {
        return try Lnrpc.ClosedChannelUpdate.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ClosedChannelUpdate {
        return try Lnrpc.ClosedChannelUpdate.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ClosedChannelUpdate {
        return try Lnrpc.ClosedChannelUpdate.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ClosedChannelUpdate {
        return try Lnrpc.ClosedChannelUpdate.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ClosedChannelUpdate {
        return try Lnrpc.ClosedChannelUpdate.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ClosedChannelUpdate {
        return try Lnrpc.ClosedChannelUpdate.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ClosedChannelUpdate {
        return try Lnrpc.ClosedChannelUpdate.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "chanId": return self.chanId
        case "capacity": return self.capacity
        case "closedHeight": return self.closedHeight
        case "chanPoint": return self.chanPoint
        default: return nil
        }
    }
}
extension Lnrpc.ClosedChannelUpdate.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ClosedChannelUpdate
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "chanId": return self.chanId
            case "capacity": return self.capacity
            case "closedHeight": return self.closedHeight
            case "chanPoint": return self.chanPoint
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "chanId":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.chanId = newSubscriptValue
            case "capacity":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.capacity = newSubscriptValue
            case "closedHeight":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.closedHeight = newSubscriptValue
            case "chanPoint":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.ChannelPoint else {
                    return
                }
                self.chanPoint = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.HopHint: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.HopHint> {
        var mergedArray = Array<Lnrpc.HopHint>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.HopHint? {
        return try Lnrpc.HopHint.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.HopHint {
        return try Lnrpc.HopHint.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.HopHint {
        return try Lnrpc.HopHint.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.HopHint {
        return try Lnrpc.HopHint.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.HopHint {
        return try Lnrpc.HopHint.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.HopHint {
        return try Lnrpc.HopHint.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.HopHint {
        return try Lnrpc.HopHint.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "nodeId": return self.nodeId
        case "chanId": return self.chanId
        case "feeBaseMsat": return self.feeBaseMsat
        case "feeProportionalMillionths": return self.feeProportionalMillionths
        case "cltvExpiryDelta": return self.cltvExpiryDelta
        default: return nil
        }
    }
}
extension Lnrpc.HopHint.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.HopHint
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "nodeId": return self.nodeId
            case "chanId": return self.chanId
            case "feeBaseMsat": return self.feeBaseMsat
            case "feeProportionalMillionths": return self.feeProportionalMillionths
            case "cltvExpiryDelta": return self.cltvExpiryDelta
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "nodeId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.nodeId = newSubscriptValue
            case "chanId":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.chanId = newSubscriptValue
            case "feeBaseMsat":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.feeBaseMsat = newSubscriptValue
            case "feeProportionalMillionths":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.feeProportionalMillionths = newSubscriptValue
            case "cltvExpiryDelta":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.cltvExpiryDelta = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.RouteHint: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.RouteHint> {
        var mergedArray = Array<Lnrpc.RouteHint>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.RouteHint? {
        return try Lnrpc.RouteHint.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.RouteHint {
        return try Lnrpc.RouteHint.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.RouteHint {
        return try Lnrpc.RouteHint.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.RouteHint {
        return try Lnrpc.RouteHint.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.RouteHint {
        return try Lnrpc.RouteHint.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.RouteHint {
        return try Lnrpc.RouteHint.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.RouteHint {
        return try Lnrpc.RouteHint.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "hopHints": return self.hopHints
        default: return nil
        }
    }
}
extension Lnrpc.RouteHint.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.RouteHint
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "hopHints": return self.hopHints
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "hopHints":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.HopHint> else {
                    return
                }
                self.hopHints = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.Invoice: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.Invoice> {
        var mergedArray = Array<Lnrpc.Invoice>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.Invoice? {
        return try Lnrpc.Invoice.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.Invoice {
        return try Lnrpc.Invoice.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Invoice {
        return try Lnrpc.Invoice.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.Invoice {
        return try Lnrpc.Invoice.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Invoice {
        return try Lnrpc.Invoice.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.Invoice {
        return try Lnrpc.Invoice.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Invoice {
        return try Lnrpc.Invoice.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "memo": return self.memo
        case "receipt": return self.receipt
        case "rPreimage": return self.rPreimage
        case "rHash": return self.rHash
        case "value": return self.value
        case "settled": return self.settled
        case "creationDate": return self.creationDate
        case "settleDate": return self.settleDate
        case "paymentRequest": return self.paymentRequest
        case "descriptionHash": return self.descriptionHash
        case "expiry": return self.expiry
        case "fallbackAddr": return self.fallbackAddr
        case "cltvExpiry": return self.cltvExpiry
        case "routeHints": return self.routeHints
        case "private": return self.private
        case "addIndex": return self.addIndex
        case "settleIndex": return self.settleIndex
        case "amtPaid": return self.amtPaid
        default: return nil
        }
    }
}
extension Lnrpc.Invoice.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.Invoice
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "memo": return self.memo
            case "receipt": return self.receipt
            case "rPreimage": return self.rPreimage
            case "rHash": return self.rHash
            case "value": return self.value
            case "settled": return self.settled
            case "creationDate": return self.creationDate
            case "settleDate": return self.settleDate
            case "paymentRequest": return self.paymentRequest
            case "descriptionHash": return self.descriptionHash
            case "expiry": return self.expiry
            case "fallbackAddr": return self.fallbackAddr
            case "cltvExpiry": return self.cltvExpiry
            case "routeHints": return self.routeHints
            case "private": return self.private
            case "addIndex": return self.addIndex
            case "settleIndex": return self.settleIndex
            case "amtPaid": return self.amtPaid
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "memo":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.memo = newSubscriptValue
            case "receipt":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.receipt = newSubscriptValue
            case "rPreimage":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.rPreimage = newSubscriptValue
            case "rHash":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.rHash = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.value = newSubscriptValue
            case "settled":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.settled = newSubscriptValue
            case "creationDate":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.creationDate = newSubscriptValue
            case "settleDate":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.settleDate = newSubscriptValue
            case "paymentRequest":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.paymentRequest = newSubscriptValue
            case "descriptionHash":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.descriptionHash = newSubscriptValue
            case "expiry":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.expiry = newSubscriptValue
            case "fallbackAddr":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.fallbackAddr = newSubscriptValue
            case "cltvExpiry":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.cltvExpiry = newSubscriptValue
            case "routeHints":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.RouteHint> else {
                    return
                }
                self.routeHints = newSubscriptValue
            case "private":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.private = newSubscriptValue
            case "addIndex":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.addIndex = newSubscriptValue
            case "settleIndex":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.settleIndex = newSubscriptValue
            case "amtPaid":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.amtPaid = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.AddInvoiceResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.AddInvoiceResponse> {
        var mergedArray = Array<Lnrpc.AddInvoiceResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.AddInvoiceResponse? {
        return try Lnrpc.AddInvoiceResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.AddInvoiceResponse {
        return try Lnrpc.AddInvoiceResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.AddInvoiceResponse {
        return try Lnrpc.AddInvoiceResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.AddInvoiceResponse {
        return try Lnrpc.AddInvoiceResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.AddInvoiceResponse {
        return try Lnrpc.AddInvoiceResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.AddInvoiceResponse {
        return try Lnrpc.AddInvoiceResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.AddInvoiceResponse {
        return try Lnrpc.AddInvoiceResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "rHash": return self.rHash
        case "paymentRequest": return self.paymentRequest
        case "addIndex": return self.addIndex
        default: return nil
        }
    }
}
extension Lnrpc.AddInvoiceResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.AddInvoiceResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "rHash": return self.rHash
            case "paymentRequest": return self.paymentRequest
            case "addIndex": return self.addIndex
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "rHash":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.rHash = newSubscriptValue
            case "paymentRequest":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.paymentRequest = newSubscriptValue
            case "addIndex":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.addIndex = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.PaymentHash: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.PaymentHash> {
        var mergedArray = Array<Lnrpc.PaymentHash>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.PaymentHash? {
        return try Lnrpc.PaymentHash.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.PaymentHash {
        return try Lnrpc.PaymentHash.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PaymentHash {
        return try Lnrpc.PaymentHash.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.PaymentHash {
        return try Lnrpc.PaymentHash.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PaymentHash {
        return try Lnrpc.PaymentHash.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PaymentHash {
        return try Lnrpc.PaymentHash.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PaymentHash {
        return try Lnrpc.PaymentHash.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "rHashStr": return self.rHashStr
        case "rHash": return self.rHash
        default: return nil
        }
    }
}
extension Lnrpc.PaymentHash.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.PaymentHash
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "rHashStr": return self.rHashStr
            case "rHash": return self.rHash
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "rHashStr":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.rHashStr = newSubscriptValue
            case "rHash":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.rHash = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.ListInvoiceRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ListInvoiceRequest> {
        var mergedArray = Array<Lnrpc.ListInvoiceRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ListInvoiceRequest? {
        return try Lnrpc.ListInvoiceRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ListInvoiceRequest {
        return try Lnrpc.ListInvoiceRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListInvoiceRequest {
        return try Lnrpc.ListInvoiceRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ListInvoiceRequest {
        return try Lnrpc.ListInvoiceRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListInvoiceRequest {
        return try Lnrpc.ListInvoiceRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ListInvoiceRequest {
        return try Lnrpc.ListInvoiceRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListInvoiceRequest {
        return try Lnrpc.ListInvoiceRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "pendingOnly": return self.pendingOnly
        case "indexOffset": return self.indexOffset
        case "numMaxInvoices": return self.numMaxInvoices
        default: return nil
        }
    }
}
extension Lnrpc.ListInvoiceRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ListInvoiceRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "pendingOnly": return self.pendingOnly
            case "indexOffset": return self.indexOffset
            case "numMaxInvoices": return self.numMaxInvoices
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "pendingOnly":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.pendingOnly = newSubscriptValue
            case "indexOffset":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.indexOffset = newSubscriptValue
            case "numMaxInvoices":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.numMaxInvoices = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.ListInvoiceResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ListInvoiceResponse> {
        var mergedArray = Array<Lnrpc.ListInvoiceResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ListInvoiceResponse? {
        return try Lnrpc.ListInvoiceResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ListInvoiceResponse {
        return try Lnrpc.ListInvoiceResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListInvoiceResponse {
        return try Lnrpc.ListInvoiceResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ListInvoiceResponse {
        return try Lnrpc.ListInvoiceResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListInvoiceResponse {
        return try Lnrpc.ListInvoiceResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ListInvoiceResponse {
        return try Lnrpc.ListInvoiceResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListInvoiceResponse {
        return try Lnrpc.ListInvoiceResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "invoices": return self.invoices
        case "lastIndexOffset": return self.lastIndexOffset
        default: return nil
        }
    }
}
extension Lnrpc.ListInvoiceResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ListInvoiceResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "invoices": return self.invoices
            case "lastIndexOffset": return self.lastIndexOffset
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "invoices":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.Invoice> else {
                    return
                }
                self.invoices = newSubscriptValue
            case "lastIndexOffset":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.lastIndexOffset = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.InvoiceSubscription: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.InvoiceSubscription> {
        var mergedArray = Array<Lnrpc.InvoiceSubscription>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.InvoiceSubscription? {
        return try Lnrpc.InvoiceSubscription.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.InvoiceSubscription {
        return try Lnrpc.InvoiceSubscription.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.InvoiceSubscription {
        return try Lnrpc.InvoiceSubscription.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.InvoiceSubscription {
        return try Lnrpc.InvoiceSubscription.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.InvoiceSubscription {
        return try Lnrpc.InvoiceSubscription.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.InvoiceSubscription {
        return try Lnrpc.InvoiceSubscription.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.InvoiceSubscription {
        return try Lnrpc.InvoiceSubscription.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "addIndex": return self.addIndex
        case "settleIndex": return self.settleIndex
        default: return nil
        }
    }
}
extension Lnrpc.InvoiceSubscription.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.InvoiceSubscription
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "addIndex": return self.addIndex
            case "settleIndex": return self.settleIndex
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "addIndex":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.addIndex = newSubscriptValue
            case "settleIndex":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.settleIndex = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.Payment: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.Payment> {
        var mergedArray = Array<Lnrpc.Payment>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.Payment? {
        return try Lnrpc.Payment.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.Payment {
        return try Lnrpc.Payment.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Payment {
        return try Lnrpc.Payment.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.Payment {
        return try Lnrpc.Payment.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Payment {
        return try Lnrpc.Payment.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.Payment {
        return try Lnrpc.Payment.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.Payment {
        return try Lnrpc.Payment.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "paymentHash": return self.paymentHash
        case "value": return self.value
        case "creationDate": return self.creationDate
        case "path": return self.path
        case "fee": return self.fee
        case "paymentPreimage": return self.paymentPreimage
        default: return nil
        }
    }
}
extension Lnrpc.Payment.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.Payment
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "paymentHash": return self.paymentHash
            case "value": return self.value
            case "creationDate": return self.creationDate
            case "path": return self.path
            case "fee": return self.fee
            case "paymentPreimage": return self.paymentPreimage
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "paymentHash":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.paymentHash = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.value = newSubscriptValue
            case "creationDate":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.creationDate = newSubscriptValue
            case "path":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.path = newSubscriptValue
            case "fee":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.fee = newSubscriptValue
            case "paymentPreimage":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.paymentPreimage = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.ListPaymentsRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ListPaymentsRequest> {
        var mergedArray = Array<Lnrpc.ListPaymentsRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ListPaymentsRequest? {
        return try Lnrpc.ListPaymentsRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ListPaymentsRequest {
        return try Lnrpc.ListPaymentsRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListPaymentsRequest {
        return try Lnrpc.ListPaymentsRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ListPaymentsRequest {
        return try Lnrpc.ListPaymentsRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListPaymentsRequest {
        return try Lnrpc.ListPaymentsRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ListPaymentsRequest {
        return try Lnrpc.ListPaymentsRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListPaymentsRequest {
        return try Lnrpc.ListPaymentsRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Lnrpc.ListPaymentsRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ListPaymentsRequest
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Lnrpc.ListPaymentsResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ListPaymentsResponse> {
        var mergedArray = Array<Lnrpc.ListPaymentsResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ListPaymentsResponse? {
        return try Lnrpc.ListPaymentsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ListPaymentsResponse {
        return try Lnrpc.ListPaymentsResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListPaymentsResponse {
        return try Lnrpc.ListPaymentsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ListPaymentsResponse {
        return try Lnrpc.ListPaymentsResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListPaymentsResponse {
        return try Lnrpc.ListPaymentsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ListPaymentsResponse {
        return try Lnrpc.ListPaymentsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ListPaymentsResponse {
        return try Lnrpc.ListPaymentsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "payments": return self.payments
        default: return nil
        }
    }
}
extension Lnrpc.ListPaymentsResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ListPaymentsResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "payments": return self.payments
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "payments":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.Payment> else {
                    return
                }
                self.payments = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.DeleteAllPaymentsRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.DeleteAllPaymentsRequest> {
        var mergedArray = Array<Lnrpc.DeleteAllPaymentsRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.DeleteAllPaymentsRequest? {
        return try Lnrpc.DeleteAllPaymentsRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.DeleteAllPaymentsRequest {
        return try Lnrpc.DeleteAllPaymentsRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.DeleteAllPaymentsRequest {
        return try Lnrpc.DeleteAllPaymentsRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.DeleteAllPaymentsRequest {
        return try Lnrpc.DeleteAllPaymentsRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.DeleteAllPaymentsRequest {
        return try Lnrpc.DeleteAllPaymentsRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.DeleteAllPaymentsRequest {
        return try Lnrpc.DeleteAllPaymentsRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.DeleteAllPaymentsRequest {
        return try Lnrpc.DeleteAllPaymentsRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Lnrpc.DeleteAllPaymentsRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.DeleteAllPaymentsRequest
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Lnrpc.DeleteAllPaymentsResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.DeleteAllPaymentsResponse> {
        var mergedArray = Array<Lnrpc.DeleteAllPaymentsResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.DeleteAllPaymentsResponse? {
        return try Lnrpc.DeleteAllPaymentsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.DeleteAllPaymentsResponse {
        return try Lnrpc.DeleteAllPaymentsResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.DeleteAllPaymentsResponse {
        return try Lnrpc.DeleteAllPaymentsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.DeleteAllPaymentsResponse {
        return try Lnrpc.DeleteAllPaymentsResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.DeleteAllPaymentsResponse {
        return try Lnrpc.DeleteAllPaymentsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.DeleteAllPaymentsResponse {
        return try Lnrpc.DeleteAllPaymentsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.DeleteAllPaymentsResponse {
        return try Lnrpc.DeleteAllPaymentsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Lnrpc.DeleteAllPaymentsResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.DeleteAllPaymentsResponse
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Lnrpc.DebugLevelRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.DebugLevelRequest> {
        var mergedArray = Array<Lnrpc.DebugLevelRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.DebugLevelRequest? {
        return try Lnrpc.DebugLevelRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.DebugLevelRequest {
        return try Lnrpc.DebugLevelRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.DebugLevelRequest {
        return try Lnrpc.DebugLevelRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.DebugLevelRequest {
        return try Lnrpc.DebugLevelRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.DebugLevelRequest {
        return try Lnrpc.DebugLevelRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.DebugLevelRequest {
        return try Lnrpc.DebugLevelRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.DebugLevelRequest {
        return try Lnrpc.DebugLevelRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "show": return self.show
        case "levelSpec": return self.levelSpec
        default: return nil
        }
    }
}
extension Lnrpc.DebugLevelRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.DebugLevelRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "show": return self.show
            case "levelSpec": return self.levelSpec
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "show":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.show = newSubscriptValue
            case "levelSpec":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.levelSpec = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.DebugLevelResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.DebugLevelResponse> {
        var mergedArray = Array<Lnrpc.DebugLevelResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.DebugLevelResponse? {
        return try Lnrpc.DebugLevelResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.DebugLevelResponse {
        return try Lnrpc.DebugLevelResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.DebugLevelResponse {
        return try Lnrpc.DebugLevelResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.DebugLevelResponse {
        return try Lnrpc.DebugLevelResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.DebugLevelResponse {
        return try Lnrpc.DebugLevelResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.DebugLevelResponse {
        return try Lnrpc.DebugLevelResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.DebugLevelResponse {
        return try Lnrpc.DebugLevelResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "subSystems": return self.subSystems
        default: return nil
        }
    }
}
extension Lnrpc.DebugLevelResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.DebugLevelResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "subSystems": return self.subSystems
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "subSystems":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.subSystems = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.PayReqString: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.PayReqString> {
        var mergedArray = Array<Lnrpc.PayReqString>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.PayReqString? {
        return try Lnrpc.PayReqString.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.PayReqString {
        return try Lnrpc.PayReqString.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PayReqString {
        return try Lnrpc.PayReqString.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.PayReqString {
        return try Lnrpc.PayReqString.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PayReqString {
        return try Lnrpc.PayReqString.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PayReqString {
        return try Lnrpc.PayReqString.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PayReqString {
        return try Lnrpc.PayReqString.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "payReq": return self.payReq
        default: return nil
        }
    }
}
extension Lnrpc.PayReqString.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.PayReqString
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "payReq": return self.payReq
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "payReq":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.payReq = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.PayReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.PayReq> {
        var mergedArray = Array<Lnrpc.PayReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.PayReq? {
        return try Lnrpc.PayReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.PayReq {
        return try Lnrpc.PayReq.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PayReq {
        return try Lnrpc.PayReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.PayReq {
        return try Lnrpc.PayReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PayReq {
        return try Lnrpc.PayReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PayReq {
        return try Lnrpc.PayReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PayReq {
        return try Lnrpc.PayReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "destination": return self.destination
        case "paymentHash": return self.paymentHash
        case "numSatoshis": return self.numSatoshis
        case "timestamp": return self.timestamp
        case "expiry": return self.expiry
        case "description_": return self.description_
        case "descriptionHash": return self.descriptionHash
        case "fallbackAddr": return self.fallbackAddr
        case "cltvExpiry": return self.cltvExpiry
        case "routeHints": return self.routeHints
        default: return nil
        }
    }
}
extension Lnrpc.PayReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.PayReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "destination": return self.destination
            case "paymentHash": return self.paymentHash
            case "numSatoshis": return self.numSatoshis
            case "timestamp": return self.timestamp
            case "expiry": return self.expiry
            case "description_": return self.description_
            case "descriptionHash": return self.descriptionHash
            case "fallbackAddr": return self.fallbackAddr
            case "cltvExpiry": return self.cltvExpiry
            case "routeHints": return self.routeHints
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "destination":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.destination = newSubscriptValue
            case "paymentHash":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.paymentHash = newSubscriptValue
            case "numSatoshis":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.numSatoshis = newSubscriptValue
            case "timestamp":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.timestamp = newSubscriptValue
            case "expiry":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.expiry = newSubscriptValue
            case "description_":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.description_ = newSubscriptValue
            case "descriptionHash":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.descriptionHash = newSubscriptValue
            case "fallbackAddr":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.fallbackAddr = newSubscriptValue
            case "cltvExpiry":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.cltvExpiry = newSubscriptValue
            case "routeHints":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.RouteHint> else {
                    return
                }
                self.routeHints = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.FeeReportRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.FeeReportRequest> {
        var mergedArray = Array<Lnrpc.FeeReportRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.FeeReportRequest? {
        return try Lnrpc.FeeReportRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.FeeReportRequest {
        return try Lnrpc.FeeReportRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.FeeReportRequest {
        return try Lnrpc.FeeReportRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.FeeReportRequest {
        return try Lnrpc.FeeReportRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.FeeReportRequest {
        return try Lnrpc.FeeReportRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.FeeReportRequest {
        return try Lnrpc.FeeReportRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.FeeReportRequest {
        return try Lnrpc.FeeReportRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Lnrpc.FeeReportRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.FeeReportRequest
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Lnrpc.ChannelFeeReport: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ChannelFeeReport> {
        var mergedArray = Array<Lnrpc.ChannelFeeReport>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ChannelFeeReport? {
        return try Lnrpc.ChannelFeeReport.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ChannelFeeReport {
        return try Lnrpc.ChannelFeeReport.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelFeeReport {
        return try Lnrpc.ChannelFeeReport.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ChannelFeeReport {
        return try Lnrpc.ChannelFeeReport.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelFeeReport {
        return try Lnrpc.ChannelFeeReport.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ChannelFeeReport {
        return try Lnrpc.ChannelFeeReport.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ChannelFeeReport {
        return try Lnrpc.ChannelFeeReport.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "chanPoint": return self.chanPoint
        case "baseFeeMsat": return self.baseFeeMsat
        case "feePerMil": return self.feePerMil
        case "feeRate": return self.feeRate
        default: return nil
        }
    }
}
extension Lnrpc.ChannelFeeReport.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ChannelFeeReport
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "chanPoint": return self.chanPoint
            case "baseFeeMsat": return self.baseFeeMsat
            case "feePerMil": return self.feePerMil
            case "feeRate": return self.feeRate
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "chanPoint":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.chanPoint = newSubscriptValue
            case "baseFeeMsat":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.baseFeeMsat = newSubscriptValue
            case "feePerMil":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.feePerMil = newSubscriptValue
            case "feeRate":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.feeRate = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.FeeReportResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.FeeReportResponse> {
        var mergedArray = Array<Lnrpc.FeeReportResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.FeeReportResponse? {
        return try Lnrpc.FeeReportResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.FeeReportResponse {
        return try Lnrpc.FeeReportResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.FeeReportResponse {
        return try Lnrpc.FeeReportResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.FeeReportResponse {
        return try Lnrpc.FeeReportResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.FeeReportResponse {
        return try Lnrpc.FeeReportResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.FeeReportResponse {
        return try Lnrpc.FeeReportResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.FeeReportResponse {
        return try Lnrpc.FeeReportResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "channelFees": return self.channelFees
        case "dayFeeSum": return self.dayFeeSum
        case "weekFeeSum": return self.weekFeeSum
        case "monthFeeSum": return self.monthFeeSum
        default: return nil
        }
    }
}
extension Lnrpc.FeeReportResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.FeeReportResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "channelFees": return self.channelFees
            case "dayFeeSum": return self.dayFeeSum
            case "weekFeeSum": return self.weekFeeSum
            case "monthFeeSum": return self.monthFeeSum
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "channelFees":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.ChannelFeeReport> else {
                    return
                }
                self.channelFees = newSubscriptValue
            case "dayFeeSum":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.dayFeeSum = newSubscriptValue
            case "weekFeeSum":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.weekFeeSum = newSubscriptValue
            case "monthFeeSum":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.monthFeeSum = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.PolicyUpdateRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.PolicyUpdateRequest> {
        var mergedArray = Array<Lnrpc.PolicyUpdateRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.PolicyUpdateRequest? {
        return try Lnrpc.PolicyUpdateRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.PolicyUpdateRequest {
        return try Lnrpc.PolicyUpdateRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PolicyUpdateRequest {
        return try Lnrpc.PolicyUpdateRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.PolicyUpdateRequest {
        return try Lnrpc.PolicyUpdateRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PolicyUpdateRequest {
        return try Lnrpc.PolicyUpdateRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PolicyUpdateRequest {
        return try Lnrpc.PolicyUpdateRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PolicyUpdateRequest {
        return try Lnrpc.PolicyUpdateRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "global": return self.global
        case "chanPoint": return self.chanPoint
        case "baseFeeMsat": return self.baseFeeMsat
        case "feeRate": return self.feeRate
        case "timeLockDelta": return self.timeLockDelta
        default: return nil
        }
    }
}
extension Lnrpc.PolicyUpdateRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.PolicyUpdateRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "global": return self.global
            case "chanPoint": return self.chanPoint
            case "baseFeeMsat": return self.baseFeeMsat
            case "feeRate": return self.feeRate
            case "timeLockDelta": return self.timeLockDelta
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "global":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.global = newSubscriptValue
            case "chanPoint":
                guard let newSubscriptValue = newSubscriptValue as? Lnrpc.ChannelPoint else {
                    return
                }
                self.chanPoint = newSubscriptValue
            case "baseFeeMsat":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.baseFeeMsat = newSubscriptValue
            case "feeRate":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.feeRate = newSubscriptValue
            case "timeLockDelta":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.timeLockDelta = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.PolicyUpdateResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.PolicyUpdateResponse> {
        var mergedArray = Array<Lnrpc.PolicyUpdateResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.PolicyUpdateResponse? {
        return try Lnrpc.PolicyUpdateResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.PolicyUpdateResponse {
        return try Lnrpc.PolicyUpdateResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PolicyUpdateResponse {
        return try Lnrpc.PolicyUpdateResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.PolicyUpdateResponse {
        return try Lnrpc.PolicyUpdateResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PolicyUpdateResponse {
        return try Lnrpc.PolicyUpdateResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.PolicyUpdateResponse {
        return try Lnrpc.PolicyUpdateResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.PolicyUpdateResponse {
        return try Lnrpc.PolicyUpdateResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Lnrpc.PolicyUpdateResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.PolicyUpdateResponse
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Lnrpc.ForwardingHistoryRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ForwardingHistoryRequest> {
        var mergedArray = Array<Lnrpc.ForwardingHistoryRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ForwardingHistoryRequest? {
        return try Lnrpc.ForwardingHistoryRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ForwardingHistoryRequest {
        return try Lnrpc.ForwardingHistoryRequest.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ForwardingHistoryRequest {
        return try Lnrpc.ForwardingHistoryRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ForwardingHistoryRequest {
        return try Lnrpc.ForwardingHistoryRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ForwardingHistoryRequest {
        return try Lnrpc.ForwardingHistoryRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ForwardingHistoryRequest {
        return try Lnrpc.ForwardingHistoryRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ForwardingHistoryRequest {
        return try Lnrpc.ForwardingHistoryRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "startTime": return self.startTime
        case "endTime": return self.endTime
        case "indexOffset": return self.indexOffset
        case "numMaxEvents": return self.numMaxEvents
        default: return nil
        }
    }
}
extension Lnrpc.ForwardingHistoryRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ForwardingHistoryRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "startTime": return self.startTime
            case "endTime": return self.endTime
            case "indexOffset": return self.indexOffset
            case "numMaxEvents": return self.numMaxEvents
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "startTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.startTime = newSubscriptValue
            case "endTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.endTime = newSubscriptValue
            case "indexOffset":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.indexOffset = newSubscriptValue
            case "numMaxEvents":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.numMaxEvents = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.ForwardingEvent: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ForwardingEvent> {
        var mergedArray = Array<Lnrpc.ForwardingEvent>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ForwardingEvent? {
        return try Lnrpc.ForwardingEvent.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ForwardingEvent {
        return try Lnrpc.ForwardingEvent.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ForwardingEvent {
        return try Lnrpc.ForwardingEvent.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ForwardingEvent {
        return try Lnrpc.ForwardingEvent.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ForwardingEvent {
        return try Lnrpc.ForwardingEvent.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ForwardingEvent {
        return try Lnrpc.ForwardingEvent.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ForwardingEvent {
        return try Lnrpc.ForwardingEvent.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "timestamp": return self.timestamp
        case "chanIdIn": return self.chanIdIn
        case "chanIdOut": return self.chanIdOut
        case "amtIn": return self.amtIn
        case "amtOut": return self.amtOut
        case "fee": return self.fee
        default: return nil
        }
    }
}
extension Lnrpc.ForwardingEvent.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ForwardingEvent
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "timestamp": return self.timestamp
            case "chanIdIn": return self.chanIdIn
            case "chanIdOut": return self.chanIdOut
            case "amtIn": return self.amtIn
            case "amtOut": return self.amtOut
            case "fee": return self.fee
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "timestamp":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.timestamp = newSubscriptValue
            case "chanIdIn":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.chanIdIn = newSubscriptValue
            case "chanIdOut":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.chanIdOut = newSubscriptValue
            case "amtIn":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.amtIn = newSubscriptValue
            case "amtOut":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.amtOut = newSubscriptValue
            case "fee":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.fee = newSubscriptValue
            default: return
            }
        }
    }
}
extension Lnrpc.ForwardingHistoryResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Lnrpc.ForwardingHistoryResponse> {
        var mergedArray = Array<Lnrpc.ForwardingHistoryResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Lnrpc.ForwardingHistoryResponse? {
        return try Lnrpc.ForwardingHistoryResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Lnrpc.ForwardingHistoryResponse {
        return try Lnrpc.ForwardingHistoryResponse.Builder().mergeFrom(data: data, extensionRegistry:Lnrpc.RpcRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ForwardingHistoryResponse {
        return try Lnrpc.ForwardingHistoryResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Lnrpc.ForwardingHistoryResponse {
        return try Lnrpc.ForwardingHistoryResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ForwardingHistoryResponse {
        return try Lnrpc.ForwardingHistoryResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Lnrpc.ForwardingHistoryResponse {
        return try Lnrpc.ForwardingHistoryResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Lnrpc.ForwardingHistoryResponse {
        return try Lnrpc.ForwardingHistoryResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "forwardingEvents": return self.forwardingEvents
        case "lastOffsetIndex": return self.lastOffsetIndex
        default: return nil
        }
    }
}
extension Lnrpc.ForwardingHistoryResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Lnrpc.ForwardingHistoryResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "forwardingEvents": return self.forwardingEvents
            case "lastOffsetIndex": return self.lastOffsetIndex
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "forwardingEvents":
                guard let newSubscriptValue = newSubscriptValue as? Array<Lnrpc.ForwardingEvent> else {
                    return
                }
                self.forwardingEvents = newSubscriptValue
            case "lastOffsetIndex":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.lastOffsetIndex = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
