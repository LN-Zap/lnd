// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: signrpc/signer.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Signrpc_KeyLocator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The family of key being identified.
  var keyFamily: Int32 = 0

  //// The precise index of the key being identified.
  var keyIndex: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_KeyDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The raw bytes of the key being identified. Either this or the KeyLocator
  ///must be specified.
  var rawKeyBytes: Data {
    get {return _storage._rawKeyBytes}
    set {_uniqueStorage()._rawKeyBytes = newValue}
  }

  ///* 
  ///The key locator that identifies which key to use for signing. Either this
  ///or the raw bytes of the target key must be specified.
  var keyLoc: Signrpc_KeyLocator {
    get {return _storage._keyLoc ?? Signrpc_KeyLocator()}
    set {_uniqueStorage()._keyLoc = newValue}
  }
  /// Returns true if `keyLoc` has been explicitly set.
  var hasKeyLoc: Bool {return _storage._keyLoc != nil}
  /// Clears the value of `keyLoc`. Subsequent reads from it will return its default value.
  mutating func clearKeyLoc() {_uniqueStorage()._keyLoc = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Signrpc_TxOut {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The value of the output being spent.
  var value: Int64 = 0

  //// The script of the output being spent.
  var pkScript: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_SignDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///A descriptor that precisely describes *which* key to use for signing. This
  ///may provide the raw public key directly, or require the Signer to re-derive
  ///the key according to the populated derivation path.
  var keyDesc: Signrpc_KeyDescriptor {
    get {return _storage._keyDesc ?? Signrpc_KeyDescriptor()}
    set {_uniqueStorage()._keyDesc = newValue}
  }
  /// Returns true if `keyDesc` has been explicitly set.
  var hasKeyDesc: Bool {return _storage._keyDesc != nil}
  /// Clears the value of `keyDesc`. Subsequent reads from it will return its default value.
  mutating func clearKeyDesc() {_uniqueStorage()._keyDesc = nil}

  ///*
  ///A scalar value that will be added to the private key corresponding to the
  ///above public key to obtain the private key to be used to sign this input.
  ///This value is typically derived via the following computation:
  ///
  /// derivedKey = privkey + sha256(perCommitmentPoint || pubKey) mod N
  var singleTweak: Data {
    get {return _storage._singleTweak}
    set {_uniqueStorage()._singleTweak = newValue}
  }

  ///*
  ///A private key that will be used in combination with its corresponding
  ///private key to derive the private key that is to be used to sign the target
  ///input. Within the Lightning protocol, this value is typically the
  ///commitment secret from a previously revoked commitment transaction. This
  ///value is in combination with two hash values, and the original private key
  ///to derive the private key to be used when signing.
  ///
  /// k = (privKey*sha256(pubKey || tweakPub) +
  ///tweakPriv*sha256(tweakPub || pubKey)) mod N
  var doubleTweak: Data {
    get {return _storage._doubleTweak}
    set {_uniqueStorage()._doubleTweak = newValue}
  }

  ///*
  ///The full script required to properly redeem the output.  This field will
  ///only be populated if a p2wsh or a p2sh output is being signed.
  var witnessScript: Data {
    get {return _storage._witnessScript}
    set {_uniqueStorage()._witnessScript = newValue}
  }

  ///*
  ///A description of the output being spent. The value and script MUST be provided.
  var output: Signrpc_TxOut {
    get {return _storage._output ?? Signrpc_TxOut()}
    set {_uniqueStorage()._output = newValue}
  }
  /// Returns true if `output` has been explicitly set.
  var hasOutput: Bool {return _storage._output != nil}
  /// Clears the value of `output`. Subsequent reads from it will return its default value.
  mutating func clearOutput() {_uniqueStorage()._output = nil}

  ///*
  ///The target sighash type that should be used when generating the final
  ///sighash, and signature.
  var sighash: UInt32 {
    get {return _storage._sighash}
    set {_uniqueStorage()._sighash = newValue}
  }

  ///*
  ///The target input within the transaction that should be signed.
  var inputIndex: Int32 {
    get {return _storage._inputIndex}
    set {_uniqueStorage()._inputIndex = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Signrpc_SignReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The raw bytes of the transaction to be signed.
  var rawTxBytes: Data = SwiftProtobuf.Internal.emptyData

  //// A set of sign descriptors, for each input to be signed.
  var signDescs: [Signrpc_SignDescriptor] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_SignResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///A set of signatures realized in a fixed 64-byte format ordered in ascending
  ///input order.
  var rawSigs: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_InputScript {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The serializes witness stack for the specified input.
  var witness: [Data] = []

  ///**
  ///The optional sig script for the specified witness that will only be set if
  ///the input specified is a nested p2sh witness program.
  var sigScript: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signrpc_InputScriptResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The set of fully valid input scripts requested.
  var inputScripts: [Signrpc_InputScript] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "signrpc"

extension Signrpc_KeyLocator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyLocator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_family"),
    2: .standard(proto: "key_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.keyFamily)
      case 2: try decoder.decodeSingularInt32Field(value: &self.keyIndex)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.keyFamily != 0 {
      try visitor.visitSingularInt32Field(value: self.keyFamily, fieldNumber: 1)
    }
    if self.keyIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.keyIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_KeyLocator, rhs: Signrpc_KeyLocator) -> Bool {
    if lhs.keyFamily != rhs.keyFamily {return false}
    if lhs.keyIndex != rhs.keyIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_KeyDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_key_bytes"),
    2: .standard(proto: "key_loc"),
  ]

  fileprivate class _StorageClass {
    var _rawKeyBytes: Data = SwiftProtobuf.Internal.emptyData
    var _keyLoc: Signrpc_KeyLocator? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _rawKeyBytes = source._rawKeyBytes
      _keyLoc = source._keyLoc
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._rawKeyBytes)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._keyLoc)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._rawKeyBytes.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._rawKeyBytes, fieldNumber: 1)
      }
      if let v = _storage._keyLoc {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_KeyDescriptor, rhs: Signrpc_KeyDescriptor) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._rawKeyBytes != rhs_storage._rawKeyBytes {return false}
        if _storage._keyLoc != rhs_storage._keyLoc {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_TxOut: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxOut"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "pk_script"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.value)
      case 2: try decoder.decodeSingularBytesField(value: &self.pkScript)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 1)
    }
    if !self.pkScript.isEmpty {
      try visitor.visitSingularBytesField(value: self.pkScript, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_TxOut, rhs: Signrpc_TxOut) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.pkScript != rhs.pkScript {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_SignDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_desc"),
    2: .standard(proto: "single_tweak"),
    3: .standard(proto: "double_tweak"),
    4: .standard(proto: "witness_script"),
    5: .same(proto: "output"),
    7: .same(proto: "sighash"),
    8: .standard(proto: "input_index"),
  ]

  fileprivate class _StorageClass {
    var _keyDesc: Signrpc_KeyDescriptor? = nil
    var _singleTweak: Data = SwiftProtobuf.Internal.emptyData
    var _doubleTweak: Data = SwiftProtobuf.Internal.emptyData
    var _witnessScript: Data = SwiftProtobuf.Internal.emptyData
    var _output: Signrpc_TxOut? = nil
    var _sighash: UInt32 = 0
    var _inputIndex: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _keyDesc = source._keyDesc
      _singleTweak = source._singleTweak
      _doubleTweak = source._doubleTweak
      _witnessScript = source._witnessScript
      _output = source._output
      _sighash = source._sighash
      _inputIndex = source._inputIndex
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._keyDesc)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._singleTweak)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._doubleTweak)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._witnessScript)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._output)
        case 7: try decoder.decodeSingularUInt32Field(value: &_storage._sighash)
        case 8: try decoder.decodeSingularInt32Field(value: &_storage._inputIndex)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._keyDesc {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._singleTweak.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._singleTweak, fieldNumber: 2)
      }
      if !_storage._doubleTweak.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._doubleTweak, fieldNumber: 3)
      }
      if !_storage._witnessScript.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._witnessScript, fieldNumber: 4)
      }
      if let v = _storage._output {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if _storage._sighash != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._sighash, fieldNumber: 7)
      }
      if _storage._inputIndex != 0 {
        try visitor.visitSingularInt32Field(value: _storage._inputIndex, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_SignDescriptor, rhs: Signrpc_SignDescriptor) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._keyDesc != rhs_storage._keyDesc {return false}
        if _storage._singleTweak != rhs_storage._singleTweak {return false}
        if _storage._doubleTweak != rhs_storage._doubleTweak {return false}
        if _storage._witnessScript != rhs_storage._witnessScript {return false}
        if _storage._output != rhs_storage._output {return false}
        if _storage._sighash != rhs_storage._sighash {return false}
        if _storage._inputIndex != rhs_storage._inputIndex {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_SignReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_tx_bytes"),
    2: .standard(proto: "sign_descs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.rawTxBytes)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.signDescs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rawTxBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawTxBytes, fieldNumber: 1)
    }
    if !self.signDescs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signDescs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_SignReq, rhs: Signrpc_SignReq) -> Bool {
    if lhs.rawTxBytes != rhs.rawTxBytes {return false}
    if lhs.signDescs != rhs.signDescs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_SignResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_sigs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedBytesField(value: &self.rawSigs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rawSigs.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.rawSigs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_SignResp, rhs: Signrpc_SignResp) -> Bool {
    if lhs.rawSigs != rhs.rawSigs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_InputScript: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InputScript"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "witness"),
    2: .standard(proto: "sig_script"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedBytesField(value: &self.witness)
      case 2: try decoder.decodeSingularBytesField(value: &self.sigScript)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.witness.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.witness, fieldNumber: 1)
    }
    if !self.sigScript.isEmpty {
      try visitor.visitSingularBytesField(value: self.sigScript, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_InputScript, rhs: Signrpc_InputScript) -> Bool {
    if lhs.witness != rhs.witness {return false}
    if lhs.sigScript != rhs.sigScript {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signrpc_InputScriptResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InputScriptResp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "input_scripts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.inputScripts)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputScripts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputScripts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signrpc_InputScriptResp, rhs: Signrpc_InputScriptResp) -> Bool {
    if lhs.inputScripts != rhs.inputScripts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
